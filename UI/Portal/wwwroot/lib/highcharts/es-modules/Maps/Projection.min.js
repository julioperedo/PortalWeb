"use strict";import PC from"../Core/Geometry/PolygonClip.js";const{clipLineString,clipPolygon}=PC;import ProjectionRegistry from"./Projections/ProjectionRegistry.js";import U from"../Core/Utilities.js";const{clamp,erase}=U,deg2rad=2*Math.PI/360,floatCorrection=1e-6;function wrapLon(t){return t<-180&&(t+=360),180<t&&(t-=360),t}class Projection{static add(t,r){Projection.registry[t]=r}static greatCircle(t,r,e){const{atan2:o,cos:i,sin:a,sqrt:n}=Math,s=t[1]*deg2rad,c=t[0]*deg2rad,l=r[1]*deg2rad,h=r[0]*deg2rad,d=l-s,f=h-c,g=a(d/2)*a(d/2)+i(s)*i(l)*a(f/2)*a(f/2),u=2*o(n(g),n(1-g)),p=6371e3*u,M=Math.round(p/5e5),P=[];if(e&&P.push(t),1<M){var v=1/M;for(let t=v;t<.999;t+=v){var y=a((1-t)*u)/a(u),C=a(t*u)/a(u),j=y*i(s)*i(c)+C*i(l)*i(h),m=y*i(s)*a(c)+C*i(l)*a(h),y=y*a(s)+C*a(l),C=o(y,n(j*j+m*m)),y=o(m,j);P.push([y/deg2rad,C/deg2rad])}}return e&&P.push(r),P}static insertGreatCircles(t){let r=t.length-1;for(;r--;){var e;10<Math.max(Math.abs(t[r][0]-t[r+1][0]),Math.abs(t[r][1]-t[r+1][1]))&&((e=Projection.greatCircle(t[r],t[r+1])).length&&t.splice(r+1,0,...e))}}static toString(t){const{name:r,rotation:e}=t||{};return[r,e&&e.join(",")].join(";")}constructor(t={}){this.hasCoordinates=!1,this.hasGeoProjection=!1,this.maxLatitude=90;var{name:r,projectedBounds:e,rotation:o}=this.options=t;this.rotator=o?this.getRotator(o):void 0;const i=r?Projection.registry[r]:void 0,{def:a,rotator:n}=(i&&(this.def=new i(t)),this);a&&(this.maxLatitude=a.maxLatitude||90,this.hasGeoProjection=!0),n&&a?(this.forward=t=>a.forward(n.forward(t)),this.inverse=t=>n.inverse(a.inverse(t))):a?(this.forward=t=>a.forward(t),this.inverse=t=>a.inverse(t)):n&&(this.forward=n.forward,this.inverse=n.inverse),this.bounds="world"===e?a&&a.bounds:e}lineIntersectsBounds(t){var{x1:r,x2:e,y1:o,y2:i}=this.bounds||{},a=(t,r,e)=>{var o,[t,i]=t,a=r?0:1;if("number"==typeof e&&t[r]>=e!=i[r]>=e)return o=(e-t[r])/(i[r]-t[r]),o=t[a]+o*(i[a]-t[a]),r?[o,e]:[e,o]};let n,s=t[0];return((n=a(t,0,r))||(n=a(t,0,e)))&&(s=n,t[1]=n),s=(n=a(t,1,o))||(n=a(t,1,i))?n:s}getRotator(t){const i=t[0]*deg2rad,r=(t[1]||0)*deg2rad,e=(t[2]||0)*deg2rad,a=Math.cos(r),n=Math.sin(r),s=Math.cos(e),c=Math.sin(e);if(0!=i||0!=r||0!=e)return{forward:t=>{var r=t[0]*deg2rad+i,t=t[1]*deg2rad,e=Math.cos(t),o=Math.cos(r)*e,r=Math.sin(r)*e,e=Math.sin(t),t=e*a+o*n;return[Math.atan2(r*s-t*c,o*a-e*n)/deg2rad,Math.asin(t*s+r*c)/deg2rad]},inverse:t=>{var r=t[0]*deg2rad,t=t[1]*deg2rad,e=Math.cos(t),o=Math.cos(r)*e,r=Math.sin(r)*e,e=Math.sin(t),t=e*s-r*c;return[(Math.atan2(r*s+e*c,o*a+t*n)-i)/deg2rad,Math.asin(t*a-o*n)/deg2rad]}}}forward(t){return t}inverse(t){return t}cutOnAntimeridian(e,o){const i=[],r=[e];for(let r=0,t=e.length;r<t;++r){var a=e[r];let t=e[r-1];if(!r){if(!o)continue;t=e[e.length-1]}var n=t[0],s=a[0];(n<-90||90<n)&&(s<-90||90<s)&&0<n!=0<s&&(s=clamp((180-(n+360)%360)/((s+360)%360-(n+360)%360),0,1),s=t[1]+s*(a[1]-t[1]),i.push({i:r,lat:s,direction:n<0?1:-1,previousLonLat:t,lonLat:a}))}let c;if(i.length)if(o){i.length%2==1&&(c=i.slice().sort((t,r)=>Math.abs(r.lat)-Math.abs(t.lat))[0],erase(i,c));let t=i.length-2;for(;0<=t;){var l=i[t].i,h=wrapLon(180+i[t].direction*floatCorrection),d=wrapLon(180-i[t].direction*floatCorrection);const M=e.splice(l,i[t+1].i-l,...Projection.greatCircle([h,i[t].lat],[h,i[t+1].lat],!0));M.push(...Projection.greatCircle([d,i[t+1].lat],[d,i[t].lat],!0)),r.push(M),t-=2}if(c)for(let t=0;t<r.length;t++){const{direction:P,lat:v}=c,e=r[t],y=e.indexOf(c.lonLat);if(-1<y){var f=(v<0?-1:1)*this.maxLatitude,g=wrapLon(180+P*floatCorrection),u=wrapLon(180-P*floatCorrection);const C=Projection.greatCircle([g,v],[g,f],!0);for(let t=g+120*P;-180<t&&t<180;t+=120*P)C.push([t,f]);C.push(...Projection.greatCircle([u,f],[u,c.lat],!0)),e.splice(y,0,...C);break}}}else{let t=i.length;for(;t--;){var p=i[t].i;const j=e.splice(p,e.length,[wrapLon(180+i[t].direction*floatCorrection),i[t].lat]);j.unshift([wrapLon(180-i[t].direction*floatCorrection),i[t].lat]),r.push(j)}}return r}path(t){const{bounds:g,def:r,rotator:e}=this,u=[],p="Polygon"===t.type||"MultiPolygon"===t.type,M=this.hasGeoProjection,P=!r||!1!==r.antimeridianCutting,o=P?e:void 0,v=P&&r||this;let y;g&&(y=[[g.x1,g.y1],[g.x2,g.y1],[g.x2,g.y2],[g.x1,g.y2]]);const i=t=>{t=t.map(r=>{if(P){let t=(r=o?o.forward(r):r)[0];r=[t=Math.abs(t-180)<floatCorrection?t<180?180-floatCorrection:180+floatCorrection:t,r[1]]}return r});let r=[t];M&&(Projection.insertGreatCircles(t),P&&(r=this.cutOnAntimeridian(t,p))),r.forEach(c=>{if(!(c.length<2)){let r=!1,e,o,i=!1;const d=t=>{r?u.push(["L",t[0],t[1]]):(u.push(["M",t[0],t[1]]),r=!0)};let a=!1,n=!1,s=c.map(t=>{const r=v.forward(t);return r.outside?a=!0:n=!0,r[1]===1/0?r[1]=1e10:r[1]===-1/0&&(r[1]=-1e10),r});if(P){if(p&&s.push(s[0]),a){if(!n)return;if(y)if(p)s=clipPolygon(s,y);else if(g)return void clipLineString(s,y).forEach(t=>{r=!1,t.forEach(d)})}s.forEach(d)}else for(let t=0;t<s.length;t++){var l=c[t],h=s[t];if(h.outside)i=!0;else{if(p&&!e&&(e=l,c.push(l),s.push(h)),i&&o)if(p&&M){const f=Projection.greatCircle(o,l);f.forEach(t=>d(v.forward(t)))}else r=!1;d(h),o=l,i=!1}}}})};return"LineString"===t.type?i(t.coordinates):"MultiLineString"===t.type?t.coordinates.forEach(t=>i(t)):"Polygon"===t.type?(t.coordinates.forEach(t=>i(t)),u.length&&u.push(["Z"])):"MultiPolygon"===t.type&&(t.coordinates.forEach(t=>{t.forEach(t=>i(t))}),u.length&&u.push(["Z"])),u}}Projection.registry=ProjectionRegistry;export default Projection;