"use strict";const sign=Math.sign||(a=>0===a?0:0<a?1:-1),scale=63.78137,deg2rad=Math.PI/180,halfPI=Math.PI/2,eps10=1e-6,tany=a=>Math.tan((halfPI+a)/2);class LambertConformalConic{constructor(a){var t=(a.parallels||[]).map(a=>a*deg2rad),s=t[0]||0,t=t[1]??s,e=Math.cos(s);"object"==typeof a.projectedBounds&&(this.projectedBounds=a.projectedBounds);let n=s===t?Math.sin(s):Math.log(e/Math.cos(t))/Math.log(tany(t)/tany(s));Math.abs(n)<1e-10&&(n=1e-10*(sign(n)||1)),this.n=n,this.c=e*Math.pow(tany(s),n)/n}forward(a){var{c:t,n:s,projectedBounds:e}=this,n=a[0]*deg2rad;let h=a[1]*deg2rad;0<t?h<-halfPI+eps10&&(h=-halfPI+eps10):h>halfPI-eps10&&(h=halfPI-eps10);const o=t/Math.pow(tany(h),s),r=o*Math.sin(s*n)*scale,c=(t-o*Math.cos(s*n))*scale,l=[r,c];return e&&(r<e.x1||r>e.x2||c<e.y1||c>e.y2)&&(l.outside=!0),l}inverse(a){var{c:t,n:s}=this,e=a[0]/scale,a=t-a[1]/scale,n=sign(s)*Math.sqrt(e*e+a*a);let h=Math.atan2(e,Math.abs(a))*sign(a);return a*s<0&&(h-=Math.PI*sign(e)*sign(a)),[h/s/deg2rad,(2*Math.atan(Math.pow(t/n,1/s))-halfPI)/deg2rad]}}export default LambertConformalConic;