"use strict";import Chart from"../parts/Chart.js";import H from"../parts/Globals.js";import O from"../parts/Options.js";var defaultOptions=O.defaultOptions;import Point from"../parts/Point.js";import SVGRenderer from"../parts/SVGRenderer.js";import U from"../parts/Utilities.js";var addEvent=U.addEvent,animObject=U.animObject,defined=U.defined,error=U.error,isArray=U.isArray,isFunction=U.isFunction,isObject=U.isObject,isNumber=U.isNumber,merge=U.merge,objectEach=U.objectEach,relativeLength=U.relativeLength,syncTimeout=U.syncTimeout;import"../parts/Axis.js";import"../parts/Series.js";var Series=H.Series,Scatter=H.seriesTypes.scatter,baseGeneratePoints=Series.prototype.generatePoints,stateIdCounter=0,oldPointsStateId=[],clusterDefaultOptions={enabled:!1,allowOverlap:!0,animation:{duration:500},drillToCluster:!0,minimumClusterSize:2,layoutAlgorithm:{gridSize:50,distance:40,kmeansThreshold:100},marker:{symbol:"cluster",radius:15,lineWidth:0,lineColor:"#ffffff"},dataLabels:{enabled:!0,format:"{point.clusterPointsAmount}",verticalAlign:"middle",align:"center",style:{color:"contrast"},inside:!0}};function getClusterPosition(t){var e,i=t.length,a=0,r=0;for(e=0;e<i;e++)a+=t[e].x,r+=t[e].y;return{x:a/i,y:r/i}}function getDataState(t,e){var i=[];return i.length=e,t.clusters.forEach(function(t){t.data.forEach(function(t){i[t.dataIndex]=t})}),t.noise.forEach(function(t){i[t.data[0].dataIndex]=t.data[0]}),i}function fadeInElement(t,e,i){t.attr({opacity:e}).animate({opacity:1},i)}function fadeInStatePoint(t,e,i,a,r){t.point&&(a&&t.point.graphic&&(t.point.graphic.show(),fadeInElement(t.point.graphic,e,i)),r&&t.point.dataLabel&&(t.point.dataLabel.show(),fadeInElement(t.point.dataLabel,e,i)))}function hideStatePoint(t,e,i){t.point&&(e&&t.point.graphic&&t.point.graphic.hide(),i&&t.point.dataLabel&&t.point.dataLabel.hide())}function destroyOldPoints(t){t&&objectEach(t,function(t){t.point&&t.point.destroy&&t.point.destroy()})}function fadeInNewPointAndDestoryOld(t,e,i,a){fadeInStatePoint(t,a,i,!0,!0),e.forEach(function(t){t.point&&t.point.destroy&&t.point.destroy()})}function getStateId(){return Math.random().toString(36).substring(2,7)+"-"+stateIdCounter++}(defaultOptions.plotOptions||{}).series=merge((defaultOptions.plotOptions||{}).series,{cluster:clusterDefaultOptions,tooltip:{clusterFormat:"<span>Clustered points: {point.clusterPointsAmount}</span><br/>"}}),SVGRenderer.prototype.symbols.cluster=function(t,e,i,a){var r,s,o=i/2,n=a/2;return r=this.arc(t+o,e+n,o-4,n-4,{start:.5*Math.PI,end:2.5*Math.PI,open:!1}),s=this.arc(t+o,e+n,o-3,n-3,{start:.5*Math.PI,end:2.5*Math.PI,innerR:o-2,open:!1}),this.arc(t+o,e+n,o-1,n-1,{start:.5*Math.PI,end:2.5*Math.PI,innerR:o,open:!1}).concat(s,r)},Scatter.prototype.animateClusterPoint=function(t){var e,i,a,r=this.xAxis,s=this.yAxis,o=this.chart,n=this.options.cluster,l=animObject((n||{}).animation),p=l.duration||500,d=(this.markerClusterInfo||{}).pointsState,u=(d||{}).newState,h=(d||{}).oldState,c=[],f=0,m=0,g=0,x=!1,y=!1;h&&u&&(a=u[t.stateId],m=r.toPixels(a.x)-o.plotLeft,g=s.toPixels(a.y)-o.plotTop,1===a.parentsId.length?(e=(u||{})[t.stateId].parentsId[0],i=h[e],a.point&&a.point.graphic&&i&&i.point&&i.point.plotX&&i.point.plotY&&i.point.plotX!==a.point.plotX&&i.point.plotY!==a.point.plotY&&(f=a.point.graphic.getBBox().width/2,a.point.graphic.attr({x:i.point.plotX-f,y:i.point.plotY-f}),a.point.graphic.animate({x:m-a.point.graphic.radius,y:g-a.point.graphic.radius},l,function(){y=!0,i.point&&i.point.destroy&&i.point.destroy()}),a.point.dataLabel&&a.point.dataLabel.alignAttr&&i.point.dataLabel&&i.point.dataLabel.alignAttr&&(a.point.dataLabel.attr({x:i.point.dataLabel.alignAttr.x,y:i.point.dataLabel.alignAttr.y}),a.point.dataLabel.animate({x:a.point.dataLabel.alignAttr.x,y:a.point.dataLabel.alignAttr.y},l)))):0===a.parentsId.length?(hideStatePoint(a,!0,!0),syncTimeout(function(){fadeInStatePoint(a,.1,l,!0,!0)},p/2)):(hideStatePoint(a,!0,!0),a.parentsId.forEach(function(t){h&&h[t]&&(i=h[t],c.push(i),i.point&&i.point.graphic&&(x=!0,i.point.graphic.show(),i.point.graphic.animate({x:m-i.point.graphic.radius,y:g-i.point.graphic.radius,opacity:.4},l,function(){y=!0,fadeInNewPointAndDestoryOld(a,c,l,.7)}),i.point.dataLabel&&-9999!==i.point.dataLabel.y&&a.point&&a.point.dataLabel&&a.point.dataLabel.alignAttr&&(i.point.dataLabel.show(),i.point.dataLabel.animate({x:a.point.dataLabel.alignAttr.x,y:a.point.dataLabel.alignAttr.y,opacity:.4},l))))}),syncTimeout(function(){y||fadeInNewPointAndDestoryOld(a,c,l,.85)},p),x||syncTimeout(function(){fadeInNewPointAndDestoryOld(a,c,l,.1)},p/2)))},Scatter.prototype.getGridOffset=function(){var t=this.chart,e=this.xAxis,i=this.yAxis;return{plotLeft:this.dataMinX&&this.dataMaxX?e.reversed?e.toPixels(this.dataMaxX):e.toPixels(this.dataMinX):t.plotLeft,plotTop:this.dataMinY&&this.dataMaxY?i.reversed?i.toPixels(this.dataMinY):i.toPixels(this.dataMaxY):t.plotTop}},Scatter.prototype.getScaledGridSize=function(t){var e,i,a=this.xAxis,r=!0,s=1,o=1,n=t.processedGridSize||clusterDefaultOptions.layoutAlgorithm.gridSize;for(this.gridValueSize||(this.gridValueSize=Math.abs(a.toValue(n)-a.toValue(0))),e=+(n/(a.toPixels(this.gridValueSize)-a.toPixels(0))).toFixed(14);r&&1!==e;)i=Math.pow(2,s),e>.75&&e<1.25?r=!1:e>=1/i&&e<1/i*2?(r=!1,o=i):e<=i&&e>i/2&&(r=!1,o=1/i),s++;return n/o/e},Scatter.prototype.getRealExtremes=function(){var t,e,i=this.chart,a=this.xAxis,r=this.yAxis,s=a?a.toValue(i.plotLeft):0,o=a?a.toValue(i.plotLeft+i.plotWidth):0,n=r?r.toValue(i.plotTop):0,l=r?r.toValue(i.plotTop+i.plotHeight):0;return s>o&&(o=(t=[s,o])[0],s=t[1]),n>l&&(l=(e=[n,l])[0],n=e[1]),{minX:s,maxX:o,minY:n,maxY:l}},Scatter.prototype.onDrillToCluster=function(t){(t.point||t.target).firePointEvent("drillToCluster",t,function(t){var e,i,a,r,s,o,n,l,p,d,u=t.point||t.target,h=u.series,c=u.series.xAxis,f=u.series.yAxis,m=u.series.chart;(h.options.cluster||{}).drillToCluster&&u.clusteredData&&(s=u.clusteredData.map(function(t){return t.x}).sort(function(t,e){return t-e}),o=u.clusteredData.map(function(t){return t.y}).sort(function(t,e){return t-e}),n=s[0],p=s[s.length-1],l=o[0],d=o[o.length-1],a=Math.abs(.1*(p-n)),r=Math.abs(.1*(d-l)),m.pointer.zoomX=!0,m.pointer.zoomY=!0,n>p&&(n=(e=[p,n])[0],p=e[1]),l>d&&(l=(i=[d,l])[0],d=i[1]),m.zoom({originalEvent:t,xAxis:[{axis:c,min:n-a,max:p+a}],yAxis:[{axis:f,min:l-r,max:d+r}]}))})},Scatter.prototype.getClusterDistancesFromPoint=function(t,e,i){var a,r,s=this.xAxis,o=this.yAxis,n=[];for(a=0;a<t.length;a++)r=Math.sqrt(Math.pow(s.toPixels(e)-s.toPixels(t[a].posX),2)+Math.pow(o.toPixels(i)-o.toPixels(t[a].posY),2)),n.push({clusterIndex:a,distance:r});return n.sort(function(t,e){return t.distance-e.distance})},Scatter.prototype.getPointsState=function(t,e,i){var a,r,s,o=e?getDataState(e,i):[],n=getDataState(t,i),l={};for(oldPointsStateId=[],t.clusters.forEach(function(t){l[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),t.noise.forEach(function(t){l[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),s=0;s<n.length;s++)a=n[s],r=o[s],a&&r&&a.parentStateId&&r.parentStateId&&l[a.parentStateId]&&-1===l[a.parentStateId].parentsId.indexOf(r.parentStateId)&&(l[a.parentStateId].parentsId.push(r.parentStateId),-1===oldPointsStateId.indexOf(r.parentStateId)&&oldPointsStateId.push(r.parentStateId));return l},Scatter.prototype.markerClusterAlgorithms={grid:function(t,e,i,a){var r,s,o,n,l,p,d=this.xAxis,u=this.yAxis,h={},c=this.getGridOffset();for(r=this.getScaledGridSize(a),p=0;p<t.length;p++)s=d.toPixels(t[p])-c.plotLeft,o=u.toPixels(e[p])-c.plotTop,n=Math.floor(s/r),h[l=Math.floor(o/r)+"-"+n]||(h[l]=[]),h[l].push({dataIndex:i[p],x:t[p],y:e[p]});return h},kmeans:function(t,e,i,a){var r,s,o,n,l,p=[],d=[],u={},h=a.processedDistance||clusterDefaultOptions.layoutAlgorithm.distance,c=a.iterations,f=0,m=!0,g=0,x=0,y=[];for(o in a.processedGridSize=a.processedDistance,s=this.markerClusterAlgorithms?this.markerClusterAlgorithms.grid.call(this,t,e,i,a):{})s[o].length>1&&(r=getClusterPosition(s[o]),p.push({posX:r.x,posY:r.y,oldX:0,oldY:0,startPointsLen:s[o].length,points:[]}));for(;m;){for(p.map(function(t){return t.points.length=0,t}),d.length=0,n=0;n<t.length;n++)g=t[n],x=e[n],(y=this.getClusterDistancesFromPoint(p,g,x)).length&&y[0].distance<h?p[y[0].clusterIndex].points.push({x:g,y:x,dataIndex:i[n]}):d.push({x:g,y:x,dataIndex:i[n]});for(l=0;l<p.length;l++)1===p[l].points.length&&(y=this.getClusterDistancesFromPoint(p,p[l].points[0].x,p[l].points[0].y))[1].distance<h&&(p[y[1].clusterIndex].points.push(p[l].points[0]),p[y[0].clusterIndex].points.length=0);for(m=!1,l=0;l<p.length;l++)r=getClusterPosition(p[l].points),p[l].oldX=p[l].posX,p[l].oldY=p[l].posY,p[l].posX=r.x,p[l].posY=r.y,(p[l].posX>p[l].oldX+1||p[l].posX<p[l].oldX-1||p[l].posY>p[l].oldY+1||p[l].posY<p[l].oldY-1)&&(m=!0);c&&(m=f<c-1),f++}return p.forEach(function(t,e){u["cluster"+e]=t.points}),d.forEach(function(t,e){u["noise"+e]=[t]}),u},optimizedKmeans:function(t,e,i,a){var r,s,o=this.xAxis,n=this.yAxis,l=a.processedDistance||clusterDefaultOptions.layoutAlgorithm.gridSize,p={},d=this.getRealExtremes(),u=(this.options.cluster||{}).marker;return!this.markerClusterInfo||this.initMaxX&&this.initMaxX<d.maxX||this.initMinX&&this.initMinX>d.minX||this.initMaxY&&this.initMaxY<d.maxY||this.initMinY&&this.initMinY>d.minY?(this.initMaxX=d.maxX,this.initMinX=d.minX,this.initMaxY=d.maxY,this.initMinY=d.minY,p=this.markerClusterAlgorithms?this.markerClusterAlgorithms.kmeans.call(this,t,e,i,a):{},this.baseClusters=null):(this.baseClusters||(this.baseClusters={clusters:this.markerClusterInfo.clusters,noise:this.markerClusterInfo.noise}),this.baseClusters.clusters.forEach(function(t){t.pointsOutside=[],t.pointsInside=[],t.data.forEach(function(e){r=Math.sqrt(Math.pow(o.toPixels(e.x)-o.toPixels(t.x),2)+Math.pow(n.toPixels(e.y)-n.toPixels(t.y),2)),s=t.clusterZone&&t.clusterZone.marker&&t.clusterZone.marker.radius?t.clusterZone.marker.radius:u&&u.radius?u.radius:clusterDefaultOptions.marker.radius,r>s+(l-s>=0?l-s:s)&&defined(t.pointsOutside)?t.pointsOutside.push(e):defined(t.pointsInside)&&t.pointsInside.push(e)}),t.pointsInside.length&&(p[t.id]=t.pointsInside),t.pointsOutside.forEach(function(e,i){p[t.id+"_noise"+i]=[e]})}),this.baseClusters.noise.forEach(function(t){p[t.id]=t.data})),p}},Scatter.prototype.preventClusterCollisions=function(t){var e,i,a,r,s,o,n,l,p,d,u,h,c,f,m,g=this.xAxis,x=this.yAxis,y=t.key.split("-").map(parseFloat),S=y[0],I=y[1],C=t.gridSize,b=t.groupedData,P=t.defaultRadius,D=t.clusterRadius,k=I*C,A=S*C,M=g.toPixels(t.x),v=x.toPixels(t.y),O=[],E=0,L=0,X=(this.options.cluster||{}).marker,Y=(this.options.cluster||{}).zones,z=this.getGridOffset();for(M-=z.plotLeft,v-=z.plotTop,n=1;n<5;n++)for(a=n%2?-1:1,r=n<3?-1:1,s=Math.floor((M+a*D)/C),c=[(o=Math.floor((v+r*D)/C))+"-"+s,o+"-"+I,S+"-"+s],l=0;l<c.length;l++)-1===O.indexOf(c[l])&&c[l]!==t.key&&O.push(c[l]);return O.forEach(function(t){var a;if(b[t]){if(b[t].posX||(u=getClusterPosition(b[t]),b[t].posX=u.x,b[t].posY=u.y),e=g.toPixels(b[t].posX||0)-z.plotLeft,i=x.toPixels(b[t].posY||0)-z.plotTop,a=t.split("-").map(parseFloat),d=a[0],p=a[1],Y)for(E=b[t].length,n=0;n<Y.length;n++)E>=Y[n].from&&E<=Y[n].to&&(L=defined((Y[n].marker||{}).radius)?Y[n].marker.radius||0:X&&X.radius?X.radius:clusterDefaultOptions.marker.radius);b[t].length>1&&0===L&&X&&X.radius?L=X.radius:1===b[t].length&&(L=P),h=D+L,L=0,p!==I&&Math.abs(M-e)<h&&(M=p-I<0?k+D:k+C-D),d!==S&&Math.abs(v-i)<h&&(v=d-S<0?A+D:A+C-D)}}),f=g.toValue(M+z.plotLeft),m=x.toValue(v+z.plotTop),b[t.key].posX=f,b[t.key].posY=m,{x:f,y:m}},Scatter.prototype.isValidGroupedDataObject=function(t){var e,i=!1;return!!isObject(t)&&(objectEach(t,function(t){if(i=!0,isArray(t)&&t.length){for(e=0;e<t.length;e++)if(!isObject(t[e])||!t[e].x||!t[e].y)return void(i=!1)}else i=!1}),i)},Scatter.prototype.getClusteredData=function(t,e){var i,a,r,s,o,n,l,p,d,u,h,c,f,m,g=[],x=[],y=[],S=[],I=[],C=0,b=Math.max(2,e.minimumClusterSize||2);if(isFunction(e.layoutAlgorithm.type)&&!this.isValidGroupedDataObject(t))return error("Highcharts marker-clusters module: The custom algorithm result is not valid!",!1,this.chart),!1;for(m in t)if(t[m].length>=b){if(r=t[m],i=getStateId(),o=r.length,e.zones)for(f=0;f<e.zones.length;f++)o>=e.zones[f].from&&o<=e.zones[f].to&&((h=e.zones[f]).zoneIndex=f,u=e.zones[f].marker,c=e.zones[f].className);for(d=getClusterPosition(r),"grid"!==e.layoutAlgorithm.type||e.allowOverlap?l={x:d.x,y:d.y}:(n=this.options.marker||{},l=this.preventClusterCollisions({x:d.x,y:d.y,key:m,groupedData:t,gridSize:this.getScaledGridSize(e.layoutAlgorithm),defaultRadius:n.radius||3+(n.lineWidth||0),clusterRadius:u&&u.radius?u.radius:(e.marker||{}).radius||clusterDefaultOptions.marker.radius})),f=0;f<o;f++)r[f].parentStateId=i;if(y.push({x:l.x,y:l.y,id:m,stateId:i,index:C,data:r,clusterZone:h,clusterZoneClassName:c}),g.push(l.x),x.push(l.y),I.push({options:{formatPrefix:"cluster",dataLabels:e.dataLabels,marker:merge(e.marker,{states:e.states},u||{})}}),this.options.data&&this.options.data.length)for(f=0;f<o;f++)isObject(this.options.data[r[f].dataIndex])&&(r[f].options=this.options.data[r[f].dataIndex]);C++,u=null}else for(f=0;f<t[m].length;f++)a=t[m][f],i=getStateId(),p=null,s=((this.options||{}).data||[])[a.dataIndex],g.push(a.x),x.push(a.y),a.parentStateId=i,S.push({x:a.x,y:a.y,id:m,stateId:i,index:C,data:t[m]}),p=s&&"object"==typeof s&&!isArray(s)?merge(s,{x:a.x,y:a.y}):{userOptions:s,x:a.x,y:a.y},I.push({options:p}),C++;return{clusters:y,noise:S,groupedXData:g,groupedYData:x,groupMap:I}},Scatter.prototype.destroyClusteredData=function(){(this.markerClusterSeriesData||[]).forEach(function(t){t&&t.destroy&&t.destroy()}),this.markerClusterSeriesData=null},Scatter.prototype.hideClusteredData=function(){var t=this.markerClusterSeriesData,e=((this.markerClusterInfo||{}).pointsState||{}).oldState||{},i=oldPointsStateId.map(function(t){return(e[t].point||{}).id||""});(t||[]).forEach(function(t){t&&-1!==i.indexOf(t.id)?(t.graphic&&t.graphic.hide(),t.dataLabel&&t.dataLabel.hide()):t&&t.destroy&&t.destroy()})},Scatter.prototype.generatePoints=function(){var t,e,i,a,r,s,o,n,l,p,d,u,h,c,f,m,g=this,x=g.chart,y=g.xAxis,S=g.yAxis,I=g.options.cluster,C=g.getRealExtremes(),b=[],P=[],D=[];if(I&&I.enabled&&g.xData&&g.yData&&!x.polar){for(d=I.layoutAlgorithm.type,(c=I.layoutAlgorithm).processedGridSize=relativeLength(c.gridSize||clusterDefaultOptions.layoutAlgorithm.gridSize,x.plotWidth),c.processedDistance=relativeLength(c.distance||clusterDefaultOptions.layoutAlgorithm.distance,x.plotWidth),a=c.kmeansThreshold||clusterDefaultOptions.layoutAlgorithm.kmeansThreshold,r=Math.abs(y.toValue(c.processedGridSize/2)-y.toValue(0)),s=Math.abs(S.toValue(c.processedGridSize/2)-S.toValue(0)),m=0;m<g.xData.length;m++)g.dataMaxX||(defined(n)&&defined(o)&&defined(p)&&defined(l)?isNumber(g.yData[m])&&isNumber(p)&&isNumber(l)&&(n=Math.max(g.xData[m],n),o=Math.min(g.xData[m],o),p=Math.max(g.yData[m]||p,p),l=Math.min(g.yData[m]||l,l)):(n=o=g.xData[m],p=l=g.yData[m])),g.xData[m]>=C.minX-r&&g.xData[m]<=C.maxX+r&&(g.yData[m]||C.minY)>=C.minY-s&&(g.yData[m]||C.maxY)<=C.maxY+s&&(b.push(g.xData[m]),P.push(g.yData[m]),D.push(m));defined(n)&&defined(o)&&isNumber(p)&&isNumber(l)&&(g.dataMaxX=n,g.dataMinX=o,g.dataMaxY=p,g.dataMinY=l),u=(h=(isFunction(d)?d:g.markerClusterAlgorithms?d&&g.markerClusterAlgorithms[d]?g.markerClusterAlgorithms[d]:b.length<a?g.markerClusterAlgorithms.kmeans:g.markerClusterAlgorithms.grid:function(){return!1}).call(this,b,P,D,c))?g.getClusteredData(h,I):h,I.animation&&g.markerClusterInfo&&g.markerClusterInfo.pointsState&&g.markerClusterInfo.pointsState.oldState?(destroyOldPoints(g.markerClusterInfo.pointsState.oldState),t=g.markerClusterInfo.pointsState.newState):t={},e=g.xData.length,i=g.markerClusterInfo,u&&(g.processedXData=u.groupedXData,g.processedYData=u.groupedYData,g.hasGroupedData=!0,g.markerClusterInfo=u,g.groupMap=u.groupMap),baseGeneratePoints.apply(this),u&&g.markerClusterInfo&&((g.markerClusterInfo.clusters||[]).forEach(function(t){(f=g.points[t.index]).isCluster=!0,f.clusteredData=t.data,f.clusterPointsAmount=t.data.length,t.point=f,addEvent(f,"click",g.onDrillToCluster)}),(g.markerClusterInfo.noise||[]).forEach(function(t){t.point=g.points[t.index]}),I.animation&&g.markerClusterInfo&&(g.markerClusterInfo.pointsState={oldState:t,newState:g.getPointsState(u,i,e)}),I.animation?this.hideClusteredData():this.destroyClusteredData(),this.markerClusterSeriesData=this.hasGroupedData?this.points:null)}else baseGeneratePoints.apply(this)},addEvent(Chart,"render",function(){(this.series||[]).forEach(function(t){if(t.markerClusterInfo){var e=t.options.cluster,i=((t.markerClusterInfo||{}).pointsState||{}).oldState;(e||{}).animation&&t.markerClusterInfo&&0===t.chart.pointer.pinchDown.length&&"pan"!==(t.xAxis.eventArgs||{}).trigger&&i&&Object.keys(i).length&&(t.markerClusterInfo.clusters.forEach(function(e){t.animateClusterPoint(e)}),t.markerClusterInfo.noise.forEach(function(e){t.animateClusterPoint(e)}))}})}),addEvent(Point,"update",function(){if(this.dataGroup)return error("Highcharts marker-clusters module: Running `Point.update` when point belongs to clustered series is not supported.",!1,this.series.chart),!1}),addEvent(Series,"destroy",Scatter.prototype.destroyClusteredData),addEvent(Series,"afterRender",function(){var t=(this.options.cluster||{}).drillToCluster;this.markerClusterInfo&&this.markerClusterInfo.clusters&&this.markerClusterInfo.clusters.forEach(function(e){e.point&&e.point.graphic&&(e.point.graphic.addClass("highcharts-cluster-point"),t&&e.point&&(e.point.graphic.css({cursor:"pointer"}),e.point.dataLabel&&e.point.dataLabel.css({cursor:"pointer"})),defined(e.clusterZone)&&e.point.graphic.addClass(e.clusterZoneClassName||"highcharts-cluster-zone-"+e.clusterZone.zoneIndex))})}),addEvent(Point,"drillToCluster",function(t){var e=(((t.point||t.target).series.options.cluster||{}).events||{}).drillToCluster;isFunction(e)&&e.call(this,t)}),addEvent(H.Axis,"setExtremes",function(){var t,e=this.chart,i=0;e.series.forEach(function(e){e.markerClusterInfo&&(t=animObject((e.options.cluster||{}).animation),i=t.duration||0)}),syncTimeout(function(){e.tooltip&&e.tooltip.destroy()},i)});