"use strict";import Controllable from"./Controllable.js";import ControllablePath from"./ControllablePath.js";import U from"../../../Core/Utilities.js";const{merge,defined}=U;class ControllableEllipse extends Controllable{constructor(t,r,s){super(t,r,s,"shape"),this.type="ellipse"}init(t,r,s){defined(r.yAxis)&&r.points.forEach(t=>{t.yAxis=r.yAxis}),defined(r.xAxis)&&r.points.forEach(t=>{t.xAxis=r.xAxis}),super.init(t,r,s)}render(t){this.graphic=this.annotation.chart.renderer.createElement("ellipse").attr(this.attrsFromOptions(this.options)).add(t),super.render()}translate(t,r){super.translateShape(t,r,!0)}getDistanceFromLine(t,r,s,i){return Math.abs((r.y-t.y)*s-(r.x-t.x)*i+r.x*t.y-r.y*t.x)/Math.sqrt((r.y-t.y)*(r.y-t.y)+(r.x-t.x)*(r.x-t.x))}getAttrs(t,r){var s=t.x,t=t.y,i=r.x,r=r.y,e=(s+i)/2,o=(t+r)/2,a=Math.sqrt((s-i)*(s-i)/4+(t-r)*(t-r)/4);let n=180*Math.atan((r-t)/(i-s))/Math.PI;return e<s&&(n+=180),{cx:e,cy:o,rx:a,ry:this.getRY(),angle:n}}getRY(){const t=this.getYAxis();return defined(t)?Math.abs(t.toPixels(this.options.ry)-t.toPixels(0)):this.options.ry}getYAxis(){var t=this.options.yAxis;return this.chart.yAxis[t]}getAbsolutePosition(t){return this.anchor(t).absolutePosition}redraw(t){var r,s;this.graphic&&(r=this.getAbsolutePosition(this.points[0]),s=this.getAbsolutePosition(this.points[1]),s=this.getAttrs(r,s),r?this.graphic[t?"animate":"attr"]({cx:s.cx,cy:s.cy,rx:s.rx,ry:s.ry,rotation:s.angle,rotationOriginX:s.cx,rotationOriginY:s.cy}):this.graphic.attr({x:0,y:-9e9}),this.graphic.placed=Boolean(r)),super.redraw(t)}setYRadius(t){const r=this.annotation.userOptions.shapes;this.options.ry=t,r&&r[0]&&(r[0].ry=t,r[0].ry=t)}}ControllableEllipse.attrsMap=merge(ControllablePath.attrsMap,{ry:"ry"});export default ControllableEllipse;