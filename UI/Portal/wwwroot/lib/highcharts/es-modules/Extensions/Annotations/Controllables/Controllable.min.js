"use strict";import ControlTarget from"../ControlTarget.js";import U from"../../../Core/Utilities.js";const merge=U["merge"];class Controllable{constructor(t,i,o,s){this.graphic=void 0,this.annotation=t,this.chart=t.chart,this.collection="label"===s?"labels":"shapes",this.controlPoints=[],this.options=i,this.points=[],this.index=o,this.itemType=s,this.init(t,i,o)}attr(){this.graphic.attr.apply(this.graphic,arguments)}attrsFromOptions(t){const i=this.constructor.attrsMap,o={},s=this.chart.styledMode;let n,r;for(n in t)r=i[n],void 0===i[n]||s&&-1!==["fill","stroke","stroke-width"].indexOf(r)||(o[r]=t[n]);return o}destroy(){this.graphic&&(this.graphic=this.graphic.destroy()),this.tracker&&(this.tracker=this.tracker.destroy()),this.destroyControlTarget()}init(t,i,o){this.annotation=t,this.chart=t.chart,this.options=i,this.points=[],this.controlPoints=[],this.index=o,this.linkPoints(),this.addControlPoints()}redraw(t){this.redrawControlPoints(t)}render(t){this.renderControlPoints()}rotate(t,i,o){this.transform("rotate",t,i,o)}scale(t,i,o,s){this.transform("scale",t,i,o,s)}setControlPointsVisibility(i){this.controlPoints.forEach(t=>{t.setVisibility(i)})}shouldBeDrawn(){return!!this.points.length}translateShape(t,i,o){const s=this.annotation.chart,n=this.annotation.userOptions,r=s.annotations.indexOf(this.annotation),e=s.options.annotations[r];this.translatePoint(t,i,0),o&&this.translatePoint(t,i,1),e[this.collection][this.index].point=this.options.point,n[this.collection][this.index].point=this.options.point}update(t){const i=this.annotation,o=merge(!0,this.options,t),s=this.graphic.parentGroup,n=this.constructor;this.destroy();t=new n(i,o,this.index,this.itemType);merge(!0,this,t),this.render(s),this.redraw()}}ControlTarget.compose(Controllable);export default Controllable;