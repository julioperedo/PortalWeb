"use strict";import Annotation from"../Annotation.js";import CrookedLine from"./CrookedLine.js";import MockPoint from"../MockPoint.js";import U from"../../../Core/Utilities.js";const merge=U["merge"];class InfinityLine extends CrookedLine{static edgePoint(e,o){return function(i){var i=i.annotation,t=i.options.typeOptions.type;let n=i.points;return"horizontalLine"!==t&&"verticalLine"!==t||(n=[n[0],new MockPoint(i.chart,n[0].target,{x:n[0].x+ +("horizontalLine"===t),y:n[0].y+ +("verticalLine"===t),xAxis:n[0].options.xAxis,yAxis:n[0].options.yAxis})]),InfinityLine.findEdgePoint(n[e],n[o])}}static findEdgeCoordinate(i,t,n,e){var o="x"===n?"y":"x";return(t[n]-i[n])*(e-i[o])/(t[o]-i[o])+i[n]}static findEdgePoint(i,t){const n=i.series.chart,e=i.series.xAxis,o=t.series.yAxis,r=MockPoint.pointToPixels(i),s=MockPoint.pointToPixels(t),y=s.x-r.x,p=s.y-r.y,a=e.left,d=a+e.width,f=o.top,x=f+o.height,L=y<0?a:d,c=p<0?f:x,g={x:0==y?r.x:L,y:0==p?r.y:c};var l;return 0!=y&&0!=p&&(t=InfinityLine.findEdgeCoordinate(r,s,"y",L),l=InfinityLine.findEdgeCoordinate(r,s,"x",c),f<=t&&t<=x?(g.x=L,g.y=t):(g.x=l,g.y=c)),g.x-=n.plotLeft,g.y-=n.plotTop,i.series.chart.inverted&&(t=g.x,g.x=g.y,g.y=t),g}addShapes(){const i=this.options.typeOptions,t=[this.points[0],InfinityLine.endEdgePoint];i.type.match(/line/gi)&&(t[0]=InfinityLine.startEdgePoint);var n=this.initShape(merge(i.line,{type:"path",points:t}),0);i.line=n.options}}InfinityLine.endEdgePoint=InfinityLine.edgePoint(0,1),InfinityLine.startEdgePoint=InfinityLine.edgePoint(1,0),InfinityLine.prototype.defaultOptions=merge(CrookedLine.prototype.defaultOptions,{});export default Annotation.types.infinityLine=InfinityLine;