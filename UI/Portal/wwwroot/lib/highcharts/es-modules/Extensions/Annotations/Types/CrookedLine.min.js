"use strict";import Annotation from"../Annotation.js";import ControlPoint from"../ControlPoint.js";import MockPoint from"../MockPoint.js";import U from"../../../Core/Utilities.js";const merge=U["merge"];class CrookedLine extends Annotation{setClipAxes(){this.clipXAxis=this.chart.xAxis[this.options.typeOptions.xAxis],this.clipYAxis=this.chart.yAxis[this.options.typeOptions.yAxis]}getPointsOptions(){const o=this.options.typeOptions;return(o.points||[]).map(t=>(t.xAxis=o.xAxis,t.yAxis=o.yAxis,t))}getControlPointsOptions(){return this.getPointsOptions()}addControlPoints(){this.getControlPointsOptions().forEach(function(t,o){o=new ControlPoint(this.chart,this,merge(this.options.controlPointOptions,t.controlPoint),o);this.controlPoints.push(o),t.controlPoint=o.options},this)}addShapes(){const t=this.options.typeOptions,o=this.initShape(merge(t.line,{type:"path",points:this.points.map((t,o)=>function(t){return t.annotation.points[o]})}),0);t.line=o.options}}CrookedLine.prototype.defaultOptions=merge(Annotation.prototype.defaultOptions,{typeOptions:{xAxis:0,yAxis:0,line:{fill:"none"}},controlPointOptions:{positioner:function(t){var o=this.graphic,t=MockPoint.pointToPixels(t.points[this.index]);return{x:t.x-(o.width||0)/2,y:t.y-(o.height||0)/2}},events:{drag:function(t,o){if(o.chart.isInsidePlot(t.chartX-o.chart.plotLeft,t.chartY-o.chart.plotTop,{visiblePlotOnly:!0})){const i=this.mouseMoveToTranslation(t),n=o.options.typeOptions;o.translatePoint(i.x,i.y,this.index),n.points[this.index].x=o.points[this.index].x,n.points[this.index].y=o.points[this.index].y,o.redraw(!1)}}}}});export default Annotation.types.crookedLine=CrookedLine;