"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const getDeferredAnimation=A["getDeferredAnimation"];import AnnotationChart from"./AnnotationChart.js";import AnnotationDefaults from"./AnnotationDefaults.js";import ControllableRect from"./Controllables/ControllableRect.js";import ControllableCircle from"./Controllables/ControllableCircle.js";import ControllableEllipse from"./Controllables/ControllableEllipse.js";import ControllablePath from"./Controllables/ControllablePath.js";import ControllableImage from"./Controllables/ControllableImage.js";import ControllableLabel from"./Controllables/ControllableLabel.js";import ControlPoint from"./ControlPoint.js";import ControlTarget from"./ControlTarget.js";import EventEmitter from"./EventEmitter.js";import MockPoint from"./MockPoint.js";import NavigationBindings from"./NavigationBindings.js";import PopupComposition from"./Popup/PopupComposition.js";import U from"../../Core/Utilities.js";const{destroyObjectProperties,erase,fireEvent,merge,pick,splat}=U;function adjustVisibility(t){const i=t.graphic,s=t.points.some(t=>!1!==t.series.visible&&!1!==t.visible);i&&(s?"hidden"===i.visibility&&i.show():i.hide())}function getLabelsAndShapesOptions(i,o){const e={};return["labels","shapes"].forEach(t=>{const s=i[t];s&&(o[t]?e[t]=splat(o[t]).map(function(t,i){return merge(s[i],t)}):e[t]=i[t])}),e}class Annotation extends EventEmitter{static compose(t,i,s){AnnotationChart.compose(Annotation,t,i),ControllableLabel.compose(s),ControllablePath.compose(t,s),NavigationBindings.compose(Annotation,t),PopupComposition.compose(NavigationBindings,i)}constructor(t,i){super(),this.coll="annotations",this.animationConfig=void 0,this.graphic=void 0,this.group=void 0,this.labelCollector=void 0,this.labelsGroup=void 0,this.shapesGroup=void 0,this.chart=t,this.points=[],this.controlPoints=[],this.coll="annotations",this.index=-1,this.labels=[],this.shapes=[],this.options=merge(this.defaultOptions,i),this.userOptions=i;i=getLabelsAndShapesOptions(this.options,i);this.options.labels=i.labels,this.options.shapes=i.shapes,this.init(t,this.options)}addClipPaths(){this.setClipAxes(),this.clipXAxis&&this.clipYAxis&&this.options.crop&&(this.clipRect=this.chart.renderer.clipRect(this.getClipBox()))}addLabels(){const s=this.options.labels||[];s.forEach((t,i)=>{t=this.initLabel(t,i);merge(!0,s[i],t.options)})}addShapes(){const s=this.options.shapes||[];s.forEach((t,i)=>{t=this.initShape(t,i);merge(!0,s[i],t.options)})}destroy(){function t(t){t.destroy()}var i=this.chart;this.labels.forEach(t),this.shapes.forEach(t),this.clipXAxis=null,this.clipYAxis=null,erase(i.labelCollectors,this.labelCollector),super.destroy(),this.destroyControlTarget(),destroyObjectProperties(this,i)}destroyItem(t){erase(this[t.itemType+"s"],t),t.destroy()}getClipBox(){if(this.clipXAxis&&this.clipYAxis)return{x:this.clipXAxis.left,y:this.clipYAxis.top,width:this.clipXAxis.width,height:this.clipYAxis.height}}initProperties(t,i){this.setOptions(i);var s=getLabelsAndShapesOptions(this.options,i);this.options.labels=s.labels,this.options.shapes=s.shapes,this.chart=t,this.points=[],this.controlPoints=[],this.coll="annotations",this.userOptions=i,this.labels=[],this.shapes=[]}init(t,i,s=this.index){var o=this.chart,e=this.options.animation;this.index=s,this.linkPoints(),this.addControlPoints(),this.addShapes(),this.addLabels(),this.setLabelCollector(),this.animationConfig=getDeferredAnimation(o,e)}initLabel(t,i){const s=merge(this.options.labelOptions,{controlPointOptions:this.options.controlPointOptions},t),o=new ControllableLabel(this,s,i);return o.itemType="label",this.labels.push(o),o}initShape(t,i){const s=merge(this.options.shapeOptions,{controlPointOptions:this.options.controlPointOptions},t),o=new Annotation.shapesMap[s.type](this,s,i);return o.itemType="shape",this.shapes.push(o),o}redraw(t){this.linkPoints(),this.graphic||this.render(),this.clipRect&&this.clipRect.animate(this.getClipBox()),this.redrawItems(this.shapes,t),this.redrawItems(this.labels,t),this.redrawControlPoints(t)}redrawItem(t,i){t.linkPoints(),t.shouldBeDrawn()?(t.graphic||this.renderItem(t),t.redraw(pick(i,!0)&&t.graphic.placed),t.points.length&&adjustVisibility(t)):this.destroyItem(t)}redrawItems(t,i){let s=t.length;for(;s--;)this.redrawItem(t[s],i)}remove(){return this.chart.removeAnnotation(this)}render(){const t=this.chart.renderer;this.graphic=t.g("annotation").attr({opacity:0,zIndex:this.options.zIndex,visibility:this.options.visible?"inherit":"hidden"}).add(),this.shapesGroup=t.g("annotation-shapes").add(this.graphic),this.options.crop&&this.shapesGroup.clip(this.chart.plotBoxClip),this.labelsGroup=t.g("annotation-labels").attr({translateX:0,translateY:0}).add(this.graphic),this.addClipPaths(),this.clipRect&&this.graphic.clip(this.clipRect),this.renderItems(this.shapes),this.renderItems(this.labels),this.addEvents(),this.renderControlPoints()}renderItem(t){t.render("label"===t.itemType?this.labelsGroup:this.shapesGroup)}renderItems(t){let i=t.length;for(;i--;)this.renderItem(t[i])}setClipAxes(){const s=this.chart.xAxis,o=this.chart.yAxis,t=(this.options.labels||[]).concat(this.options.shapes||[]).reduce((t,i)=>{i=i&&(i.point||i.points&&i.points[0]);return[s[i&&i.xAxis]||t[0],o[i&&i.yAxis]||t[1]]},[]);this.clipXAxis=t[0],this.clipYAxis=t[1]}setControlPointsVisibility(i){function t(t){t.setControlPointsVisibility(i)}this.controlPoints.forEach(t=>{t.setVisibility(i)}),this.shapes.forEach(t),this.labels.forEach(t)}setLabelCollector(){const t=this;t.labelCollector=function(){return t.labels.reduce(function(t,i){return i.options.allowOverlap||t.push(i.graphic),t},[])},t.chart.labelCollectors.push(t.labelCollector)}setOptions(t){this.options=merge(this.defaultOptions,t)}setVisibility(t){const i=this.options,s=this.chart.navigationBindings,o=pick(t,!i.visible);this.graphic.attr("visibility",o?"inherit":"hidden"),o||(this.shapes.forEach(t=function(t){t.setControlPointsVisibility(o)}),this.labels.forEach(t),s.activeAnnotation===this&&s.popup&&"annotation-toolbar"===s.popup.type&&fireEvent(s,"closePopup")),i.visible=o}update(t,i){const s=this.chart,o=getLabelsAndShapesOptions(this.userOptions,t),e=s.annotations.indexOf(this),n=merge(!0,this.userOptions,t);n.labels=o.labels,n.shapes=o.shapes,this.destroy(),this.initProperties(s,n),this.init(s,n),s.options.annotations[e]=n,this.isUpdating=!0,pick(i,!0)&&s.redraw(),fireEvent(this,"afterUpdate"),this.isUpdating=!1}}Annotation.ControlPoint=ControlPoint,Annotation.MockPoint=MockPoint,Annotation.shapesMap={rect:ControllableRect,circle:ControllableCircle,ellipse:ControllableEllipse,path:ControllablePath,image:ControllableImage},Annotation.types={},Annotation.prototype.defaultOptions=AnnotationDefaults,Annotation.prototype.nonDOMEvents=["add","afterUpdate","drag","remove"],ControlTarget.compose(Annotation);export default Annotation;