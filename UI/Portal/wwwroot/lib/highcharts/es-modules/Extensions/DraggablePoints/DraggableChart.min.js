"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const animObject=A["animObject"];import DDU from"./DragDropUtilities.js";const{addEvents,countProps,getFirstProp,getNormalizedEvent}=DDU;import DragDropDefaults from"./DragDropDefaults.js";import H from"../../Core/Globals.js";const doc=H["doc"];import U from"../../Core/Utilities.js";const{addEvent,merge,pick,pushUnique}=U,composedMembers=[];function addDragDropEvents(t){var e=t.container;isChartDraggable(t)&&(addEvents(e,["mousedown","touchstart"],e=>{mouseDown(getNormalizedEvent(e,t),t)}),addEvents(e,["mousemove","touchmove"],e=>{mouseMove(getNormalizedEvent(e,t),t)},{passive:!1}),addEvent(e,"mouseleave",e=>{mouseUp(getNormalizedEvent(e,t),t)}),t.unbindDragDropMouseUp=addEvents(doc,["mouseup","touchend"],e=>{mouseUp(getNormalizedEvent(e,t),t)},{passive:!1}),t.hasAddedDragDropEvents=!0,addEvent(t,"destroy",()=>{t.unbindDragDropMouseUp&&t.unbindDragDropMouseUp()}))}function chartHideDragHandles(){const e=this.dragHandles||{};if(e){for(const t of Object.keys(e))e[t].destroy&&e[t].destroy();delete this.dragHandles}}function chartSetGuideBoxState(e,t){const o=this.dragGuideBox,r=merge(DragDropDefaults.guideBox,t),i=merge(r.default,r[e]);return o.attr({class:i.className,stroke:i.lineColor,strokeWidth:i.lineWidth,fill:i.color,cursor:i.cursor,zIndex:i.zIndex}).css({pointerEvents:"none"})}function chartZoomOrPanKeyPressed(e){var t=this,o=t.options.chart||{},o=o.panKey&&o.panKey+"Key";return e[t.zooming.key&&t.zooming.key+"Key"]||e[o]}function compose(e){if(pushUnique(composedMembers,e)){const t=e.prototype;t.hideDragHandles=chartHideDragHandles,t.setGuideBoxState=chartSetGuideBoxState,t.zoomOrPanKeyPressed=chartZoomOrPanKeyPressed,addEvent(e,"render",onChartRender)}}function dragMove(e,t){const o=t.series,r=o.chart,i=r.dragDropData,a=merge(o.options.dragDrop,t.options.dragDrop),s=a.draggableX,n=a.draggableY,d=i.origin,g=i.updateProp;let p=e.chartX-d.chartX,c=e.chartY-d.chartY;e=p;r.inverted&&(p=-c,c=-e),pick(a.liveRedraw,!0)?(updatePoints(r,!1),t.showDragHandles()):g?resizeGuideBox(t,p,c):r.dragGuideBox.translate(s?p:0,n?c:0),d.prevdX=p,d.prevdY=c}function flipResizeSide(e){return{left:"right",right:"left",top:"bottom",bottom:"top"}[e]}function getGroupedPoints(t){const o=t.series,r=o.options.data||[],i=o.options.dragDrop.groupBy;let a=[];if(o.boosted)for(let e=0,t=r.length;e<t;++e)a.push((new o.pointClass).init(o,r[e])),a[a.length-1].index=e;else a=o.points;return t.options[i]?a.filter(e=>e.options[i]===t.options[i]):[t]}function getNewPoints(e,t){const o=e.point,r=o.series,i=r.chart,a=merge(r.options.dragDrop,o.options.dragDrop),s={},n=e.updateProp,d={},g=o.series.dragDropProps;for(const c in g){var p=g[c];n&&(n!==c||!p.resize||p.optionName&&!1===a[p.optionName])||(n||p.move&&("x"===p.axis&&a.draggableX||"y"===p.axis&&a.draggableY))&&(i.mapView?s["x"===c?"lon":"lat"]=p:s[c]=p)}for(const u of n?[o]:e.groupedPoints)d[u.id]={point:u,newValues:u.getDropValues(e.origin,t,s)};return d}function getPositionSnapshot(e,t,o){const r={chartX:e.chartX,chartY:e.chartY,guideBox:o&&{x:o.attr("x"),y:o.attr("y"),width:o.attr("width"),height:o.attr("height")},points:{}};for(const i of t){const a=i.series.dragDropProps||{},s={};for(const n of Object.keys(a)){const d=a[n],g=i.series[d.axis+"Axis"];s[n]=i[n],i.series.chart.mapView&&i.plotX&&i.plotY?s[n+"Offset"]="x"===n?i.plotX:i.plotY:s[n+"Offset"]=g.toPixels(i[n])-(g.horiz?e.chartX:e.chartY)}s.point=i,r.points[i.id]=s}return r}function hasDraggedPastSensitivity(e,t,o){var t=t.dragDropData.origin,r=t.chartX,t=t.chartY,i=e.chartX,e=e.chartY;return o<Math.sqrt((i-r)*(i-r)+(e-t)*(e-t))}function initDragDrop(e,t){const o=getGroupedPoints(t),r=t.series,i=r.chart;let a;pick(r.options.dragDrop&&r.options.dragDrop.liveRedraw,!0)||(i.dragGuideBox=a=r.getGuideBox(o),i.setGuideBoxState("default",r.options.dragDrop.guideBox).add(r.group)),i.dragDropData={origin:getPositionSnapshot(e,o,a),point:t,groupedPoints:o,isDragging:!0}}function isChartDraggable(e){let t=e.series?e.series.length:0;if(e.hasCartesianSeries&&!e.polar||e.mapView)for(;t--;)if(e.series[t].options.dragDrop&&isSeriesDraggable(e.series[t]))return!0;return!1}function isPointMovable(e){var t=e.series,o=t.chart,r=t.options.dragDrop||{},e=e.options&&e.options.dragDrop,i=t.dragDropProps;let a,s,n;for(const d in i)"x"===(a=i[d]).axis&&a.move?s=!0:"y"===a.axis&&a.move&&(n=!0);return(r.draggableX&&s||r.draggableY&&n)&&!(e&&!1===e.draggableX&&!1===e.draggableY)&&(!(!t.yAxis||!t.xAxis)||o.mapView)}function isSeriesDraggable(e){const t=["draggableX","draggableY"],o=e.dragDropProps||{};var r;for(const a of Object.keys(o))(r=o[a]).optionName&&t.push(r.optionName);let i=t.length;for(;i--;)if(e.options.dragDrop[t[i]])return!0}function mouseDown(e,t){const o=t.hoverPoint,r=merge(o&&o.series.options.dragDrop,o&&o.options.dragDrop),i=r.draggableX||!1,a=r.draggableY||!1;t.cancelClick=!1,!i&&!a||t.zoomOrPanKeyPressed(e)||t.hasDraggedAnnotation||(t.dragDropData&&t.dragDropData.isDragging?mouseUp(e,t):o&&isPointMovable(o)&&(t.mouseIsDown=!1,initDragDrop(e,o),o.firePointEvent("dragStart",e)))}function mouseMove(a,s){if(!s.zoomOrPanKeyPressed(a)){const n=s.dragDropData;let e,t,o,r,i;n&&n.isDragging&&n.point.series&&(t=(e=n.point).series.options.dragDrop,a.preventDefault(),n.draggedPastSensitivity||(n.draggedPastSensitivity=hasDraggedPastSensitivity(a,s,pick(e.options.dragDrop&&e.options.dragDrop.dragSensitivity,t&&t.dragSensitivity,DragDropDefaults.dragSensitivity))),n.draggedPastSensitivity&&(n.newPoints=getNewPoints(n,a),o=n.newPoints,i=1===(r=countProps(o))?getFirstProp(o):null,e.firePointEvent("drag",{origin:n.origin,newPoints:n.newPoints,newPoint:i&&i.newValues,newPointId:i&&i.point.id,numNewPoints:r,chartX:a.chartX,chartY:a.chartY},function(){dragMove(a,e)})))}}function mouseUp(e,t){var o=t.dragDropData;if(o&&o.isDragging&&o.draggedPastSensitivity&&o.point.series){const r=o.point,i=o.newPoints,a=countProps(i),s=1===a?getFirstProp(i):null;t.dragHandles&&t.hideDragHandles(),e.preventDefault(),t.cancelClick=!0,r.firePointEvent("drop",{origin:o.origin,chartX:e.chartX,chartY:e.chartY,newPoints:i,numNewPoints:a,newPoint:s&&s.newValues,newPointId:s&&s.point.id},function(){updatePoints(t)})}delete t.dragDropData,t.dragGuideBox&&(t.dragGuideBox.destroy(),delete t.dragGuideBox)}function onChartRender(){this.hasAddedDragDropEvents||addDragDropEvents(this)}function resizeGuideBox(e,t,o){const r=e.series,i=r.chart,a=i.dragDropData,s=r.dragDropProps[a.updateProp],n=a.newPoints[e.id].newValues,d="function"==typeof s.resizeSide?s.resizeSide(n,e):s.resizeSide;s.beforeResize&&s.beforeResize(i.dragGuideBox,n,e),resizeRect(i.dragGuideBox,"x"===s.axis&&r.xAxis.reversed||"y"===s.axis&&r.yAxis.reversed?flipResizeSide(d):d,{x:"x"===s.axis?t-(a.origin.prevdX||0):0,y:"y"===s.axis?o-(a.origin.prevdY||0):0})}function resizeRect(e,t,o){let r;switch(t){case"left":r={x:e.attr("x")+o.x,width:Math.max(1,e.attr("width")-o.x)};break;case"right":r={width:Math.max(1,e.attr("width")+o.x)};break;case"top":r={y:e.attr("y")+o.y,height:Math.max(1,e.attr("height")-o.y)};break;case"bottom":r={height:Math.max(1,e.attr("height")+o.y)}}e.attr(r)}function updatePoints(e,t){var o=e.dragDropData.newPoints,t=animObject(t);e.isDragDropAnimating=!0;let r;for(const i of Object.keys(o))(r=o[i]).point.update(r.newValues,!1);e.redraw(t),setTimeout(()=>{delete e.isDragDropAnimating,e.hoverPoint&&!e.dragHandles&&e.hoverPoint.showDragHandles()},t.duration)}const DraggableChart={compose:compose,flipResizeSide:flipResizeSide,initDragDrop:initDragDrop};export default DraggableChart;