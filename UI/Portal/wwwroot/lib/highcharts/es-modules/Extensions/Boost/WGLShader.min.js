"use strict";import U from"../../Core/Utilities.js";const{clamp,error,pick}=U,fragmentShader=["precision highp float;","uniform vec4 fillColor;","varying highp vec2 position;","varying highp vec4 vColor;","uniform sampler2D uSampler;","uniform bool isCircle;","uniform bool hasColor;","void main(void) {","vec4 col = fillColor;","vec4 tcol = texture2D(uSampler, gl_PointCoord.st);","if (hasColor) {","col = vColor;","}","if (isCircle) {","col *= tcol;","if (tcol.r < 0.0) {","discard;","} else {","gl_FragColor = col;","}","} else {","gl_FragColor = col;","}","}"].join("\n"),vertexShader=["#version 100","#define LN10 2.302585092994046","precision highp float;","attribute vec4 aVertexPosition;","attribute vec4 aColor;","varying highp vec2 position;","varying highp vec4 vColor;","uniform mat4 uPMatrix;","uniform float pSize;","uniform float translatedThreshold;","uniform bool hasThreshold;","uniform bool skipTranslation;","uniform float xAxisTrans;","uniform float xAxisMin;","uniform float xAxisMinPad;","uniform float xAxisPointRange;","uniform float xAxisLen;","uniform bool  xAxisPostTranslate;","uniform float xAxisOrdinalSlope;","uniform float xAxisOrdinalOffset;","uniform float xAxisPos;","uniform bool  xAxisCVSCoord;","uniform bool  xAxisIsLog;","uniform bool  xAxisReversed;","uniform float yAxisTrans;","uniform float yAxisMin;","uniform float yAxisMinPad;","uniform float yAxisPointRange;","uniform float yAxisLen;","uniform bool  yAxisPostTranslate;","uniform float yAxisOrdinalSlope;","uniform float yAxisOrdinalOffset;","uniform float yAxisPos;","uniform bool  yAxisCVSCoord;","uniform bool  yAxisIsLog;","uniform bool  yAxisReversed;","uniform bool  isBubble;","uniform bool  bubbleSizeByArea;","uniform float bubbleZMin;","uniform float bubbleZMax;","uniform float bubbleZThreshold;","uniform float bubbleMinSize;","uniform float bubbleMaxSize;","uniform bool  bubbleSizeAbs;","uniform bool  isInverted;","float bubbleRadius(){","float value = aVertexPosition.w;","float zMax = bubbleZMax;","float zMin = bubbleZMin;","float radius = 0.0;","float pos = 0.0;","float zRange = zMax - zMin;","if (bubbleSizeAbs){","value = value - bubbleZThreshold;","zMax = max(zMax - bubbleZThreshold, zMin - bubbleZThreshold);","zMin = 0.0;","}","if (value < zMin){","radius = bubbleZMin / 2.0 - 1.0;","} else {","pos = zRange > 0.0 ? (value - zMin) / zRange : 0.5;","if (bubbleSizeByArea && pos > 0.0){","pos = sqrt(pos);","}","radius = ceil(bubbleMinSize + pos * (bubbleMaxSize - bubbleMinSize)) / 2.0;","}","return radius * 2.0;","}","float translate(float val,","float pointPlacement,","float localA,","float localMin,","float minPixelPadding,","float pointRange,","float len,","bool  cvsCoord,","bool  isLog,","bool  reversed","){","float sign = 1.0;","float cvsOffset = 0.0;","if (cvsCoord) {","sign *= -1.0;","cvsOffset = len;","}","if (isLog) {","val = log(val) / LN10;","}","if (reversed) {","sign *= -1.0;","cvsOffset -= sign * len;","}","return sign * (val - localMin) * localA + cvsOffset + ","(sign * minPixelPadding);","}","float xToPixels(float value) {","if (skipTranslation){","return value;// + xAxisPos;","}","return translate(value, 0.0, xAxisTrans, xAxisMin, xAxisMinPad, xAxisPointRange, xAxisLen, xAxisCVSCoord, xAxisIsLog, xAxisReversed);// + xAxisPos;","}","float yToPixels(float value, float checkTreshold) {","float v;","if (skipTranslation){","v = value;// + yAxisPos;","} else {","v = translate(value, 0.0, yAxisTrans, yAxisMin, yAxisMinPad, yAxisPointRange, yAxisLen, yAxisCVSCoord, yAxisIsLog, yAxisReversed);// + yAxisPos;","if (v > yAxisLen) {","v = yAxisLen;","}","}","if (checkTreshold > 0.0 && hasThreshold) {","v = min(v, translatedThreshold);","}","return v;","}","void main(void) {","if (isBubble){","gl_PointSize = bubbleRadius();","} else {","gl_PointSize = pSize;","}","vColor = aColor;","if (skipTranslation && isInverted) {","gl_Position = uPMatrix * vec4(aVertexPosition.y + yAxisPos, aVertexPosition.x + xAxisPos, 0.0, 1.0);","} else if (isInverted) {","gl_Position = uPMatrix * vec4(yToPixels(aVertexPosition.y, aVertexPosition.z) + yAxisPos, xToPixels(aVertexPosition.x) + xAxisPos, 0.0, 1.0);","} else {","gl_Position = uPMatrix * vec4(xToPixels(aVertexPosition.x) + xAxisPos, yToPixels(aVertexPosition.y, aVertexPosition.z) + yAxisPos, 0.0, 1.0);","}","}"].join("\n");class WGLShader{constructor(i){this.errors=[],this.uLocations={},(this.gl=i)&&this.createShader()}bind(){this.gl&&this.shaderProgram&&this.gl.useProgram(this.shaderProgram)}createShader(){var i=this.stringToProgram(vertexShader,"vertex"),r=this.stringToProgram(fragmentShader,"fragment"),o=i=>this.gl.getUniformLocation(this.shaderProgram,i);return i&&r?(this.shaderProgram=this.gl.createProgram(),this.gl.attachShader(this.shaderProgram,i),this.gl.attachShader(this.shaderProgram,r),this.gl.linkProgram(this.shaderProgram),this.gl.getProgramParameter(this.shaderProgram,this.gl.LINK_STATUS)?(this.gl.useProgram(this.shaderProgram),this.gl.bindAttribLocation(this.shaderProgram,0,"aVertexPosition"),this.pUniform=o("uPMatrix"),this.psUniform=o("pSize"),this.fcUniform=o("fillColor"),this.isBubbleUniform=o("isBubble"),this.bubbleSizeAbsUniform=o("bubbleSizeAbs"),this.bubbleSizeAreaUniform=o("bubbleSizeByArea"),this.uSamplerUniform=o("uSampler"),this.skipTranslationUniform=o("skipTranslation"),this.isCircleUniform=o("isCircle"),this.isInverted=o("isInverted"),!0):(this.errors.push(this.gl.getProgramInfoLog(this.shaderProgram)),this.handleErrors(),this.shaderProgram=!1)):(this.shaderProgram=!1,this.handleErrors(),!1)}handleErrors(){this.errors.length&&error("[highcharts boost] shader error - "+this.errors.join("\n"))}stringToProgram(i,r){var o=this.gl.createShader("vertex"===r?this.gl.VERTEX_SHADER:this.gl.FRAGMENT_SHADER);return this.gl.shaderSource(o,i),this.gl.compileShader(o),this.gl.getShaderParameter(o,this.gl.COMPILE_STATUS)?o:(this.errors.push("when compiling "+r+" shader:\n"+this.gl.getShaderInfoLog(o)),!1)}destroy(){this.gl&&this.shaderProgram&&(this.gl.deleteProgram(this.shaderProgram),this.shaderProgram=!1)}fillColorUniform(){return this.fcUniform}getProgram(){return this.shaderProgram}pointSizeUniform(){return this.psUniform}perspectiveUniform(){return this.pUniform}reset(){this.gl&&this.shaderProgram&&(this.gl.uniform1i(this.isBubbleUniform,0),this.gl.uniform1i(this.isCircleUniform,0))}setBubbleUniforms(i,r,o,s=1){var e,t=i.options,a=Number.MAX_VALUE,l=-Number.MAX_VALUE;this.gl&&this.shaderProgram&&i.is("bubble")&&(e=i.getPxExtremes(),a=pick(t.zMin,clamp(r,!1===t.displayNegative?t.zThreshold:-Number.MAX_VALUE,a)),l=pick(t.zMax,Math.max(l,o)),this.gl.uniform1i(this.isBubbleUniform,1),this.gl.uniform1i(this.isCircleUniform,1),this.gl.uniform1i(this.bubbleSizeAreaUniform,"width"!==i.options.sizeBy),this.gl.uniform1i(this.bubbleSizeAbsUniform,i.options.sizeByAbsoluteValue),this.setUniform("bubbleMinSize",e.minPxSize*s),this.setUniform("bubbleMaxSize",e.maxPxSize*s),this.setUniform("bubbleZMin",a),this.setUniform("bubbleZMax",l),this.setUniform("bubbleZThreshold",i.options.zThreshold))}setColor(i){this.gl&&this.shaderProgram&&this.gl.uniform4f(this.fcUniform,i[0]/255,i[1]/255,i[2]/255,i[3])}setDrawAsCircle(i){this.gl&&this.shaderProgram&&this.gl.uniform1i(this.isCircleUniform,i?1:0)}setInverted(i){this.gl&&this.shaderProgram&&this.gl.uniform1i(this.isInverted,i)}setPMatrix(i){this.gl&&this.shaderProgram&&this.gl.uniformMatrix4fv(this.pUniform,!1,i)}setPointSize(i){this.gl&&this.shaderProgram&&this.gl.uniform1f(this.psUniform,i)}setSkipTranslation(i){this.gl&&this.shaderProgram&&this.gl.uniform1i(this.skipTranslationUniform,!0===i?1:0)}setTexture(i){this.gl&&this.shaderProgram&&this.gl.uniform1i(this.uSamplerUniform,i)}setUniform(i,r){this.gl&&this.shaderProgram&&(i=this.uLocations[i]=this.uLocations[i]||this.gl.getUniformLocation(this.shaderProgram,i),this.gl.uniform1f(i,r))}}export default WGLShader;