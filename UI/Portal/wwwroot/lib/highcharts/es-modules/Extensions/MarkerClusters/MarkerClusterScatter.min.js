"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const animObject=A["animObject"];import MarkerClusterDefaults from"./MarkerClusterDefaults.js";const clusterDefaults=MarkerClusterDefaults["cluster"];import U from"../../Core/Utilities.js";const{addEvent,defined,error,isArray,isFunction,isObject,isNumber,merge,objectEach,pushUnique,relativeLength,syncTimeout}=U,composedMembers=[],markerClusterAlgorithms={grid:function(t,e,a,s){const i={},o=this.getGridOffset();let r,n,l,d,u;var p=this.getScaledGridSize(s);for(u=0;u<t.length;u++){var c=valuesToPixels(this,{x:t[u],y:e[u]});r=c.x-o.plotLeft,n=c.y-o.plotTop,l=Math.floor(r/p),d=Math.floor(n/p)+"-"+l,i[d]||(i[d]=[]),i[d].push({dataIndex:a[u],x:t[u],y:e[u]})}return i},kmeans:function(e,a,s,t){const i=this,o=[],r=[],n={},l=t.processedDistance||clusterDefaults.layoutAlgorithm.distance,d=t.iterations;let u=0,p=!0,c,h,m,f=[];t.processedGridSize=t.processedDistance;var x=i.markerClusterAlgorithms?i.markerClusterAlgorithms.grid.call(i,e,a,s,t):{};for(const g in x)1<x[g].length&&(m=getClusterPosition(x[g]),o.push({posX:m.x,posY:m.y,oldX:0,oldY:0,startPointsLen:x[g].length,points:[]}));for(;p;){for(const y of o)y.points.length=0;for(let t=r.length=0;t<e.length;t++)c=e[t],h=a[t],((f=i.getClusterDistancesFromPoint(o,c,h)).length&&f[0].distance<l?o[f[0].clusterIndex].points:r).push({x:c,y:h,dataIndex:s[t]});for(let t=0;t<o.length;t++)1===o[t].points.length&&(f=i.getClusterDistancesFromPoint(o,o[t].points[0].x,o[t].points[0].y))[1].distance<l&&(o[f[1].clusterIndex].points.push(o[t].points[0]),o[f[0].clusterIndex].points.length=0);p=!1;for(let t=0;t<o.length;t++)m=getClusterPosition(o[t].points),o[t].oldX=o[t].posX,o[t].oldY=o[t].posY,o[t].posX=m.x,o[t].posY=m.y,(o[t].posX>o[t].oldX+1||o[t].posX<o[t].oldX-1||o[t].posY>o[t].oldY+1||o[t].posY<o[t].oldY-1)&&(p=!0);d&&(p=u<d-1),u++}for(let t=0,e=o.length;t<e;++t)n["cluster"+t]=o[t].points;for(let t=0,e=r.length;t<e;++t)n["noise"+t]=[r[t]];return n},optimizedKmeans:function(t,e,a,s){var i=this,o=s.processedDistance||clusterDefaults.layoutAlgorithm.gridSize,r=i.getRealExtremes(),n=(i.options.cluster||{}).marker;let l,d={},u,p;if(!i.markerClusterInfo||i.initMaxX&&i.initMaxX<r.maxX||i.initMinX&&i.initMinX>r.minX||i.initMaxY&&i.initMaxY<r.maxY||i.initMinY&&i.initMinY>r.minY)i.initMaxX=r.maxX,i.initMinX=r.minX,i.initMaxY=r.maxY,i.initMinY=r.minY,d=i.markerClusterAlgorithms?i.markerClusterAlgorithms.kmeans.call(i,t,e,a,s):{},i.baseClusters=null;else{i.baseClusters||(i.baseClusters={clusters:i.markerClusterInfo.clusters,noise:i.markerClusterInfo.noise});for(const m of i.baseClusters.clusters){m.pointsOutside=[],m.pointsInside=[];for(const f of m.data){var c=valuesToPixels(i,f),h=valuesToPixels(i,m);l=Math.sqrt(Math.pow(c.x-h.x,2)+Math.pow(c.y-h.y,2)),u=0<=o-(p=(m.clusterZone&&m.clusterZone.marker&&m.clusterZone.marker.radius?m.clusterZone.marker:n&&n.radius?n:clusterDefaults.marker).radius)?o-p:p,l>p+u&&defined(m.pointsOutside)?m.pointsOutside.push(f):defined(m.pointsInside)&&m.pointsInside.push(f)}m.pointsInside.length&&(d[m.id]=m.pointsInside);let t=0;for(const x of m.pointsOutside)d[m.id+"_noise"+t++]=[x]}for(const g of i.baseClusters.noise)d[g.id]=g.data}return d}};let baseGeneratePoints,oldPointsStateId=[],stateIdCounter=0;function compose(t,e){if(pushUnique(composedMembers,e)){const a=e.prototype;baseGeneratePoints=a.generatePoints,a.markerClusterAlgorithms=markerClusterAlgorithms,a.animateClusterPoint=seriesAnimateClusterPoint,a.destroyClusteredData=seriesDestroyClusteredData,a.generatePoints=seriesGeneratePoints,a.getClusterDistancesFromPoint=seriesGetClusterDistancesFromPoint,a.getClusteredData=seriesGetClusteredData,a.getGridOffset=seriesGetGridOffset,a.getPointsState=seriesGetPointsState,a.getRealExtremes=seriesGetRealExtremes,a.getScaledGridSize=seriesGetScaledGridSize,a.hideClusteredData=seriesHideClusteredData,a.isValidGroupedDataObject=seriesIsValidGroupedDataObject,a.preventClusterCollisions=seriesPreventClusterCollisions,addEvent(e,"destroy",a.destroyClusteredData)}pushUnique(composedMembers,t)&&((t.plotOptions||{}).series=merge((t.plotOptions||{}).series,MarkerClusterDefaults))}function destroyOldPoints(e){if(e){let t;for(const a of Object.keys(e))(t=e[a]).point&&t.point.destroy&&t.point.destroy()}}function fadeInElement(t,e,a){t.attr({opacity:e}).animate({opacity:1},a)}function fadeInNewPointAndDestoryOld(t,e,a,s){fadeInStatePoint(t,s,a,!0,!0);for(const i of e)i.point&&i.point.destroy&&i.point.destroy()}function fadeInStatePoint(t,e,a,s,i){t.point&&(s&&t.point.graphic&&(t.point.graphic.show(),fadeInElement(t.point.graphic,e,a)),i&&t.point.dataLabel&&(t.point.dataLabel.show(),fadeInElement(t.point.dataLabel,e,a)))}function getClusterPosition(e){var a=e.length;let s=0,i=0;for(let t=0;t<a;t++)s+=e[t].x,i+=e[t].y;return{x:s/a,y:i/a}}function getDataState(t,e){const a=[];return a.length=e,t.clusters.forEach(function(t){t.data.forEach(function(t){a[t.dataIndex]=t})}),t.noise.forEach(function(t){a[t.data[0].dataIndex]=t.data[0]}),a}function getStateId(){return Math.random().toString(36).substring(2,7)+"-"+stateIdCounter++}function hideStatePoint(t,e,a){t.point&&(e&&t.point.graphic&&t.point.graphic.hide(),a&&t.point.dataLabel&&t.point.dataLabel.hide())}function onPointDrillToCluster(t){const e=t.point||t.target;e.firePointEvent("drillToCluster",t,function(t){const e=t.point||t.target,a=e.series,s=e.series.xAxis,i=e.series.yAxis,o=e.series.chart,r=o.mapView,n=a.options.cluster,l=(n||{}).drillToCluster;var d,u,p,c,h,m,f;l&&e.clusteredData&&(m=e.clusteredData.map(t=>t.x).sort((t,e)=>t-e),u=e.clusteredData.map(t=>t.y).sort((t,e)=>t-e),h=m[0],m=m[m.length-1],d=u[0],u=u[u.length-1],f=Math.abs(.1*(m-h)),p=Math.abs(.1*(u-d)),c=Math.min(h,m)-f,h=Math.max(h,m)+f,m=Math.min(d,u)-p,f=Math.max(d,u)+p,r?r.fitToBounds({x1:c,x2:h,y1:m,y2:f}):s&&i&&(o.pointer.zoomX=!0,o.pointer.zoomY=!0,o.zoom({originalEvent:t,xAxis:[{axis:s,min:c,max:h}],yAxis:[{axis:i,min:m,max:f}]})))})}function pixelsToValues(t,e){const{chart:a,xAxis:s,yAxis:i}=t;return a.mapView?a.mapView.pixelsToProjectedUnits(e):{x:s?s.toValue(e.x):0,y:i?i.toValue(e.y):0}}function seriesAnimateClusterPoint(t){const e=this.chart,a=e.mapView,s=this.options.cluster,i=animObject((s||{}).animation),o=i.duration||500,r=(this.markerClusterInfo||{}).pointsState,n=(r||{}).newState,l=(r||{}).oldState,d=[];let u,p,c,h,m,f,x,g=!1,y=!1;var C;l&&n&&(C=valuesToPixels(this,c=n[t.stateId]),f=C.x-(a?0:e.plotLeft),x=C.y-(a?0:e.plotTop),1===c.parentsId.length?(u=(n||{})[t.stateId].parentsId[0],p=l[u],c.point&&c.point.graphic&&p&&p.point&&p.point.plotX&&p.point.plotY&&p.point.plotX!==c.point.plotX&&p.point.plotY!==c.point.plotY&&(h=c.point.graphic.getBBox(),m=c.point.graphic&&c.point.graphic.isImg?0:h.width/2,c.point.graphic.attr({x:p.point.plotX-m,y:p.point.plotY-m}),c.point.graphic.animate({x:f-(c.point.graphic.radius||0),y:x-(c.point.graphic.radius||0)},i,function(){y=!0,p.point&&p.point.destroy&&p.point.destroy()}),c.point.dataLabel&&c.point.dataLabel.alignAttr&&p.point.dataLabel&&p.point.dataLabel.alignAttr&&(c.point.dataLabel.attr({x:p.point.dataLabel.alignAttr.x,y:p.point.dataLabel.alignAttr.y}),c.point.dataLabel.animate({x:c.point.dataLabel.alignAttr.x,y:c.point.dataLabel.alignAttr.y},i)))):0===c.parentsId.length?(hideStatePoint(c,!0,!0),syncTimeout(function(){fadeInStatePoint(c,.1,i,!0,!0)},o/2)):(hideStatePoint(c,!0,!0),c.parentsId.forEach(function(t){l&&l[t]&&(p=l[t],d.push(p),p.point&&p.point.graphic&&(g=!0,p.point.graphic.show(),p.point.graphic.animate({x:f-(p.point.graphic.radius||0),y:x-(p.point.graphic.radius||0),opacity:.4},i,function(){y=!0,fadeInNewPointAndDestoryOld(c,d,i,.7)}),p.point.dataLabel&&-9999!==p.point.dataLabel.y&&c.point&&c.point.dataLabel&&c.point.dataLabel.alignAttr&&(p.point.dataLabel.show(),p.point.dataLabel.animate({x:c.point.dataLabel.alignAttr.x,y:c.point.dataLabel.alignAttr.y,opacity:.4},i))))}),syncTimeout(function(){y||fadeInNewPointAndDestoryOld(c,d,i,.85)},o),g||syncTimeout(function(){fadeInNewPointAndDestoryOld(c,d,i,.1)},o/2)))}function seriesDestroyClusteredData(){const t=this.markerClusterSeriesData;(t||[]).forEach(function(t){t&&t.destroy&&t.destroy()}),this.markerClusterSeriesData=null}function seriesGeneratePoints(){const a=this,t=a.chart,e=t.mapView,s=a.xData,i=a.yData,o=a.options.cluster,r=a.getRealExtremes(),n=[],l=[],d=[];let u,p,c,h,m,f,x,g,y,C,I,S,D,P,b,M,k;if(e&&a.is("mappoint")&&s&&i&&(a.options.data||[]).forEach((t,e)=>{t=a.projectPoint(t);t&&(s[e]=t.x,i[e]=t.y)}),o&&o.enabled&&s&&s.length&&i&&i.length&&!t.polar){I=o.layoutAlgorithm.type,(b=o.layoutAlgorithm).processedGridSize=relativeLength(b.gridSize||clusterDefaults.layoutAlgorithm.gridSize,t.plotWidth),b.processedDistance=relativeLength(b.distance||clusterDefaults.layoutAlgorithm.distance,t.plotWidth),h=b.kmeansThreshold||clusterDefaults.layoutAlgorithm.kmeansThreshold;var A=b.processedGridSize/2,X=pixelsToValues(a,{x:0,y:0}),A=pixelsToValues(a,{x:A,y:A});for(m=Math.abs(X.x-A.x),f=Math.abs(X.y-A.y),k=0;k<s.length;k++)a.dataMaxX||(defined(g)&&defined(x)&&defined(C)&&defined(y)?isNumber(i[k])&&isNumber(C)&&isNumber(y)&&(g=Math.max(s[k],g),x=Math.min(s[k],x),C=Math.max(i[k]||C,C),y=Math.min(i[k]||y,y)):(g=x=s[k],C=y=i[k])),s[k]>=r.minX-m&&s[k]<=r.maxX+m&&(i[k]||r.minY)>=r.minY-f&&(i[k]||r.maxY)<=r.maxY+f&&(n.push(s[k]),l.push(i[k]),d.push(k));defined(g)&&defined(x)&&isNumber(C)&&isNumber(y)&&(a.dataMaxX=g,a.dataMinX=x,a.dataMaxY=C,a.dataMinY=y),D=(P=(S=isFunction(I)?I:a.markerClusterAlgorithms?I&&a.markerClusterAlgorithms[I]?a.markerClusterAlgorithms[I]:n.length<h?a.markerClusterAlgorithms.kmeans:a.markerClusterAlgorithms.grid:function(){return!1}).call(this,n,l,d,b))&&a.getClusteredData(P,o),u=o.animation&&a.markerClusterInfo&&a.markerClusterInfo.pointsState&&a.markerClusterInfo.pointsState.oldState?(destroyOldPoints(a.markerClusterInfo.pointsState.oldState),a.markerClusterInfo.pointsState.newState):{},p=s.length,c=a.markerClusterInfo,D&&(a.processedXData=D.groupedXData,a.processedYData=D.groupedYData,a.hasGroupedData=!0,a.markerClusterInfo=D,a.groupMap=D.groupMap),baseGeneratePoints.apply(this),D&&a.markerClusterInfo&&((a.markerClusterInfo.clusters||[]).forEach(function(t){(M=a.points[t.index]).isCluster=!0,M.clusteredData=t.data,M.clusterPointsAmount=t.data.length,t.point=M,addEvent(M,"click",onPointDrillToCluster)}),(a.markerClusterInfo.noise||[]).forEach(function(t){t.point=a.points[t.index]}),o.animation&&a.markerClusterInfo&&(a.markerClusterInfo.pointsState={oldState:u,newState:a.getPointsState(D,c,p)}),o.animation?this.hideClusteredData():this.destroyClusteredData(),this.markerClusterSeriesData=this.hasGroupedData?this.points:null)}else baseGeneratePoints.apply(this)}function seriesGetClusterDistancesFromPoint(e,a,s){const i=[];for(let t=0;t<e.length;t++){var o=valuesToPixels(this,{x:a,y:s}),r=valuesToPixels(this,{x:e[t].posX,y:e[t].posY}),o=Math.sqrt(Math.pow(o.x-r.x,2)+Math.pow(o.y-r.y,2));i.push({clusterIndex:t,distance:o})}return i.sort((t,e)=>t.distance-e.distance)}function seriesGetClusteredData(t,e){const a=this,s=[],i=[],o=[],r=[],n=[],l=Math.max(2,e.minimumClusterSize||2);let d=0,u,p,c,h,m,f,x,g,y,C,I,S,D,P;if(isFunction(e.layoutAlgorithm.type)&&!a.isValidGroupedDataObject(t))return error("Highcharts marker-clusters module: The custom algorithm result is not valid!",!1,a.chart),!1;for(P in t)if(t[P].length>=l){if(c=t[P],u=getStateId(),m=c.length,e.zones)for(D=0;D<e.zones.length;D++)m>=e.zones[D].from&&m<=e.zones[D].to&&((I=e.zones[D]).zoneIndex=D,C=e.zones[D].marker,S=e.zones[D].className);for(y=getClusterPosition(c),x="grid"!==e.layoutAlgorithm.type||e.allowOverlap?{x:y.x,y:y.y}:(f=a.options.marker||{},a.preventClusterCollisions({x:y.x,y:y.y,key:P,groupedData:t,gridSize:a.getScaledGridSize(e.layoutAlgorithm),defaultRadius:f.radius||3+(f.lineWidth||0),clusterRadius:C&&C.radius?C.radius:(e.marker||{}).radius||clusterDefaults.marker.radius})),D=0;D<m;D++)c[D].parentStateId=u;if(o.push({x:x.x,y:x.y,id:P,stateId:u,index:d,data:c,clusterZone:I,clusterZoneClassName:S}),s.push(x.x),i.push(x.y),n.push({options:{formatPrefix:"cluster",dataLabels:e.dataLabels,marker:merge(e.marker,{states:e.states},C||{})}}),a.options.data&&a.options.data.length)for(D=0;D<m;D++)isObject(a.options.data[c[D].dataIndex])&&(c[D].options=a.options.data[c[D].dataIndex]);d++,C=null}else for(D=0;D<t[P].length;D++)p=t[P][D],u=getStateId(),g=null,h=((a.options||{}).data||[])[p.dataIndex],s.push(p.x),i.push(p.y),p.parentStateId=u,r.push({x:p.x,y:p.y,id:P,stateId:u,index:d,data:t[P]}),g=h&&"object"==typeof h&&!isArray(h)?merge(h,{x:p.x,y:p.y}):{userOptions:h,x:p.x,y:p.y},n.push({options:g}),d++;return{clusters:o,noise:r,groupedXData:s,groupedYData:i,groupMap:n}}function seriesGetGridOffset(){const t=this,e=t.chart,a=t.xAxis,s=t.yAxis;let i=0,o=0;return i=a&&t.dataMinX&&t.dataMaxX?a.reversed?a.toPixels(t.dataMaxX):a.toPixels(t.dataMinX):e.plotLeft,o=s&&t.dataMinY&&t.dataMaxY?s.reversed?s.toPixels(t.dataMinY):s.toPixels(t.dataMaxY):e.plotTop,{plotLeft:i,plotTop:o}}function seriesGetPointsState(t,e,a){const s=e?getDataState(e,a):[],i=getDataState(t,a),o={};var r,n;oldPointsStateId=[],t.clusters.forEach(function(t){o[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),t.noise.forEach(function(t){o[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}});for(let t=0;t<i.length;t++)r=i[t],n=s[t],r&&n&&r.parentStateId&&n.parentStateId&&o[r.parentStateId]&&-1===o[r.parentStateId].parentsId.indexOf(n.parentStateId)&&(o[r.parentStateId].parentsId.push(n.parentStateId),-1===oldPointsStateId.indexOf(n.parentStateId)&&oldPointsStateId.push(n.parentStateId));return o}function seriesGetRealExtremes(){var t=this.chart,e=t.mapView?0:t.plotLeft,a=pixelsToValues(this,{x:e,y:t.mapView?0:t.plotTop}),e=pixelsToValues(this,{x:e+t.plotWidth,y:e+t.plotHeight}),t=a.x,s=e.x,a=a.y,e=e.y;return{minX:Math.min(t,s),maxX:Math.max(t,s),minY:Math.min(a,e),maxY:Math.max(a,e)}}function seriesGetScaledGridSize(t){const e=this,a=e.xAxis,s=this.chart.mapView,i=t.processedGridSize||clusterDefaults.layoutAlgorithm.gridSize;let o=!0,r=1,n=1;e.gridValueSize||(s?e.gridValueSize=i/s.getScale():e.gridValueSize=Math.abs(a.toValue(i)-a.toValue(0)));for(var l=+(i/(s?e.gridValueSize*s.getScale():a.toPixels(e.gridValueSize)-a.toPixels(0))).toFixed(14);o&&1!=l;){var d=Math.pow(2,r);.75<l&&l<1.25?o=!1:1/d<=l&&l<1/d*2?(o=!1,n=d):l<=d&&d/2<l&&(o=!1,n=1/d),r++}return i/n/l}function seriesHideClusteredData(){const t=this.markerClusterSeriesData,e=((this.markerClusterInfo||{}).pointsState||{}).oldState||{},a=oldPointsStateId.map(t=>(e[t].point||{}).id||"");(t||[]).forEach(function(t){t&&-1!==a.indexOf(t.id)?(t.graphic&&t.graphic.hide(),t.dataLabel&&t.dataLabel.hide()):t&&t.destroy&&t.destroy()})}function seriesIsValidGroupedDataObject(t){let e=!1,a;return!!isObject(t)&&(objectEach(t,function(t){if(e=!0,isArray(t)&&t.length){for(a=0;a<t.length;a++)if(!isObject(t[a])||!t[a].x||!t[a].y)return void(e=!1)}else e=!1}),e)}function seriesPreventClusterCollisions(t){const e=this,[a,s]=t.key.split("-").map(parseFloat),i=t.gridSize,o=t.groupedData,r=t.defaultRadius,n=t.clusterRadius,l=s*i,d=a*i,u=valuesToPixels(e,t),p=[],c=(e.options.cluster||{}).marker,h=(e.options.cluster||{}).zones,m=e.getGridOffset();let f=u.x,x=u.y,g,y=0,C,I,S,D,P,b,M,k,A,X,Y,v,L;for(f-=m.plotLeft,x-=m.plotTop,M=1;M<5;M++)for(S=M%2?-1:1,D=M<3?-1:1,P=Math.floor((f+S*n)/i),L=[(b=Math.floor((x+D*n)/i))+"-"+P,b+"-"+s,a+"-"+P],k=0;k<L.length;k++)-1===p.indexOf(L[k])&&L[k]!==t.key&&p.push(L[k]);for(const T of p)if(o[T]){o[T].posX||(Y=getClusterPosition(o[T]),o[T].posX=Y.x,o[T].posY=Y.y);const G=valuesToPixels(e,{x:o[T].posX||0,y:o[T].posY||0});if(C=G.x-m.plotLeft,I=G.y-m.plotTop,[X,A]=T.split("-").map(parseFloat),h)for(g=o[T].length,M=0;M<h.length;M++)g>=h[M].from&&g<=h[M].to&&(y=defined((h[M].marker||{}).radius)?h[M].marker.radius||0:(c&&c.radius?c:clusterDefaults.marker).radius);1<o[T].length&&0===y&&c&&c.radius?y=c.radius:1===o[T].length&&(y=r),v=n+y,y=0,A!==s&&Math.abs(f-C)<v&&(f=A-s<0?l+n:l+i-n),X!==a&&Math.abs(x-I)<v&&(x=X-a<0?d+n:d+i-n)}const G=pixelsToValues(e,{x:f+m.plotLeft,y:x+m.plotTop});return o[t.key].posX=G.x,o[t.key].posY=G.y,G}function valuesToPixels(t,e){const{chart:a,xAxis:s,yAxis:i}=t;return a.mapView?a.mapView.projectedUnitsToPixels(e):{x:s?s.toPixels(e.x):0,y:i?i.toPixels(e.y):0}}const MarkerClusterScatter={compose:compose};export default MarkerClusterScatter;