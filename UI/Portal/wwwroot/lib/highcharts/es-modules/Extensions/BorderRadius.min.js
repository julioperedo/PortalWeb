"use strict";import D from"../Core/Defaults.js";const defaultOptions=D["defaultOptions"];import G from"../Core/Globals.js";const noop=G["noop"];import U from"../Core/Utilities.js";const{addEvent,extend,isObject,merge,pushUnique,relativeLength}=U,composedMembers=[],defaultBorderRadiusOptions={radius:0,scope:"stack",where:void 0};let oldArc=noop,oldRoundedRect=noop;function applyBorderRadius(t,e,s){var o=t[e];let r=t[e+1];"Z"===r[0]&&(r=t[0]);let a,n,i;if("M"!==o[0]&&"L"!==o[0]||"A"!==r[0]?"A"!==o[0]||"M"!==r[0]&&"L"!==r[0]||(a=r,n=o):(a=o,n=r,i=!0),a&&n&&n.params){const c=n[1],p=n[5],u=n.params,{start:l,end:m,cx:M,cy:b}=u;var o=p?c-s:c+s,d=o?Math.asin(s/o):0,h=p?d:-d,d=Math.cos(d)*o;i?(u.start=l+h,a[1]=M+d*Math.cos(l),a[2]=b+d*Math.sin(l),t.splice(e+1,0,["A",s,s,0,0,1,M+c*Math.cos(u.start),b+c*Math.sin(u.start)])):(u.end=m-h,n[6]=M+c*Math.cos(u.end),n[7]=b+c*Math.sin(u.end),t.splice(e+1,0,["A",s,s,0,0,1,M+d*Math.cos(m),b+d*Math.sin(m)])),n[4]=Math.abs(u.end-u.start)<Math.PI?0:1}}function arc(t,e,s,o,r={}){var a=oldArc(t,e,s,o,r),{innerR:t=0,r:e=s,start:o=0,end:s=0}=r;if(r.open||!r.borderRadius)return a;var s=s-o,o=Math.sin(s/2),n=Math.max(Math.min(relativeLength(r.borderRadius||0,e-t),(e-t)/2,e*o/(1+o)),0),i=Math.min(n,s/Math.PI*2*t);let d=a.length-1;for(;d--;)applyBorderRadius(a,d,1<d?i:n);return a}function seriesOnAfterColumnTranslate(){if(this.options.borderRadius&&(!this.chart.is3d||!this.chart.is3d())){const{options:d,yAxis:h}=this,c="percent"===d.stacking,t=defaultOptions.plotOptions?.[this.type]?.borderRadius,p=optionsToObject(d.borderRadius,isObject(t)?t:{}),u=h.options.reversed;for(const l of this.points){var o=l["shapeArgs"];if("roundedRect"===l.shapeType&&o){var{width:r=0,height:a=0,y:n=0}=o;let t=n,e=a;"stack"===p.scope&&l.stackTotal&&(n=h.translate(c?100:l.stackTotal,!1,!0,!1,!0),i=h.translate(d.threshold||0,!1,!0,!1,!0),n=this.crispCol(0,Math.min(n,i),0,Math.abs(n-i)),t=n.y,e=n.height);var i=(l.negative?-1:1)*(u?-1:1)==-1;let s=p.where;s=(s=!s&&this.is("waterfall")&&Math.abs((l.yBottom||0)-(this.translatedThreshold||0))>this.borderWidth?"all":s)||"end";n=Math.min(relativeLength(p.radius,r),r/2,"all"===s?a/2:1/0)||0;"end"===s&&(i&&(t-=n),e+=n),extend(o,{brBoxHeight:e,brBoxY:t,r:n})}}}}function compose(t,e,s,o){if(pushUnique(composedMembers,t)&&addEvent(t,"afterColumnTranslate",seriesOnAfterColumnTranslate,{order:9}),pushUnique(composedMembers,e)&&addEvent(e,"afterTranslate",pieSeriesOnAfterTranslate),pushUnique(composedMembers,s)&&s.symbolCustomAttribs.push("borderRadius","brBoxHeight","brBoxY"),pushUnique(composedMembers,o)){const r=o.prototype.symbols;oldArc=r.arc,oldRoundedRect=r.roundedRect,r.arc=arc,r.roundedRect=roundedRect}}function optionsToObject(t,e){return isObject(t)||(t={radius:t||0}),merge(defaultBorderRadiusOptions,e,t)}function pieSeriesOnAfterTranslate(){var t=optionsToObject(this.options.borderRadius);for(const e of this.points){const s=e.shapeArgs;s&&(s.borderRadius=relativeLength(t.radius,(s.r||0)-(s.innerR||0)))}}function roundedRect(t,e,s,o,r={}){const a=oldRoundedRect(t,e,s,o,r),{r:n=0,brBoxHeight:i=o,brBoxY:d=e}=r,h=e-d,c=d+i-(e+o),p=-.1<h-n?0:n,u=-.1<c-n?0:n,l=Math.max(p&&h,0),m=Math.max(u&&c,0),M=[t+p,e],b=[t+s-p,e],f=[t+s,e+p],R=[t+s,e+o-u],v=[t+s-u,e+o],A=[t+u,e+o],O=[t,e+o-u],g=[t,e+p];var x,r=(t,e)=>Math.sqrt(Math.pow(t,2)-Math.pow(e,2));return l&&(x=r(p,p-l),M[0]-=x,b[0]+=x,f[1]=g[1]=e+p-l),o<p-l&&(x=r(p,p-l-o),f[0]=R[0]=t+s-p+x,v[0]=Math.min(f[0],v[0]),A[0]=Math.max(R[0],A[0]),O[0]=g[0]=t+p-x,f[1]=g[1]=e+o),m&&(x=r(u,u-m),v[0]+=x,A[0]-=x,R[1]=O[1]=e+o-u+m),o<u-m&&(x=r(u,u-m-o),f[0]=R[0]=t+s-u+x,b[0]=Math.min(f[0],b[0]),M[0]=Math.max(R[0],M[0]),O[0]=g[0]=t+u-x,R[1]=O[1]=e),a.length=0,a.push(["M",...M],["L",...b],["A",p,p,0,0,1,...f],["L",...R],["A",u,u,0,0,1,...v],["L",...A],["A",u,u,0,0,1,...O],["L",...g],["A",p,p,0,0,1,...M],["Z"]),a}const BorderRadius={compose:compose,optionsToObject:optionsToObject};export default BorderRadius;