"use strict";import FormulaTypes from"./FormulaTypes.js";const{isFormula,isFunction,isOperator,isRange,isReference,isValue}=FormulaTypes,asLogicalStringRegExp=/ */,MAX_FALSE=Number.MAX_VALUE/1.000000000001,MAX_STRING=Number.MAX_VALUE/1.000000000002,MAX_TRUE=Number.MAX_VALUE,operatorPriority={"^":3,"*":2,"/":2,"+":1,"-":1,"=":0,"<":0,"<=":0,">":0,">=":0},processorFunctions={},processorFunctionNameRegExp=/^[A-Z][A-Z\.]*$/;function asLogicalNumber(e){switch(typeof e){case"boolean":return e?MAX_TRUE:MAX_FALSE;case"string":return MAX_STRING;case"number":return e;default:return NaN}}function asLogicalString(e){return"string"==typeof e?e.toLowerCase().replace(asLogicalStringRegExp,"\0"):e}function asNumber(e){switch(typeof e){case"boolean":return e?1:0;case"string":return parseFloat(e.replace(",","."));case"number":return e;default:return NaN}}function basicOperation(e,r,o){switch(e){case"=":return asLogicalString(r)===asLogicalString(o);case"<":return typeof r==typeof o?asLogicalString(r)<asLogicalString(o):asLogicalNumber(r)<asLogicalNumber(o);case"<=":return typeof r==typeof o?asLogicalString(r)<=asLogicalString(o):asLogicalNumber(r)<=asLogicalNumber(o);case">":return typeof r==typeof o?asLogicalString(r)>asLogicalString(o):asLogicalNumber(r)>asLogicalNumber(o);case">=":return typeof r==typeof o?asLogicalString(r)>=asLogicalString(o):asLogicalNumber(r)>=asLogicalNumber(o)}r=asNumber(r),o=asNumber(o);let n;switch(e){case"+":n=r+o;break;case"-":n=r-o;break;case"*":n=r*o;break;case"/":n=r/o;break;case"^":n=Math.pow(r,o);break;default:return NaN}return n%1?Math.round(1e9*n)/1e9:n}function getArgumentValue(e,r){return isValue(e)?e:isRange(e)?r&&getRangeValues(e,r)||[]:isFunction(e)?processFunction(e,r):processFormula(isFormula(e)?e:[e],r)}function getArgumentsValues(o,n){const t=[];for(let e=0,r=o.length;e<r;++e)t.push(getArgumentValue(o[e],n));return t}function getRangeValues(t,a){const s=a.getColumnNames().slice(t.beginColumn,t.endColumn+1),i=[];for(let o=0,e=s.length,n;o<e;++o){var u=a.getColumn(s[o],!0)||[];for(let e=t.beginRow,r=t.endRow+1;e<r;++e)"string"==typeof(n=u[e])&&"="===n[0]&&a!==a.modified&&(n=a.modified.getCell(s[o],e)),i.push(isValue(n)?n:NaN)}return i}function getReferenceValue(e,r){var o,n=r.getColumnNames()[e.column];return n?"string"==typeof(o=r.getCell(n,e.row))&&"="===o[0]&&r!==r.modified?(r=r.modified.getCell(n,e.row),isValue(r)?r:NaN):isValue(o)?o:NaN:NaN}function processFormula(s,i){let u;for(let e=0,r=s.length,o,n,t,a;e<r;++e)if(o=s[e],isOperator(o))n=o;else if(isValue(o)?a=o:isFormula(o)?a=processFormula(s,i):isFunction(o)?(t=processFunction(o,i),a=isValue(t)?t:NaN):isReference(o)&&(a=i&&getReferenceValue(o,i)),void 0!==a){if(void 0===u)u=n?basicOperation(n,0,a):a;else{if(!n)return NaN;var c=s[e+1];isOperator(c)&&operatorPriority[c]>operatorPriority[n]&&(a=basicOperation(c,a,processFormula(s.slice(e+2))),e=r),u=basicOperation(n,u,a)}n=void 0,a=void 0}return isValue(u)?u:NaN}function processFunction(e,r,o){const n=processorFunctions[e.name];if(n)try{return n(e.args,r)}catch{return NaN}const t=new Error(`Function "${e.name}" not found.`);throw t.name="FormulaProcessError",t}function registerProcessorFunction(e,r){return processorFunctionNameRegExp.test(e)&&!processorFunctions[e]&&!!(processorFunctions[e]=r)}function translateReferences(n,t=0,a=0){for(let e=0,r=n.length,o;e<r;++e)(o=n[e])instanceof Array?translateReferences(o,t,a):isFunction(o)?translateReferences(o.args,t,a):isRange(o)?(o.beginColumnRelative&&(o.beginColumn+=t),o.beginRowRelative&&(o.beginRow+=a),o.endColumnRelative&&(o.endColumn+=t),o.endRowRelative&&(o.endRow+=a)):isReference(o)&&(o.columnRelative&&(o.column+=t),o.rowRelative&&(o.row+=a));return n}const FormulaProcessor={asNumber:asNumber,getArgumentValue:getArgumentValue,getArgumentsValues:getArgumentsValues,getRangeValues:getRangeValues,getReferenceValue:getReferenceValue,processFormula:processFormula,processorFunctions:processorFunctions,registerProcessorFunction:registerProcessorFunction,translateReferences:translateReferences};export default FormulaProcessor;