"use strict";import T from"../../Templating.js";const format=T["format"];import SeriesRegistry from"../../Series/SeriesRegistry.js";const Series=SeriesRegistry["series"];import U from"../../Utilities.js";const{destroyObjectProperties,fireEvent,isNumber,pick}=U;class StackItem{constructor(t,i,e,s,r){var l=t.chart.inverted,o=t.reversed,t=(this.axis=t,this.isNegative=!!e!=!!o);this.options=i=i||{},this.x=s,this.total=null,this.cumulative=null,this.points={},this.hasValidPoints=!1,this.stack=r,this.leftCliff=0,this.rightCliff=0,this.alignOptions={align:i.align||(l?t?"left":"right":"center"),verticalAlign:i.verticalAlign||(l?"middle":t?"bottom":"top"),y:i.y,x:i.x},this.textAlign=i.textAlign||(l?t?"right":"left":"center")}destroy(){destroyObjectProperties(this,this.axis)}render(t){const i=this.axis.chart,e=this.options,s=e.format,r=s?format(s,this,i):e.formatter.call(this);if(this.label)this.label.attr({text:r,visibility:"hidden"});else{this.label=i.renderer.label(r,null,void 0,e.shape,void 0,void 0,e.useHTML,!1,"stack-labels");const l={r:e.borderRadius||0,text:r,padding:pick(e.padding,5),visibility:"hidden"};i.styledMode||(l.fill=e.backgroundColor,l.stroke=e.borderColor,l["stroke-width"]=e.borderWidth,this.label.css(e.style||{})),this.label.attr(l),this.label.added||this.label.add(t)}this.label.labelrank=i.plotSizeY,fireEvent(this,"afterRender")}setOffset(t,i,e,s,r,l){const{alignOptions:o,axis:a,label:n,options:h,textAlign:d}=this,x=a.chart,c=this.getStackBox({xOffset:t,width:i,boxBottom:e,boxTop:s,defaultX:r,xAxis:l}),g=o["verticalAlign"];if(n&&c){e=n.getBBox(),s=n.padding;let t="justify"===pick(h.overflow,"justify"),i;o.x=h.x||0,o.y=h.y||0;var{x:r,y:l}=this.adjustStackPosition({labelBox:e,verticalAlign:g,textAlign:d});c.x-=r,c.y-=l,n.align(o,!1,c),i=x.isInsidePlot(n.alignAttr.x+o.x+r,n.alignAttr.y+o.y+l),(t=i?t:!1)&&Series.prototype.justifyDataLabel.call(a,n,o,n.alignAttr,e,c),n.attr({x:n.alignAttr.x,y:n.alignAttr.y,rotation:h.rotation,rotationOriginX:e.width/2,rotationOriginY:e.height/2}),pick(!t&&h.crop,!0)&&(i=isNumber(n.x)&&isNumber(n.y)&&x.isInsidePlot(n.x-s+(n.width||0),n.y)&&x.isInsidePlot(n.x+s,n.y)),n[i?"show":"hide"]()}fireEvent(this,"afterSetOffset",{xOffset:t,width:i})}adjustStackPosition({labelBox:t,verticalAlign:i,textAlign:e}){var s={bottom:0,middle:1,top:2,right:1,center:0,left:-1};return{x:t.width/2+t.width/2*s[e],y:t.height/2*s[i]}}getStackBox(t){const i=this.axis,e=i.chart,{boxTop:s,defaultX:r,xOffset:l,width:o,boxBottom:a}=t,n=i.stacking.usePercentage?100:pick(s,this.total,0),h=i.toPixels(n),d=t.xAxis||e.xAxis[0],x=pick(r,d.translate(this.x))+l,c=i.toPixels(a||isNumber(i.min)&&i.logarithmic&&i.logarithmic.lin2log(i.min)||0),g=Math.abs(h-c),f=e.inverted,p=this.isNegative;return f?{x:(p?h:h-g)-e.plotLeft,y:d.height-x-o,width:g,height:o}:{x:x+d.transB-e.plotLeft,y:(p?h-g:h)-e.plotTop,width:o,height:g}}}export default StackItem;