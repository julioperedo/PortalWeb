"use strict";import AxisDefaults from"./AxisDefaults.js";import D from"../Defaults.js";const defaultOptions=D["defaultOptions"];import H from"../Globals.js";const noop=H["noop"];import U from"../Utilities.js";const{addEvent,correctFloat,defined,extend,fireEvent,merge,pick,relativeLength,wrap}=U;var RadialAxis;!function(t){const s=[],d={gridLineWidth:1,labels:{align:void 0,x:0,y:void 0,style:{textOverflow:"none"}},maxPadding:0,minPadding:0,showLastLabel:!1,tickLength:0},p={labels:{align:"center",distance:-25,x:0,y:void 0},minorGridLineWidth:0,minorTickInterval:"auto",minorTickLength:10,minorTickPosition:"inside",minorTickWidth:1,tickLength:10,tickPosition:"inside",tickWidth:2,title:{rotation:0},zIndex:2},u={gridLineInterpolation:"circle",gridLineWidth:1,labels:{align:"right",x:-3,y:-2},showLastLabel:!1,title:{x:4,text:null,rotation:90}};function i(){this.autoConnect=this.isCircular&&void 0===pick(this.userMax,this.options.max)&&correctFloat(this.endAngleRad-this.startAngleRad)===correctFloat(2*Math.PI),!this.isCircular&&this.chart.inverted&&this.max++,this.autoConnect&&(this.max+=(this.categories?1:this.pointRange)||this.closestPointRange||0)}function e(){return()=>{if(this.isRadial&&this.tickPositions&&this.options.labels&&!0!==this.options.labels.allowOverlap)return this.tickPositions.map(t=>this.ticks[t]&&this.ticks[t].label).filter(t=>Boolean(t))}}function g(){return noop}function n(t,i,s){var e=this.pane.center;let n=t.value,a,o,r;return this.isCircular?(defined(n)?t.point&&(t.point.shapeArgs||{}).start&&(n=this.chart.inverted?this.translate(t.point.rectPlotY,!0):t.point.x):(o=t.chartX||0,r=t.chartY||0,n=this.translate(Math.atan2(r-s,o-i)-this.startAngleRad,!0)),a=this.getPosition(n),o=a.x,r=a.y):(defined(n)||(o=t.chartX,r=t.chartY),defined(o)&&defined(r)&&(s=e[1]+this.chart.plotTop,n=this.translate(Math.min(Math.sqrt(Math.pow(o-i,2)+Math.pow(r-s,2)),e[2]/2)-e[3]/2,!0))),[n,o||0,r||0]}function a(t,i,s){var e=this.pane.center,n=this.chart,a=this.left||0,o=this.top||0;let r,h=pick(i,e[2]/2-this.offset),l;return(s=void 0===s?this.horiz?0:this.center&&-this.center[3]/2:s)&&(h+=s),this.isCircular||void 0!==i?((l=this.chart.renderer.symbols.arc(a+e[0],o+e[1],h,h,{start:this.startAngleRad,end:this.endAngleRad,open:!0,innerR:0})).xBounds=[a+e[0]],l.yBounds=[o+e[1]-h]):(r=this.postTranslate(this.angleRad,h),l=[["M",this.center[0]+n.plotLeft,this.center[1]+n.plotTop],["L",r.x,r.y]]),l}function o(){const t=this.constructor.prototype;t.getOffset.call(this),this.chart.axisOffset[this.side]=0}function r(t,i,s){const e=this.chart,n=i=>{if("string"!=typeof i)return i;{let t=parseInt(i,10);return t=d.test(i)?t*r/100:t}},a=this.center,o=this.startAngleRad,r=a[2]/2,h=Math.min(this.offset,0),l=this.left||0,c=this.top||0,d=/%$/,p=this.isCircular;let u,g,f,x,P,A,v=pick(n(s.outerRadius),r),m=n(s.innerRadius),R=pick(n(s.thickness),10);return"polygon"===this.options.gridLineInterpolation?A=this.getPlotLinePath({value:t}).concat(this.getPlotLinePath({value:i,reverse:!0})):(t=Math.max(t,this.min),i=Math.min(i,this.max),t=this.translate(t),i=this.translate(i),p||(v=t||0,m=i||0),"circle"!==s.shape&&p?(u=o+(t||0),g=o+(i||0)):(u=-Math.PI/2,g=1.5*Math.PI,P=!0),v-=h,R-=h,A=e.renderer.symbols.arc(l+a[0],c+a[1],v,v,{start:Math.min(u,g),end:Math.max(u,g),innerR:pick(m,v-R),open:P}),p&&(f=(g+u)/2,x=l+a[0]+a[2]/2*Math.cos(f),A.xBounds=f>-Math.PI/2&&f<Math.PI/2?[x,e.plotWidth]:[0,x],A.yBounds=[c+a[1]+a[2]/2*Math.sin(f)],A.yBounds[0]+=f>-Math.PI&&f<0||f>Math.PI?-10:10)),A}function h(t){const i=this.pane.center,s=this.chart,e=s.inverted,n=t.reverse,a=this.pane.options.background?this.pane.options.background[0]||this.pane.options.background:{},o=a.innerRadius||"0%",r=a.outerRadius||"100%",h=i[0]+s.plotLeft,l=i[1]+s.plotTop,c=this.height,d=t.isCrosshair,p=i[3]/2;let u=t.value,g,f,x,P,A,v,m,R,M;var L=this.getPosition(u);let k=L.x,b=L.y;if(d&&(R=this.getCrosshairPosition(t,h,l),u=R[0],k=R[1],b=R[2]),this.isCircular)f=Math.sqrt(Math.pow(k-h,2)+Math.pow(b-l,2)),x="string"==typeof o?relativeLength(o,1):o/f,P="string"==typeof r?relativeLength(r,1):r/f,i&&p&&(g=p/f,x<g&&(x=g),P<g&&(P=g)),M=[["M",h+x*(k-h),l-x*(l-b)],["L",k-(1-P)*(k-h),b+(1-P)*(l-b)]];else if((u=this.translate(u))&&(u<0||u>c)&&(u=0),"circle"===this.options.gridLineInterpolation)M=this.getLinePath(0,u,p);else if(M=[],s[e?"yAxis":"xAxis"].forEach(t=>{t.pane===this.pane&&(A=t)}),A){m=A.tickPositions,A.autoConnect&&(m=m.concat([m[0]])),n&&(m=m.slice().reverse()),u&&(u+=p);for(let t=0;t<m.length;t++)v=A.getPosition(m[t],u),M.push(t?["L",v.x,v.y]:["M",v.x,v.y])}return M}function l(t,i){t=this.translate(t);return this.postTranslate(this.isCircular?t:this.angleRad,pick(this.isCircular?i:t<0?0:t,this.center[2]/2)-this.offset)}function c(){var t=this.center,i=this.chart,s=this.options.title;return{x:i.plotLeft+t[0]+(s.x||0),y:i.plotTop+t[1]-{high:.5,middle:.25,low:0}[s.align]*t[2]+(s.y||0)}}function f(t){t.beforeSetTickPositions=i,t.createLabelCollector=e,t.getCrosshairPosition=n,t.getLinePath=a,t.getOffset=o,t.getPlotBandPath=r,t.getPlotLinePath=h,t.getPosition=l,t.getTitlePosition=c,t.postTranslate=L,t.setAxisSize=b,t.setAxisTranslation=y,t.setOptions=C}function x(){var s=this.chart,e=this.options,n=s.angular&&this.isXAxis,a=this.pane,o=a&&a.options;if(!n&&a&&(s.angular||s.polar)){n=2*Math.PI,a=(pick(o.startAngle,0)-90)*Math.PI/180,s=(pick(o.endAngle,pick(o.startAngle,0)+360)-90)*Math.PI/180;this.angleRad=(e.angle||0)*Math.PI/180,this.startAngleRad=a,this.endAngleRad=s,this.offset=e.offset||0;let t=(a%n+n)%n,i=(s%n+n)%n;t>Math.PI&&(t-=n),i>Math.PI&&(i-=n),this.normalizedStartAngleRad=t,this.normalizedEndAngleRad=i}}function P(t){this.isRadial&&(t.align=void 0,t.preventDefault())}function A(){var t;this.chart&&this.chart.labelCollectors&&(0<=(t=this.labelCollector?this.chart.labelCollectors.indexOf(this.labelCollector):-1)&&this.chart.labelCollectors.splice(t,1))}function v(t){const i=this.chart,s=i.inverted,e=i.angular,n=i.polar,a=this.isXAxis,o=this.coll,r=e&&a,h=t.userOptions.pane||0,l=this.pane=i.pane&&i.pane[h];let c;"colorAxis"===o?this.isRadial=!1:(e?(r?((t=this).isHidden=!0,t.createLabelCollector=g,t.getOffset=noop,t.redraw=k,t.render=k,t.setScale=noop,t.setCategories=noop,t.setTitle=noop):f(this),(c=!a)&&(this.defaultPolarOptions=p)):n&&(f(this),c=this.horiz,this.defaultPolarOptions=c?d:merge("xAxis"===o?AxisDefaults.defaultXAxisOptions:AxisDefaults.defaultYAxisOptions,u),s&&"yAxis"===o&&(this.defaultPolarOptions.stackLabels=AxisDefaults.defaultYAxisOptions.stackLabels,this.defaultPolarOptions.reversedStacks=!0)),e||n?(this.isRadial=!0,this.labelCollector||(this.labelCollector=this.createLabelCollector()),this.labelCollector&&i.labelCollectors.push(this.labelCollector)):this.isRadial=!1,l&&c&&(l.axis=this),this.isCircular=c)}function m(){this.isRadial&&this.beforeSetTickPositions()}function R(l){const c=this.label;if(c){const d=this.axis,p=c.getBBox(),u=d.options.labels,g=(d.translate(this.pos)+d.startAngleRad+Math.PI/2)/Math.PI*180%360,f=Math.round(g),x=defined(u.y)?0:.3*-p.height;let t=u.y,i,s=20,e=u.align,n="end",a=f<0?f+360:f,o=a,r=0,h=0;d.isRadial&&(i=d.getPosition(this.pos,d.center[2]/2+relativeLength(pick(u.distance,-25),d.center[2]/2,-d.center[2]/2)),"auto"===u.rotation?c.attr({rotation:g}):defined(t)||(t=d.chart.renderer.fontMetrics(c).b-p.height/2),defined(e)||(e=d.isCircular?g>(s=p.width>d.len*d.tickInterval/(d.max-d.min)?0:s)&&g<180-s?"left":g>180+s&&g<360-s?"right":"center":"center",c.attr({align:e})),"auto"===e&&2===d.tickPositions.length&&d.isCircular&&(90<a&&a<180?a=180-a:270<a&&a<=360&&(a=540-a),180<o&&o<=360&&(o=360-o),d.pane.options.startAngle!==f&&d.pane.options.startAngle!==f+360&&d.pane.options.startAngle!==f-360||(n="start"),e=-90<=f&&f<=90||-360<=f&&f<=-270||270<=f&&f<=360?"start"===n?"right":"left":"start"===n?"left":"right",70<o&&o<110&&(e="center"),a<15||180<=a&&a<195?r=.3*p.height:15<=a&&a<=35?r="start"===n?0:.75*p.height:195<=a&&a<=215?r="start"===n?.75*p.height:0:35<a&&a<=90?r="start"===n?.25*-p.height:p.height:215<a&&a<=270&&(r="start"===n?p.height:.25*-p.height),o<15?h="start"===n?.15*-p.height:.15*p.height:165<o&&o<=180&&(h="start"===n?.15*p.height:.15*-p.height),c.attr({align:e}),c.translate(h,r+x)),l.pos.x=i.x+(u.x||0),l.pos.y=i.y+(t||0))}}function M(t){this.axis.getPosition&&extend(t.pos,this.axis.getPosition(this.pos))}function L(t,i){var s=this.chart,e=this.center;return t=this.startAngleRad+t,{x:s.plotLeft+e[0]+Math.cos(t)*i,y:s.plotTop+e[1]+Math.sin(t)*i}}function k(){this.isDirty=!1}function b(){const t=this.constructor.prototype;let i,s;t.setAxisSize.call(this),this.isRadial&&(this.pane.updateCenter(this),i=this.center=this.pane.center.slice(),this.isCircular?this.sector=this.endAngleRad-this.startAngleRad:(s=this.postTranslate(this.angleRad,i[3]/2),i[0]=s.x-this.chart.plotLeft,i[1]=s.y-this.chart.plotTop),this.len=this.width=this.height=(i[2]-i[3])*pick(this.sector,1)/2)}function y(){const t=this.constructor.prototype;t.setAxisTranslation.call(this),this.center&&(this.isCircular?this.transA=(this.endAngleRad-this.startAngleRad)/(this.max-this.min||1):this.transA=(this.center[2]-this.center[3])/2/(this.max-this.min||1),this.isXAxis?this.minPixelPadding=this.transA*this.minPointOffset:this.minPixelPadding=0)}function C(t){const i=this.options=merge(this.constructor.defaultOptions,this.defaultPolarOptions,defaultOptions[this.coll],t);i.plotBands||(i.plotBands=[]),fireEvent(this,"afterSetOptions")}function I(t,i,s,e,n,a,o){const r=this.axis;let h,l;return l=r.isRadial?["M",i,s,"L",(h=r.getPosition(this.pos,r.center[2]/2+e)).x,h.y]:t.call(this,i,s,e,n,a,o)}t.compose=function(t,i){return U.pushUnique(s,t)&&(addEvent(t,"afterInit",x),addEvent(t,"autoLabelAlign",P),addEvent(t,"destroy",A),addEvent(t,"init",v),addEvent(t,"initialAxisTranslation",m)),U.pushUnique(s,i)&&(addEvent(i,"afterGetLabelPosition",R),addEvent(i,"afterGetPosition",M),wrap(i.prototype,"getMarkPath",I)),t}}(RadialAxis=RadialAxis||{});export default RadialAxis;