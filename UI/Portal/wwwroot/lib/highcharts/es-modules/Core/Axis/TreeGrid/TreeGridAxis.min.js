"use strict";import BrokenAxis from"../BrokenAxis.js";import GridAxis from"../GridAxis.js";import Tree from"../../../Gantt/Tree.js";import TreeGridTick from"./TreeGridTick.js";import TU from"../../../Series/TreeUtilities.js";const getLevelOptions=TU["getLevelOptions"];import U from"../../Utilities.js";const{addEvent,find,fireEvent,isArray,isObject,isString,merge,pick,wrap}=U,composedMembers=[];let TickConstructor;function getBreakFromNode(e,t){var o=e.collapseEnd||0;let r=e.collapseStart||0;return t<=o&&(r-=.5),{from:r,to:o,showPoints:!1}}function getTreeGridFromData(e,t,o){const a=[],s=[],d={},c="boolean"==typeof t&&t;let l={},p=-1;var f,t=Tree.getTree(e,{after:function(e){const t=l[e.pos];let o=0,r=0;t.children.forEach(function(e){r+=(e.descendants||0)+1,o=Math.max((e.height||0)+1,o)}),t.descendants=r,t.height=o,t.collapsed&&s.push(t)},before:function(e){const t=isObject(e.data,!0)?e.data:{},o=isString(t.name)?t.name:"",r=d[e.parent],s=isObject(r,!0)?l[r.pos]:null;let i,n;c&&isObject(s,!0)&&(i=find(s.children,function(e){return e.name===o}))?(n=i.pos,i.nodes.push(e)):n=p++,l[n]||(l[n]=i={depth:s?s.depth+1:0,name:o,id:t.id,nodes:[e],children:[],pos:n},-1!==n&&a.push(o),isObject(s,!0)&&s.children.push(i)),isString(e.id)&&(d[e.id]=e),i&&!0===t.collapsed&&(i.collapsed=!0),e.pos=n}});function u(e,o,t){const r=e.nodes;let s=o+(-1===o?0:f-1);const i=(s-o)/2,n=o+i;return r.forEach(function(e){const t=e.data;isObject(t,!0)&&(t.y=o+(t.seriesIndex||0),delete t.seriesIndex),e.pos=n}),(t[n]=e).pos=n,e.tickmarkOffset=.5+i,e.collapseStart=s+.5,e.children.forEach(function(e){u(e,s+1,t),s=(e.collapseEnd||0)-.5}),e.collapseEnd=s+.5,t}return l=(e=l,f=o,u(e[-1],-1,{})),{categories:a,mapOfIdToNode:d,mapOfPosToGridNode:l,collapsedNodes:s,tree:t}}function onBeforeRender(c){const e=c.target,t=e.axes;t.filter(function(e){return"treegrid"===e.options.type}).forEach(function(e){const t=e.options||{},o=t.labels,r=t.uniqueNames,s=t.max,i=!e.treeGrid.mapOfPosToGridNode||e.series.some(function(e){return!e.hasRendered||e.isDirtyData||e.isDirty});let n=0,a,d;if(i){if(a=e.series.reduce(function(t,o){return o.visible&&((o.options.data||[]).forEach(function(e){o.options.keys&&o.options.keys.length&&(e=o.pointClass.prototype.optionsToObject.call({series:o},e),o.pointClass.setGanttPointAliases(e)),isObject(e,!0)&&(e.seriesIndex=n,t.push(e))}),!0===r&&n++),t},[]),s&&a.length<s)for(let e=a.length;e<=s;e++)a.push({name:e+"â€‹"});d=getTreeGridFromData(a,r||!1,!0===r?n:1),e.categories=d.categories,e.treeGrid.mapOfPosToGridNode=d.mapOfPosToGridNode,e.hasNames=!0,e.treeGrid.tree=d.tree,e.series.forEach(function(e){var t=(e.options.data||[]).map(function(t){return isArray(t)&&e.options.keys&&e.options.keys.length&&a.forEach(function(e){0<=t.indexOf(e.x)&&0<=t.indexOf(e.x2)&&(t=e)}),isObject(t,!0)?merge(t):t});e.visible&&e.setData(t,!1)}),e.treeGrid.mapOptionsToLevel=getLevelOptions({defaults:o,from:1,levels:o&&o.levels,to:e.treeGrid.tree&&e.treeGrid.tree.height}),"beforeRender"===c.type&&(e.treeGrid.collapsedNodes=d.collapsedNodes)}})}function wrapGenerateTick(e,t){const o=this,r=o.treeGrid.mapOptionsToLevel||{},s="treegrid"===o.options.type,i=o.ticks;let n=i[t],a,d,c;s&&o.treeGrid.mapOfPosToGridNode?((a=r[(c=o.treeGrid.mapOfPosToGridNode[t]).depth])&&(d={labels:a}),!n&&TickConstructor?i[t]=n=new TickConstructor(o,t,void 0,void 0,{category:c.name,tickmarkOffset:c.tickmarkOffset,options:d}):(n.parameters.category=c.name,n.options=d,n.addLabel())):e.apply(o,Array.prototype.slice.call(arguments,1))}function wrapInit(e,t,o,r){const s=this,i="treegrid"===o.type;s.treeGrid||(s.treeGrid=new TreeGridAxisAdditions(s)),i&&(addEvent(t,"beforeRender",onBeforeRender),addEvent(t,"beforeRedraw",onBeforeRender),addEvent(t,"addSeries",function(e){e.options.data&&(e=getTreeGridFromData(e.options.data,o.uniqueNames||!1,1),s.treeGrid.collapsedNodes=(s.treeGrid.collapsedNodes||[]).concat(e.collapsedNodes))}),addEvent(s,"foundExtremes",function(){s.treeGrid.collapsedNodes&&s.treeGrid.collapsedNodes.forEach(function(t){var e=s.treeGrid.collapse(t);s.brokenAxis&&(s.brokenAxis.setBreaks(e,!1),s.treeGrid.collapsedNodes&&(s.treeGrid.collapsedNodes=s.treeGrid.collapsedNodes.filter(e=>t.collapseStart!==e.collapseStart||t.collapseEnd!==e.collapseEnd)))})}),addEvent(s,"afterBreaks",function(){"yAxis"===s.coll&&!s.staticScale&&s.chart.options.chart.height&&(s.isDirty=!0)}),o=merge({grid:{enabled:!0},labels:{align:"left",levels:[{level:void 0},{level:1,style:{fontWeight:"bold"}}],symbol:{type:"triangle",x:-5,y:-5,height:10,width:10,padding:5}},uniqueNames:!1},o,{reversed:!0,grid:{columns:void 0}})),e.apply(s,[t,o,r]),i&&(s.hasNames=!0,s.options.showLastLabel=!0)}function wrapSetTickInterval(e){var t=this,o=t.options;"treegrid"===o.type?(t.min=pick(t.userMin,o.min,t.dataMin),t.max=pick(t.userMax,o.max,t.dataMax),fireEvent(t,"foundExtremes"),t.setAxisTranslation(),t.tickmarkOffset=.5,t.tickInterval=1,t.tickPositions=t.treeGrid.mapOfPosToGridNode?t.treeGrid.getTickPositions():[]):e.apply(t,Array.prototype.slice.call(arguments,1))}class TreeGridAxisAdditions{static compose(e,t,o,r){if(U.pushUnique(composedMembers,e)){-1===e.keepProps.indexOf("treeGrid")&&e.keepProps.push("treeGrid");const s=e.prototype;wrap(s,"generateTick",wrapGenerateTick),wrap(s,"init",wrapInit),wrap(s,"setTickInterval",wrapSetTickInterval),s.utils={getNode:Tree.getNode}}return U.pushUnique(composedMembers,r)&&(TickConstructor=TickConstructor||r),GridAxis.compose(e,t,r),BrokenAxis.compose(e,o),TreeGridTick.compose(r),e}constructor(e){this.axis=e}setCollapsedStatus(s){const e=this.axis,i=e.chart;e.series.forEach(function(e){var t=e.options.data;if(s.id&&t){const o=i.get(s.id),r=t[e.data.indexOf(o)];o&&r&&(o.collapsed=s.collapsed,r.collapsed=s.collapsed)}})}collapse(e){const t=this.axis,o=t.options.breaks||[],r=getBreakFromNode(e,t.max);return o.push(r),e.collapsed=!0,t.treeGrid.setCollapsedStatus(e),o}expand(e){const t=this.axis,o=t.options.breaks||[],r=getBreakFromNode(e,t.max);return e.collapsed=!1,t.treeGrid.setCollapsedStatus(e),o.reduce(function(e,t){return t.to===r.to&&t.from===r.from||e.push(t),e},[])}getTickPositions(){const o=this.axis,r=Math.floor(o.min/o.tickInterval)*o.tickInterval,s=Math.ceil(o.max/o.tickInterval)*o.tickInterval;return Object.keys(o.treeGrid.mapOfPosToGridNode||{}).reduce(function(e,t){t=+t;return!(t>=r&&t<=s)||o.brokenAxis&&o.brokenAxis.isInAnyBreak(t)||e.push(t),e},[])}isCollapsed(e){const t=this.axis,o=t.options.breaks||[],r=getBreakFromNode(e,t.max);return o.some(function(e){return e.from===r.from&&e.to===r.to})}toggleCollapse(e){return this.isCollapsed(e)?this.expand(e):this.collapse(e)}}export default TreeGridAxisAdditions;