"use strict";import Axis3DDefaults from"./Axis3DDefaults.js";import H from"../Globals.js";const deg2rad=H["deg2rad"];import Math3D from"../Math3D.js";const{perspective,perspective3D,shapeArea}=Math3D;import Tick3D from"./Tick3DComposition.js";import U from"../Utilities.js";const{addEvent,merge,pick,wrap}=U,composedMembers=[];function onAxisAfterSetOptions(){const t=this,i=t.chart,s=t.options;i.is3d&&i.is3d()&&"colorAxis"!==t.coll&&(s.tickWidth=pick(s.tickWidth,0),s.gridLineWidth=pick(s.gridLineWidth,1))}function onAxisDrawCrosshair(t){var i=this;i.chart.is3d()&&"colorAxis"!==i.coll&&t.point&&(t.point.crosshairPos=i.isXAxis?t.point.axisXpos:i.len-t.point.axisYpos)}function onAxisInit(){var t=this;t.axis3D||(t.axis3D=new Axis3DAdditions(t))}function wrapAxisGetLinePath(t){var i=this;return i.chart.is3d()&&"colorAxis"!==i.coll?[]:t.apply(i,[].slice.call(arguments,1))}function wrapAxisGetPlotBandPath(t){if(!this.chart.is3d()||"colorAxis"===this.coll)return t.apply(this,[].slice.call(arguments,1));const i=arguments,s=i[1],e=i[2],o=[],a=this.getPlotLinePath({value:s}),r=this.getPlotLinePath({value:e});if(a&&r)for(let t=0;t<a.length;t+=2){var x=a[t],l=a[t+1],p=r[t],n=r[t+1];"M"===x[0]&&"L"===l[0]&&"M"===p[0]&&"L"===n[0]&&o.push(x,l,n,["L",p[1],p[2]],["Z"])}return o}function wrapAxisGetPlotLinePath(t){const i=this,s=i.axis3D,e=i.chart,o=t.apply(i,[].slice.call(arguments,1));if("colorAxis"===i.coll||!e.chart3d||!e.is3d())return o;if(null===o)return o;var t=e.options.chart.options3d,t=i.isZAxis?e.plotWidth:t.depth,a=e.chart3d.frame3d,r=o[0],x=o[1];let l,p=[];return"M"===r[0]&&"L"===x[0]&&(l=[s.swapZ({x:r[1],y:r[2],z:0}),s.swapZ({x:r[1],y:r[2],z:t}),s.swapZ({x:x[1],y:x[2],z:0}),s.swapZ({x:x[1],y:x[2],z:t})],this.horiz?(this.isZAxis?(a.left.visible&&p.push(l[0],l[2]),a.right.visible&&p.push(l[1],l[3])):(a.front.visible&&p.push(l[0],l[2]),a.back.visible&&p.push(l[1],l[3])),a.top.visible&&p.push(l[0],l[1]),a.bottom.visible&&p.push(l[2],l[3])):(a.front.visible&&p.push(l[0],l[2]),a.back.visible&&p.push(l[1],l[3]),a.left.visible&&p.push(l[0],l[1]),a.right.visible&&p.push(l[2],l[3])),p=perspective(p,this.chart,!1)),e.renderer.toLineSegments(p)}function wrapAxisGetSlotWidth(t,e){const i=this,o=i.chart,a=i.ticks,r=i.gridGroup;if(i.categories&&o.frameShapes&&o.is3d()&&r&&e&&e.label){var x=r.element.childNodes[0].getBBox(),l=o.frameShapes.left.getBBox(),p=o.options.chart.options3d,p={x:o.plotWidth/2,y:o.plotHeight/2,z:p.depth/2,vd:pick(p.depth,1)*pick(p.viewDistance,0)},n=e.pos,h=a[n-1],c=a[n+1];let t,i,s;return 0!==n&&h&&h.label&&h.label.xy&&(i=perspective3D({x:h.label.xy.x,y:h.label.xy.y,z:null},p,p.vd)),c&&c.label&&c.label.xy&&(s=perspective3D({x:c.label.xy.x,y:c.label.xy.y,z:null},p,p.vd)),t={x:e.label.xy.x,y:e.label.xy.y,z:null},t=perspective3D(t,p,p.vd),Math.abs(i?t.x-i.x:s?s.x-t.x:x.x-l.x)}return t.apply(i,[].slice.call(arguments,1))}function wrapAxisGetTitlePosition(t){t=t.apply(this,[].slice.call(arguments,1));return this.axis3D?this.axis3D.fix3dPosition(t,!0):t}class Axis3DAdditions{static compose(t,i){Tick3D.compose(i),U.pushUnique(composedMembers,t)&&(merge(!0,t.defaultOptions,Axis3DDefaults),t.keepProps.push("axis3D"),addEvent(t,"init",onAxisInit),addEvent(t,"afterSetOptions",onAxisAfterSetOptions),addEvent(t,"drawCrosshair",onAxisDrawCrosshair),i=t.prototype,wrap(i,"getLinePath",wrapAxisGetLinePath),wrap(i,"getPlotBandPath",wrapAxisGetPlotBandPath),wrap(i,"getPlotLinePath",wrapAxisGetPlotLinePath),wrap(i,"getSlotWidth",wrapAxisGetSlotWidth),wrap(i,"getTitlePosition",wrapAxisGetTitlePosition))}constructor(t){this.axis=t}fix3dPosition(t,i){const s=this.axis,e=s.chart;if("colorAxis"===s.coll||!e.chart3d||!e.is3d())return t;var o=deg2rad*e.options.chart.options3d.alpha,a=deg2rad*e.options.chart.options3d.beta,r=pick(i&&s.options.title.position3d,s.options.labels.position3d),i=pick(i&&s.options.title.skew3d,s.options.labels.skew3d),x=e.chart3d.frame3d,l=e.plotLeft,p=e.plotWidth+l,n=e.plotTop,h=e.plotHeight+n;let c=0,y=0,d,z={x:0,y:1,z:0},f=!1;if(t=s.axis3D.swapZ({x:t.x,y:t.y,z:0}),s.isZAxis)if(s.opposite){if(null===x.axes.z.top)return{};y=t.y-n,t.x=x.axes.z.top.x,t.y=x.axes.z.top.y,d=x.axes.z.top.xDir,f=!x.top.frontFacing}else{if(null===x.axes.z.bottom)return{};y=t.y-h,t.x=x.axes.z.bottom.x,t.y=x.axes.z.bottom.y,d=x.axes.z.bottom.xDir,f=!x.bottom.frontFacing}else if(s.horiz)if(s.opposite){if(null===x.axes.x.top)return{};y=t.y-n,t.y=x.axes.x.top.y,t.z=x.axes.x.top.z,d=x.axes.x.top.xDir,f=!x.top.frontFacing}else{if(null===x.axes.x.bottom)return{};y=t.y-h,t.y=x.axes.x.bottom.y,t.z=x.axes.x.bottom.z,d=x.axes.x.bottom.xDir,f=!x.bottom.frontFacing}else if(s.opposite){if(null===x.axes.y.right)return{};c=t.x-p,t.x=x.axes.y.right.x,t.z=x.axes.y.right.z,d={x:(d=x.axes.y.right.xDir).z,y:d.y,z:-d.x}}else{if(null===x.axes.y.left)return{};c=t.x-l,t.x=x.axes.y.left.x,t.z=x.axes.y.left.z,d=x.axes.y.left.xDir}if("chart"!==r)if("flap"===r)if(s.horiz){let t=Math.sin(o);n=Math.cos(o);s.opposite&&(t=-t),f&&(t=-t),z={x:d.z*t,y:n,z:-d.x*t}}else d={x:Math.cos(a),y:0,z:Math.sin(a)};else if("ortho"===r)if(s.horiz){h=Math.sin(o),p=Math.cos(o);const m=Math.sin(a)*p,b=-h,A=-p*Math.cos(a);z={x:d.y*A-d.z*b,y:d.z*m-d.x*A,z:d.x*b-d.y*m};let t=1/Math.sqrt(z.x*z.x+z.y*z.y+z.z*z.z);f&&(t=-t),z={x:t*z.x,y:t*z.y,z:t*z.z}}else d={x:Math.cos(a),y:0,z:Math.sin(a)};else s.horiz?z={x:Math.sin(a)*Math.sin(o),y:Math.cos(o),z:-Math.cos(a)*Math.sin(o)}:d={x:Math.cos(a),y:0,z:Math.sin(a)};t.x+=c*d.x+y*z.x,t.y+=c*d.y+y*z.y,t.z+=c*d.z+y*z.z;const u=perspective([t],s.chart)[0];return i&&(shapeArea(perspective([t,{x:t.x+d.x,y:t.y+d.y,z:t.z+d.z},{x:t.x+z.x,y:t.y+z.y,z:t.z+z.z}],s.chart))<0&&(d={x:-d.x,y:-d.y,z:-d.z}),l=perspective([{x:t.x,y:t.y,z:t.z},{x:t.x+d.x,y:t.y+d.y,z:t.z+d.z},{x:t.x+z.x,y:t.y+z.y,z:t.z+z.z}],s.chart),u.matrix=[l[1].x-l[0].x,l[1].y-l[0].y,l[2].x-l[0].x,l[2].y-l[0].y,u.x,u.y],u.matrix[4]-=u.x*u.matrix[0]+u.y*u.matrix[2],u.matrix[5]-=u.x*u.matrix[1]+u.y*u.matrix[3]),u}swapZ(t,i){var s=this.axis;return s.isZAxis?{x:(i=i?0:s.chart.plotLeft)+t.z,y:t.y,z:t.x-i}:t}}export default Axis3DAdditions;