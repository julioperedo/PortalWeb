"use strict";import StackItem from"./Stacking/StackItem.js";import U from"../Utilities.js";const{addEvent,find,fireEvent,isArray,isNumber,pick}=U;var BrokenAxis;!function(i){const s=[];function n(){void 0!==this.brokenAxis&&this.brokenAxis.setBreaks(this.options.breaks,!1)}function r(){this.brokenAxis?.hasBreaks&&(this.options.ordinal=!1)}function o(){const i=this,t=i.brokenAxis;if(t?.hasBreaks){const e=i.tickPositions,s=i.tickPositions.info,n=[];for(let i=0;i<e.length;i++)t.isInAnyBreak(e[i])||n.push(e[i]);i.tickPositions=n,i.tickPositions.info=s}}function a(){var i=this;i.brokenAxis||(i.brokenAxis=new h(i))}function f(){const{isDirty:i,options:{connectNulls:t},points:e,xAxis:s,yAxis:n}=this;if(i){let i=e.length;for(;i--;){const o=e[i];var r=!(null===o.y&&!1===t)&&(s?.brokenAxis?.isInAnyBreak(o.x,!0)||n?.brokenAxis?.isInAnyBreak(o.y,!0));o.visible=!r&&!1!==o.options.visible}}}function c(){this.drawBreaks(this.xAxis,["x"]),this.drawBreaks(this.yAxis,pick(this.pointArrayMap,["y"]))}function k(s,i){const e=this,n=e.points;let r,o,a;if(s?.brokenAxis?.hasBreaks){const f=s.brokenAxis;i.forEach(function(i){r=f?.breakArray||[],o=s.isXAxis?s.min:pick(e.options.threshold,s.min);const t=s?.options?.breaks?.filter(function(t){let e=!0;for(let i=0;i<r.length;i++){var s=r[i];if(s.from===t.from&&s.to===t.to){e=!1;break}}return e});n.forEach(function(e){a=pick(e["stack"+i.toUpperCase()],e[i]),r.forEach(function(t){if(isNumber(o)&&isNumber(a)){let i="";o<t.from&&a>t.to||o>t.from&&a<t.from?i="pointBreak":(o<t.from&&a>t.from&&a<t.to||o>t.from&&a>t.to&&a<t.from)&&(i="pointInBreak"),i&&fireEvent(s,i,{point:e,brk:t})}}),t?.forEach(function(i){fireEvent(s,"pointOutsideOfBreak",{point:e,brk:i})})})})}}function u(){const i=this.currentDataGrouping,e=i?.gapSize,s=this.points.slice(),n=this.yAxis;let r=this.options.gapSize,o=s.length-1,a;if(r&&0<o){"value"!==this.options.gapUnit&&(r*=this.basePointRange),e&&e>r&&e>=this.basePointRange&&(r=e);let i,t;for(;o--;){var f;t&&!1!==t.visible||(t=s[o+1]),i=s[o],!1!==t.visible&&!1!==i.visible&&(t.x-i.x>r&&(f=(i.x+t.x)/2,s.splice(o+1,0,{isNull:!0,x:f}),n.stacking&&this.options.stacking&&((a=n.stacking.stacks[this.stackKey][f]=new StackItem(n,n.options.stackLabels,!1,f,this.stack)).total=0)),t=i)}}return this.getGraphPath(s)}i.compose=function(i,t){if(U.pushUnique(s,i)&&(i.keepProps.push("brokenAxis"),addEvent(i,"init",a),addEvent(i,"afterInit",n),addEvent(i,"afterSetTickPositions",o),addEvent(i,"afterSetOptions",r)),U.pushUnique(s,t)){const e=t.prototype;e.drawBreaks=k,e.gappedPath=u,addEvent(t,"afterGeneratePoints",f),addEvent(t,"afterRender",c)}return i};class h{static isInBreak(i,t){var e=i.repeat||1/0,s=i.from,n=i.to-i.from,s=s<=t?(t-s)%e:e-(s-t)%e;let r;return r=i.inclusive?s<=n:s<n&&0!=s}static lin2Val(i){var t=this.brokenAxis,e=t&&t.breakArray;if(!e||!isNumber(i))return i;let s=i,n,r;for(r=0;r<e.length&&!((n=e[r]).from>=s);r++)(n.to<s||h.isInBreak(n,s))&&(s+=n.len);return s}static val2Lin(i){var t=this.brokenAxis,e=t&&t.breakArray;if(!e||!isNumber(i))return i;let s=i,n,r;for(r=0;r<e.length;r++)if((n=e[r]).to<=i)s-=n.len;else{if(n.from>=i)break;if(h.isInBreak(n,i)){s-=i-n.from;break}}return s}constructor(i){this.hasBreaks=!1,this.axis=i}findBreakAt(t,i){return find(i,function(i){return i.from<t&&t<i.to})}isInAnyBreak(i,t){var e=this.axis,s=e.options.breaks||[];let n=s.length,r,o,a;if(n&&isNumber(i)){for(;n--;)h.isInBreak(s[n],i)&&(r=!0,o=o||pick(s[n].showPoints,!e.isXAxis));a=r&&t?r&&!o:r}return a}setBreaks(i,t){const u=this,l=u.axis;var e=isArray(i)&&!!i.length&&!!Object.keys(i[0]).length;l.isDirty=u.hasBreaks!==e,u.hasBreaks=e,i!==l.options.breaks&&(l.options.breaks=l.userOptions.breaks=i),l.forceRedraw=!0,l.series.forEach(function(i){i.isDirty=!0}),e||l.val2lin!==h.val2Lin||(delete l.val2lin,delete l.lin2val),e&&(l.userOptions.ordinal=!1,l.lin2val=h.lin2Val,l.val2lin=h.val2Lin,l.setExtremes=function(t,e,i,s,n){if(u.hasBreaks){var r=this.options.breaks||[];let i;for(;i=u.findBreakAt(t,r);)t=i.to;for(;i=u.findBreakAt(e,r);)e=i.from;e<t&&(e=t)}l.constructor.prototype.setExtremes.call(this,t,e,i,s,n)},l.setAxisTranslation=function(){if(l.constructor.prototype.setAxisTranslation.call(this),u.unitLength=void 0,u.hasBreaks){const i=l.options.breaks||[],f=[],c=[],k=pick(l.pointRangePadding,0);let t=0,e,s,n=l.userMin||l.min,r=l.userMax||l.max,o,a;i.forEach(function(i){s=i.repeat||1/0,isNumber(n)&&isNumber(r)&&(h.isInBreak(i,n)&&(n+=i.to%s-n%s),h.isInBreak(i,r)&&(r-=r%s-i.from%s))}),i.forEach(function(i){if(o=i.from,s=i.repeat||1/0,isNumber(n)&&isNumber(r)){for(;o-s>n;)o-=s;for(;o<n;)o+=s;for(a=o;a<r;a+=s)f.push({value:a,move:"in"}),f.push({value:a+i.to-i.from,move:"out",size:i.breakSize})}}),f.sort(function(i,t){return i.value===t.value?("in"===i.move?0:1)-("in"===t.move?0:1):i.value-t.value}),e=0,o=n,f.forEach(function(i){1===(e+="in"===i.move?1:-1)&&"in"===i.move&&(o=i.value),0===e&&isNumber(o)&&(c.push({from:o,to:i.value,len:i.value-o-(i.size||0)}),t+=i.value-o-(i.size||0))}),u.breakArray=c,isNumber(n)&&isNumber(r)&&isNumber(l.min)&&(u.unitLength=r-n-t+k,fireEvent(l,"afterBreaks"),l.staticScale?l.transA=l.staticScale:u.unitLength&&(l.transA*=(r-l.min+k)/u.unitLength),k&&(l.minPixelPadding=l.transA*(l.minPointOffset||0)),l.min=n,l.max=r)}}),pick(t,!0)&&l.chart.redraw()}}i.Additions=h}(BrokenAxis=BrokenAxis||{});export default BrokenAxis;