"use strict";import A from"../Animation/AnimationUtilities.js";const{animObject,setAnimation}=A;import D from"../Defaults.js";const defaultOptions=D["defaultOptions"];import F from"../Foundation.js";const registerEventOptions=F["registerEventOptions"];import H from"../Globals.js";const{hasTouch,svg,win}=H;import LegendSymbol from"../Legend/LegendSymbol.js";import Point from"./Point.js";import SeriesDefaults from"./SeriesDefaults.js";import SeriesRegistry from"./SeriesRegistry.js";const seriesTypes=SeriesRegistry["seriesTypes"];import SVGElement from"../Renderer/SVG/SVGElement.js";import U from"../Utilities.js";const{addEvent,arrayMax,arrayMin,clamp,correctFloat,defined,diffObjects,erase,error,extend,find,fireEvent,getClosestDistance,getNestedProperty,insertItem,isArray,isNumber,isString,merge,objectEach,pick,removeEvent,splat,syncTimeout}=U;class Series{constructor(){this._i=void 0,this.chart=void 0,this.data=void 0,this.eventOptions=void 0,this.eventsToUnbind=void 0,this.index=void 0,this.linkedSeries=void 0,this.options=void 0,this.points=void 0,this.processedXData=void 0,this.processedYData=void 0,this.tooltipOptions=void 0,this.userOptions=void 0,this.xAxis=void 0,this.yAxis=void 0,this.zones=void 0}init(t,e){fireEvent(this,"init",{options:e});const i=this,s=t.series;this.eventsToUnbind=[],i.chart=t,i.options=i.setOptions(e);var e=i.options,r=!1!==e.visible,r=(i.linkedSeries=[],i.bindAxes(),extend(i,{name:e.name,state:"",visible:r,selected:!0===e.selected}),registerEventOptions(this,e),e.events);(r&&r.click||e.point&&e.point.events&&e.point.events.click||e.allowPointSelect)&&(t.runTrackerClick=!0),i.getColor(),i.getSymbol(),i.parallelArrays.forEach(function(t){i[t+"Data"]||(i[t+"Data"]=[])}),i.isCartesian&&(t.hasCartesianSeries=!0);let o;s.length&&(o=s[s.length-1]),i._i=pick(o&&o._i,-1)+1,i.opacity=i.options.opacity,t.orderItems("series",insertItem(this,s)),e.dataSorting&&e.dataSorting.enabled?i.setDataSortingOptions():i.points||i.data||i.setData(e.data,!1),fireEvent(this,"afterInit")}is(t){return seriesTypes[t]&&this instanceof seriesTypes[t]}bindAxes(){const i=this,s=i.options,t=i.chart;let r;fireEvent(this,"bindAxes",null,function(){(i.axisTypes||[]).forEach(function(e){t[e].forEach(function(t){r=t.options,(pick(s[e],0)===t.index||void 0!==s[e]&&s[e]===r.id)&&(insertItem(i,t.series),(i[e]=t).isDirty=!0)}),i[e]||i.optionalAxis===e||error(18,!0,t)})}),fireEvent(this,"afterBindAxes")}updateParallelArrays(i,s,e){const r=i.series,t=isNumber(s)?function(t){var e="y"===t&&r.toYData?r.toYData(i):i[t];r[t+"Data"][s]=e}:function(t){Array.prototype[s].apply(r[t+"Data"],e)};r.parallelArrays.forEach(t)}hasData(){return this.visible&&void 0!==this.dataMax&&void 0!==this.dataMin||this.visible&&this.yData&&0<this.yData.length}hasMarkerChanged(t,e){t=t.marker,e=e.marker||{};return t&&(e.enabled&&!t.enabled||e.symbol!==t.symbol||e.height!==t.height||e.width!==t.width)}autoIncrement(t){const e=this.options,i=e.pointIntervalUnit,s=e.relativeXValue,r=this.chart.time;let o=this.xIncrement,a,n;return o=pick(o,e.pointStart,0),this.pointInterval=n=pick(this.pointInterval,e.pointInterval,1),s&&isNumber(t)&&(n*=t),i&&(a=new r.Date(o),"day"===i?r.set("Date",a,r.get("Date",a)+n):"month"===i?r.set("Month",a,r.get("Month",a)+n):"year"===i&&r.set("FullYear",a,r.get("FullYear",a)+n),n=a.getTime()-o),s&&isNumber(t)?o+n:(this.xIncrement=o+n,o)}setDataSortingOptions(){const t=this.options;extend(this,{requireSorting:!1,sorted:!1,enabledDataSorting:!0,allowDG:!1}),defined(t.pointRange)||(t.pointRange=1)}setOptions(t){var e=this.chart,i=e.options.plotOptions,s=e.userOptions||{},t=merge(t),r=e.styledMode,o={plotOptions:i,userOptions:t};let a;fireEvent(this,"setOptions",o);var n=o.plotOptions[this.type],s=s.plotOptions||{},l=s.series||{},h=defaultOptions.plotOptions[this.type]||{},d=s[this.type]||{};this.userOptions=o.userOptions;const p=merge(n,i.series,d,t),c=(this.tooltipOptions=merge(defaultOptions.tooltip,defaultOptions.plotOptions.series?.tooltip,h?.tooltip,e.userOptions.tooltip,s.series?.tooltip,d.tooltip,t.tooltip),this.stickyTracking=pick(t.stickyTracking,d.stickyTracking,l.stickyTracking,!(!this.tooltipOptions.shared||this.noSharedTooltip)||p.stickyTracking),null===n.marker&&delete p.marker,this.zoneAxis=p.zoneAxis,this.zones=(p.zones||[]).slice());return!p.negativeColor&&!p.negativeFillColor||p.zones||(a={value:p[this.zoneAxis+"Threshold"]||p.threshold||0,className:"highcharts-negative"},r||(a.color=p.negativeColor,a.fillColor=p.negativeFillColor),c.push(a)),c.length&&defined(c[c.length-1].value)&&c.push(r?{}:{color:this.color,fillColor:this.fillColor}),fireEvent(this,"afterSetOptions",{options:p}),p}getName(){return pick(this.options.name,"Series "+(this.index+1))}getCyclic(t,e,i){const s=this.chart,r=t+"Index",o=t+"Counter",a=i?.length||s.options.chart.colorCount;let n,l;e||(l=pick("color"===t?this.options.colorIndex:void 0,this[r]),defined(l)?n=l:(s.series.length||(s[o]=0),n=s[o]%a,s[o]+=1),i&&(e=i[n])),void 0!==n&&(this[r]=n),this[t]=e}getColor(){this.chart.styledMode?this.getCyclic("color"):this.options.colorByPoint?this.color="#cccccc":this.getCyclic("color",this.options.color||defaultOptions.plotOptions[this.type].color,this.chart.options.colors)}getPointsCollection(){return(this.hasGroupedData?this.points:this.data)||[]}getSymbol(){var t=this.options.marker;this.getCyclic("symbol",t.symbol,this.chart.options.symbols)}findPointIndex(e,t){var i=e.id,s=e.x,r=this.points,o=this.options.dataSorting;let a,n,l;if(i){i=this.chart.get(i);i instanceof Point&&(a=i)}else if(this.linkedParent||this.enabledDataSorting||this.options.relativeXValue){let t=t=>!t.touched&&t.index===e.index;if(o&&o.matchByName?t=t=>!t.touched&&t.name===e.name:this.options.relativeXValue&&(t=t=>!t.touched&&t.options.x===e.x),!(a=find(r,t)))return}return a&&void 0!==(l=a&&a.index)&&(n=!0),-1!==(l=void 0===l&&isNumber(s)?this.xData.indexOf(s,t):l)&&void 0!==l&&this.cropped&&(l=l>=this.cropStart?l-this.cropStart:l),l=!n&&isNumber(l)&&r[l]&&r[l].touched?void 0:l}updateData(t,e){const r=this.options,o=r.dataSorting,a=this.points,n=[],l=this.requireSorting,h=t.length===a.length;let d,i,s,p,c=!0;if(this.xIncrement=null,t.forEach(function(t,e){var i=defined(t)&&this.pointClass.prototype.optionsToObject.call({series:this},t)||{},s=i.x;i.id||isNumber(s)?(-1===(s=this.findPointIndex(i,p))||void 0===s?n.push(t):a[s]&&t!==r.data[s]?(a[s].update(t,!1,null,!1),a[s].touched=!0,l&&(p=s+1)):a[s]&&(a[s].touched=!0),(!h||e!==s||o&&o.enabled||this.hasDerivedData)&&(d=!0)):n.push(t)},this),d)for(i=a.length;i--;)(s=a[i])&&!s.touched&&s.remove&&s.remove(!1,e);else!h||o&&o.enabled?c=!1:(t.forEach(function(t,e){t===a[e].y||a[e].destroyed||a[e].update(t,!1,null,!1)}),n.length=0);return a.forEach(function(t){t&&(t.touched=!1)}),!!c&&(n.forEach(function(t){this.addPoint(t,!1,null,null,!1)},this),null===this.xIncrement&&this.xData&&this.xData.length&&(this.xIncrement=arrayMax(this.xData),this.autoIncrement()),!0)}setData(t,e=!0,i,s){const r=this,o=r.points,a=o&&o.length||0,n=r.options,l=r.chart,h=n.dataSorting,d=r.xAxis,p=n.turboThreshold,c=this.xData,u=this.yData,g=r.pointArrayMap,m=g&&g.length,f=n.keys;let y,v,x,b=0,k=1,D,S;l.options.chart.allowMutatingData||(n.data&&delete r.options.data,r.userOptions.data&&delete r.userOptions.data,S=merge(!0,t));var A=(t=S||t||[]).length;if(h&&h.enabled&&(t=this.sortData(t)),!(x=l.options.chart.allowMutatingData&&!1!==s&&A&&a&&!r.cropped&&!r.hasGroupedData&&r.visible&&!r.boosted?this.updateData(t,i):x)){if(r.xIncrement=null,r.colorCounter=0,this.parallelArrays.forEach(function(t){r[t+"Data"].length=0}),p&&p<A)if(D=r.getFirstValidPoint(t),isNumber(D))for(y=0;y<A;y++)c[y]=this.autoIncrement(),u[y]=t[y];else if(isArray(D))if(m)if(D.length===m)for(y=0;y<A;y++)c[y]=this.autoIncrement(),u[y]=t[y];else for(y=0;y<A;y++)v=t[y],c[y]=v[0],u[y]=v.slice(1,m+1);else if(f&&(b=f.indexOf("x"),k=f.indexOf("y"),b=0<=b?b:0,k=0<=k?k:1),1===D.length&&(k=0),b===k)for(y=0;y<A;y++)c[y]=this.autoIncrement(),u[y]=t[y][k];else for(y=0;y<A;y++)v=t[y],c[y]=v[b],u[y]=v[k];else error(12,!1,l);else for(y=0;y<A;y++)v={series:r},r.pointClass.prototype.applyOptions.apply(v,[t[y]]),r.updateParallelArrays(v,y);for(u&&isString(u[0])&&error(14,!0,l),r.data=[],r.options.data=r.userOptions.data=t,y=a;y--;)o[y]?.destroy();d&&(d.minRange=d.userMinRange),r.isDirty=l.isDirtyBox=!0,r.isDirtyData=!!o,i=!1}"point"===n.legendType&&(this.processData(),this.generatePoints()),e&&l.redraw(i)}sortData(r){function o(t,e){return defined(e)&&t.pointClass.prototype.optionsToObject.call({series:t},e)||{}}const i=this,t=i.options,e=t.dataSorting,s=e.sortKey||"y",a=(r.forEach(function(t,e){r[e]=o(i,t),r[e].index=e},this),r.concat().sort((t,e)=>{t=getNestedProperty(s,t),e=getNestedProperty(s,e);return e<t?-1:t<e?1:0}));return a.forEach(function(t,e){t.x=e},this),i.linkedSeries&&i.linkedSeries.forEach(function(i){const t=i.options,s=t.data;t.dataSorting&&t.dataSorting.enabled||!s||(s.forEach(function(t,e){s[e]=o(i,t),r[e]&&(s[e].x=r[e].x,s[e].index=e)}),i.setData(s,!1))}),r}getProcessedData(t){const e=this,i=e.xAxis,s=e.options,r=s.cropThreshold,o=t||e.getExtremesFromAll||s.getExtremesFromAll,a=i?.logarithmic,n=e.isCartesian;let l,h,d=0,p,c,u,g=e.xData,m=e.yData,f=!1;t=g.length,i&&(p=i.getExtremes(),c=p.min,u=p.max,f=!(!i.categories||i.names.length)),n&&e.sorted&&!o&&(!r||r<t||e.forceCrop)&&(g[t-1]<c||g[0]>u?(g=[],m=[]):e.yData&&(g[0]<c||g[t-1]>u)&&(l=this.cropData(e.xData,e.yData,c,u),g=l.xData,m=l.yData,d=l.start,h=!0)),t=getClosestDistance([a?g.map(a.log2lin):g],()=>e.requireSorting&&!f&&error(15,!1,e.chart));return{xData:g,yData:m,cropped:h,cropStart:d,closestPointRange:t}}processData(t){var e=this,i=e.xAxis;if(e.isCartesian&&!e.isDirty&&!i.isDirty&&!e.yAxis.isDirty&&!t)return!1;i=e.getProcessedData();e.cropped=i.cropped,e.cropStart=i.cropStart,e.processedXData=i.xData,e.processedYData=i.yData,e.closestPointRange=e.basePointRange=i.closestPointRange,fireEvent(e,"afterProcessData")}cropData(t,e,i,s){var r=t.length;let o,a,n=0,l=r;for(o=0;o<r;o++)if(t[o]>=i){n=Math.max(0,o-1);break}for(a=o;a<r;a++)if(t[a]>s){l=a+1;break}return{xData:t.slice(n,l),yData:e.slice(n,l),start:n,end:l}}generatePoints(){const t=this,e=t.options,i=t.processedData||e.data,s=t.processedXData,r=t.processedYData,o=t.pointClass,a=s.length,n=t.cropStart||0,l=t.hasGroupedData,h=e.keys,d=[],p=e.dataGrouping&&e.dataGrouping.groupAll?n:0;let c,u,g,m,f=t.data;if(!f&&!l){const y=[];y.length=i.length,f=t.data=y}for(h&&l&&(t.options.keys=!1),m=0;m<a;m++)u=n+m,l?((g=(new o).init(t,[s[m]].concat(splat(r[m])))).dataGroup=t.groupMap[p+m],g.dataGroup.options&&(g.options=g.dataGroup.options,extend(g,g.dataGroup.options),delete g.dataLabels)):(g=f[u])||void 0===i[u]||(f[u]=g=(new o).init(t,i[u],s[m])),g&&(g.index=l?p+m:u,d[m]=g);if(t.options.keys=h,f&&(a!==(c=f.length)||l))for(m=0;m<c;m++)m!==n||l||(m+=a),f[m]&&(f[m].destroyElements(),f[m].plotX=void 0);t.data=f,t.points=d,fireEvent(this,"afterGeneratePoints")}getXExtremes(t){return{min:arrayMin(t),max:arrayMax(t)}}getExtremes(t,e){const i=this.xAxis,s=this.yAxis,r=this.processedXData||this.xData,o=[],a=this.requireSorting&&!this.is("column")?1:0,n=!!s&&s.positiveValuesOnly;let l,h,d,p,c,u,g,m=0,f=0,y=0;var v=(t=t||this.stackedYData||this.processedYData||[]).length;for(i&&(l=i.getExtremes(),m=l.min,f=l.max),u=0;u<v;u++)if(p=r[u],c=t[u],h=(isNumber(c)||isArray(c))&&((isNumber(c)?0<c:c.length)||!n),d=e||this.getExtremesFromAll||this.options.getExtremesFromAll||this.cropped||!i||(r[u+a]||p)>=m&&(r[u-a]||p)<=f,h&&d)if(g=c.length)for(;g--;)isNumber(c[g])&&(o[y++]=c[g]);else o[y++]=c;var x={activeYData:o,dataMin:arrayMin(o),dataMax:arrayMax(o)};return fireEvent(this,"afterGetExtremes",{dataExtremes:x}),x}applyExtremes(){var t=this.getExtremes();return this.dataMin=t.dataMin,this.dataMax=t.dataMax,t}getFirstValidPoint(t){var e=t.length;let i=0,s=null;for(;null===s&&i<e;)s=t[i],i++;return s}translate(){this.processedXData||this.processData(),this.generatePoints();const o=this,t=o.options,a=t.stacking,n=o.xAxis,l=n.categories,h=o.enabledDataSorting,d=o.yAxis,p=o.points,e=p.length,c=o.pointPlacementToXValue(),u=Boolean(c),g=t.threshold,m=t.startFromThreshold?g:0;let f,y,v,x,b=Number.MAX_VALUE;function k(t){return clamp(t,-1e5,1e5)}for(f=0;f<e;f++){const S=p[f],A=S.x;let t,e,i=S.y,s=S.low;var D=a&&d.stacking?.stacks[(o.negStacks&&i<(m?0:g)?"-":"")+o.stackKey];y=n.translate(A,!1,!1,!1,!0,c),S.plotX=isNumber(y)?correctFloat(k(y)):void 0,a&&o.visible&&D&&D[A]&&(x=o.getStackIndicator(x,A,o.index),!S.isNull&&x.key&&(t=D[A],e=t.points[x.key]),t&&isArray(e)&&(s=e[0],i=e[1],s===m&&x.key===D[A].base&&(s=pick(isNumber(g)?g:d.min)),d.positiveValuesOnly&&defined(s)&&s<=0&&(s=void 0),S.total=S.stackTotal=pick(t.total),S.percentage=defined(S.y)&&t.total?S.y/t.total*100:void 0,S.stackY=i,o.irregularWidths||t.setOffset(o.pointXOffset||0,o.barW||0,void 0,void 0,void 0,o.xAxis))),S.yBottom=defined(s)?k(d.translate(s,!1,!0,!1,!0)):void 0,o.dataModify&&(i=o.dataModify.modifyValue(i,f));let r;isNumber(i)&&void 0!==S.plotX&&(r=d.translate(i,!1,!0,!1,!0),r=isNumber(r)?k(r):void 0),S.plotY=r,S.isInside=this.isPointInside(S),S.clientX=u?correctFloat(n.translate(A,!1,!1,!1,!0,c)):y,S.negative=(S.y||0)<(g||0),S.category=pick(l&&l[S.x],S.x),S.isNull||!1===S.visible||(void 0!==v&&(b=Math.min(b,Math.abs(y-v))),v=y),S.zone=this.zones.length?S.getZone():void 0,!S.graphic&&o.group&&h&&(S.isNew=!0)}o.closestPointRangePx=b,fireEvent(this,"afterTranslate")}getValidPoints(t,s,r){const o=this.chart;return(t||this.points||[]).filter(function(t){var{plotX:e,plotY:i}=t;return!(!(r||!t.isNull&&isNumber(i))||s&&!o.isInsidePlot(e,i,{inverted:o.inverted}))&&!1!==t.visible})}getClipBox(){var{chart:t,xAxis:e,yAxis:i}=this;const s=merge(t.clipBox);return e&&e.len!==t.plotSizeX&&(s.width=e.len),i&&i.len!==t.plotSizeY&&(s.height=i.len),s}getSharedClipKey(){return this.sharedClipKey=(this.options.xAxis||0)+","+(this.options.yAxis||0),this.sharedClipKey}setClip(){const{chart:t,group:e,markerGroup:i}=this,s=t.sharedClips,r=t.renderer,o=this.getClipBox(),a=this.getSharedClipKey();let n=s[a];n?n.animate(o):s[a]=n=r.clipRect(o),e&&e.clip(!1===this.options.clip?void 0:n),i&&i.clip()}animate(t){const{chart:e,group:i,markerGroup:s}=this,r=e.inverted,o=animObject(this.options.animation),a=[this.getSharedClipKey(),o.duration,o.easing,o.defer].join(",");let n=e.sharedClips[a],l=e.sharedClips[a+"m"];if(t&&i){const h=this.getClipBox();n?n.attr("height",h.height):(h.width=0,r&&(h.x=e.plotHeight),n=e.renderer.clipRect(h),e.sharedClips[a]=n,t={x:(r,-99),y:(r,-99),width:r?e.plotWidth+199:99,height:r?99:e.plotHeight+199},l=e.renderer.clipRect(t),e.sharedClips[a+"m"]=l),i.clip(n),s&&s.clip(l)}else if(n&&!n.hasClass("highcharts-animating")){const d=this.getClipBox(),p=o.step;s&&s.element.childNodes.length&&(o.step=function(t,e){p&&p.apply(e,arguments),"width"===e.prop&&l&&l.element&&l.attr(r?"height":"width",t+99)}),n.addClass("highcharts-animating").animate(d,o)}}afterAnimate(){this.setClip(),objectEach(this.chart.sharedClips,(t,e,i)=>{t&&!this.chart.container.querySelector(`[clip-path="url(#${t.id})"]`)&&(t.destroy(),delete i[e])}),this.finishedAnimating=!0,fireEvent(this,"afterAnimate")}drawPoints(t=this.points){const e=this,i=e.chart,s=i.styledMode,{colorAxis:r,options:o}=e,a=o.marker,n=e[e.specialGroup||"markerGroup"],l=e.xAxis,h=pick(a.enabled,!(l&&!l.isRadial)||null,e.closestPointRangePx>=a.enabledThreshold*a.radius);let d,p,c,u,g,m,f;if(!1!==a.enabled||e._hasPointMarkers)for(d=0;d<t.length;d++){var y,v;p=t[d],c=p.graphic,u=c?"animate":"attr",g=p.marker||{},m=!!p.marker,(h&&void 0===g.enabled||g.enabled)&&!p.isNull&&!1!==p.visible?(v=pick(g.symbol,e.symbol,"rect"),f=e.markerAttribs(p,p.selected&&"select"),e.enabledDataSorting&&(p.startXPos=l.reversed?-(f.width||0):l.width),y=!1!==p.isInside,!c&&y&&(0<(f.width||0)||p.hasImage)&&(p.graphic=c=i.renderer.symbol(v,f.x,f.y,f.width,f.height,m?g:a).add(n),e.enabledDataSorting&&i.hasRendered&&(c.attr({x:p.startXPos}),u="animate")),c&&"animate"===u&&c[y?"show":"hide"](y).animate(f),c&&(v=e.pointAttribs(p,s||!p.selected?void 0:"select"),s?r&&c.css({fill:v.fill}):c[u](v)),c&&c.addClass(p.getClassName(),!0)):c&&(p.graphic=c.destroy())}}markerAttribs(t,e){const i=this.options,s=i.marker,r=t.marker||{},o=r.symbol||s.symbol,a={};let n,l,h=pick(r.radius,s&&s.radius);e&&(n=s.states[e],l=r.states&&r.states[e],h=pick(l&&l.radius,n&&n.radius,h&&h+(n&&n.radiusPlus||0))),t.hasImage=o&&0===o.indexOf("url"),t.hasImage&&(h=0);e=t.pos();return isNumber(h)&&e&&(a.x=e[0]-h,a.y=e[1]-h,i.crisp&&(a.x=Math.floor(a.x))),h&&(a.width=a.height=2*h),a}pointAttribs(t,e){var i=this.options.marker,s=t&&t.options,r=s&&s.marker||{},s=s&&s.color,o=t&&t.color,t=t&&t.zone&&t.zone.color;let a,n,l=this.color,h,d,p=pick(r.lineWidth,i.lineWidth),c=1;return l=s||t||o||l,h=r.fillColor||i.fillColor||l,d=r.lineColor||i.lineColor||l,(e=e||"normal")&&(a=i.states[e]||{},n=r.states&&r.states[e]||{},p=pick(n.lineWidth,a.lineWidth,p+pick(n.lineWidthPlus,a.lineWidthPlus,0)),h=n.fillColor||a.fillColor||h,d=n.lineColor||a.lineColor||d,c=pick(n.opacity,a.opacity,c)),{stroke:d,"stroke-width":p,fill:h,opacity:c}}destroy(i){const s=this,t=s.chart,r=/AppleWebKit\/533/.test(win.navigator.userAgent),e=s.data||[];let o,a,n,l;for(fireEvent(s,"destroy",{keepEventsForUpdate:i}),this.removeEvents(i),(s.axisTypes||[]).forEach(function(t){(l=s[t])&&l.series&&(erase(l.series,s),l.isDirty=l.forceRedraw=!0)}),s.legendItem&&s.chart.legend.destroyItem(s),a=e.length;a--;)(n=e[a])&&n.destroy&&n.destroy();s.clips&&s.clips.forEach(t=>t.destroy()),U.clearTimeout(s.animationTimeout),objectEach(s,function(t,e){t instanceof SVGElement&&!t.survive&&t[o=r&&"group"===e?"hide":"destroy"]()}),t.hoverSeries===s&&(t.hoverSeries=void 0),erase(t.series,s),t.orderItems("series"),objectEach(s,function(t,e){i&&"hcEvents"===e||delete s[e]})}applyZones(){const i=this,s=this.chart,r=s.renderer,t=this.zones,o=this.clips||[],a=this.graph,n=this.area,l=Math.max(s.plotWidth,s.plotHeight),h=this[(this.zoneAxis||"y")+"Axis"],d=s.inverted;let p,c,u,g,m,f,y,v,x,b,k,D=!1;t.length&&(a||n)&&h&&void 0!==h.min?(m=h.reversed,f=h.horiz,a&&!this.showLine&&a.hide(),n&&n.hide(),g=h.getExtremes(),t.forEach(function(t,e){p=m?f?s.plotWidth:0:!f&&h.toPixels(g.min)||0,p=clamp(pick(c,p),0,l),c=clamp(Math.round(h.toPixels(pick(t.value,g.max),!0)||0),0,l),D&&(p=c=h.toPixels(g.max)),y=Math.abs(p-c),v=Math.min(p,c),x=Math.max(p,c),h.isXAxis?(u={x:d?x:v,y:0,width:y,height:l},f||(u.x=s.plotHeight-u.x)):(u={x:0,y:d?x:v,width:l,height:y},f&&(u.y=s.plotWidth-u.y)),o[e]?o[e].animate(u):o[e]=r.clipRect(u),b=i["zone-area-"+e],k=i["zone-graph-"+e],a&&k&&k.clip(o[e]),n&&b&&b.clip(o[e]),D=t.value>g.max,i.resetZones&&0===c&&(c=void 0)}),this.clips=o):i.visible&&(a&&a.show(),n&&n.show())}plotGroup(t,e,i,s,r){let o=this[t];const a=!o,n={visibility:i,zIndex:s||.1};return void 0===this.opacity||this.chart.styledMode||"inactive"===this.state||(n.opacity=this.opacity),a&&(this[t]=o=this.chart.renderer.g().add(r)),o.addClass("highcharts-"+e+" highcharts-series-"+this.index+" highcharts-"+this.type+"-series "+(defined(this.colorIndex)?"highcharts-color-"+this.colorIndex+" ":"")+(this.options.className||"")+(o.hasClass("highcharts-tracker")?" highcharts-tracker":""),!0),o.attr(n)[a?"attr":"animate"](this.getPlotBox(e)),o}getPlotBox(t){let e=this.xAxis,i=this.yAxis;var s=this.chart,t=s.inverted&&!s.polar&&e&&!1!==this.invertible&&"series"===t;return s.inverted&&(e=i,i=this.xAxis),{translateX:e?e.left:s.plotLeft,translateY:i?i.top:s.plotTop,rotation:t?90:0,rotationOriginX:t?(e.len-i.len)/2:0,rotationOriginY:t?(e.len+i.len)/2:0,scaleX:t?-1:1,scaleY:1}}removeEvents(t){t||removeEvent(this),this.eventsToUnbind.length&&(this.eventsToUnbind.forEach(function(t){t()}),this.eventsToUnbind.length=0)}render(){const t=this,e=t.chart,i=t.options,s=animObject(i.animation),r=t.visible?"inherit":"hidden",o=i.zIndex,a=t.hasRendered,n=e.seriesGroup;e.inverted;let l=t.finishedAnimating?0:s.duration;fireEvent(this,"render");t.plotGroup("group","series",r,o,n);t.markerGroup=t.plotGroup("markerGroup","markers",r,o,n),!1!==i.clip&&t.setClip(),t.animate&&l&&t.animate(!0),t.drawGraph&&(t.drawGraph(),t.applyZones()),t.visible&&t.drawPoints(),t.drawDataLabels&&t.drawDataLabels(),t.redrawPoints&&t.redrawPoints(),t.drawTracker&&i.enableMouseTracking&&t.drawTracker(),t.animate&&l&&t.animate(),a||(l&&s.defer&&(l+=s.defer),t.animationTimeout=syncTimeout(function(){t.afterAnimate()},l||0)),t.isDirty=!1,t.hasRendered=!0,fireEvent(t,"afterRender")}redraw(){var t=this.isDirty||this.isDirtyData;this.translate(),this.render(),t&&delete this.kdTree}reserveSpace(){return this.visible||!this.chart.options.chart.ignoreHiddenSeries}searchPoint(t,e){var i=this.xAxis,s=this.yAxis,r=this.chart.inverted;return this.searchKDTree({clientX:r?i.len-t.chartY+i.pos:t.chartX-i.pos,plotY:r?s.len-t.chartX+s.pos:t.chartY-s.pos},e,t)}buildKDTree(t){this.buildingKdTree=!0;const n=this,e=-1<n.options.findNearestPointBy.indexOf("y")?2:1;delete n.kdTree,syncTimeout(function(){n.kdTree=function t(e,i,s){var r=e&&e.length;let o,a;if(r)return o=n.kdAxisArray[i%s],e.sort(function(t,e){return t[o]-e[o]}),{point:e[a=Math.floor(r/2)],left:t(e.slice(0,a),i+1,s),right:t(e.slice(a+1),i+1,s)}}(n.getValidPoints(null,!n.directTouch),e,e),n.buildingKdTree=!1},n.options.kdNow||t&&"touchstart"===t.type?0:1)}searchKDTree(t,e,i){const u=this,[g,m]=this.kdAxisArray,f=e?"distX":"dist",s=-1<(u.options.findNearestPointBy||"").indexOf("y")?2:1,y=!!u.isBubble;function v(t,e,i,s){var r,o=e.point,a=u.kdAxisArray[i%s];let n,l,h=o;p=o,c=(r=t)[g],d=p[g],c=defined(c)&&defined(d)?c-d:null,d=r[m],r=p[m],d=defined(d)&&defined(r)?d-r:0,r=y&&p.marker?.radius||0,p.dist=Math.sqrt((c&&c*c||0)+d*d)-r,p.distX=defined(c)?Math.abs(c)-r:Number.MAX_VALUE;var d=(t[a]||0)-(o[a]||0)+(y&&o.marker?.radius||0),p=d<0?"left":"right",c=d<0?"right":"left";return e[p]&&(n=v(t,e[p],i+1,s),h=n[f]<h[f]?n:o),e[c]&&Math.sqrt(d*d)<h[f]&&(l=v(t,e[c],i+1,s),h=l[f]<h[f]?l:h),h}if(this.kdTree||this.buildingKdTree||this.buildKDTree(i),this.kdTree)return v(t,this.kdTree,s,s)}pointPlacementToXValue(){var{options:{pointPlacement:t,pointRange:e},xAxis:i}=this;let s=t;return"between"===s&&(s=i.reversed?-.5:.5),isNumber(s)?s*(e||i.pointRange):0}isPointInside(t){var{chart:e,xAxis:i,yAxis:s}=this;return void 0!==t.plotY&&void 0!==t.plotX&&0<=t.plotY&&t.plotY<=(s?s.len:e.plotHeight)&&0<=t.plotX&&t.plotX<=(i?i.len:e.plotWidth)}drawTracker(){function e(t){s.enableMouseTracking&&o.hoverSeries!==i&&i.onMouseOver()}const i=this,s=i.options,t=s.trackByArea,r=[].concat(t?i.areaPath:i.graphPath),o=i.chart,a=o.pointer,n=o.renderer,l=o.options.tooltip.snap,h=i.tracker,d="rgba(192,192,192,"+(svg?1e-4:.002)+")";h?h.attr({d:r}):i.graph&&(i.tracker=n.path(r).attr({visibility:i.visible?"inherit":"hidden",zIndex:2}).addClass(t?"highcharts-tracker-area":"highcharts-tracker-line").add(i.group),o.styledMode||i.tracker.attr({"stroke-linecap":"round","stroke-linejoin":"round",stroke:d,fill:t?d:"none","stroke-width":i.graph.strokeWidth()+(t?0:2*l)}),[i.tracker,i.markerGroup,i.dataLabelsGroup].forEach(function(t){t&&(t.addClass("highcharts-tracker").on("mouseover",e).on("mouseout",function(t){a.onTrackerMouseOut(t)}),s.cursor&&!o.styledMode&&t.css({cursor:s.cursor}),hasTouch&&t.on("touchstart",e))})),fireEvent(this,"afterDrawTracker")}addPoint(t,e,i,s,r){const o=this,a=o.options,n=o.data,l=o.chart,h=o.xAxis,d=h&&h.hasNames&&h.names,p=a.data,c=o.xData;let u,g;e=pick(e,!0);var m={series:o},f=(o.pointClass.prototype.applyOptions.apply(m,[t]),m.x);if(g=c.length,o.requireSorting&&f<c[g-1])for(u=!0;g&&c[g-1]>f;)g--;o.updateParallelArrays(m,"splice",[g,0,0]),o.updateParallelArrays(m,g),d&&m.name&&(d[f]=m.name),p.splice(g,0,t),(u||o.processedData)&&(o.data.splice(g,0,null),o.processData()),"point"===a.legendType&&o.generatePoints(),i&&(n[0]&&n[0].remove?n[0].remove(!1):(n.shift(),o.updateParallelArrays(m,"shift"),p.shift())),!1!==r&&fireEvent(o,"addPoint",{point:m}),o.isDirty=!0,o.isDirtyData=!0,e&&l.redraw(s)}removePoint(t,e,i){function s(){n&&n.length===o.length&&n.splice(t,1),o.splice(t,1),r.options.data.splice(t,1),r.updateParallelArrays(a||{series:r},"splice",[t,1]),a&&a.destroy(),r.isDirty=!0,r.isDirtyData=!0,e&&l.redraw()}const r=this,o=r.data,a=o[t],n=r.points,l=r.chart;setAnimation(i,l),e=pick(e,!0),a?a.firePointEvent("remove",null,s):s()}remove(t,e,i,s){const r=this,o=r.chart;function a(){r.destroy(s),o.isDirtyLegend=o.isDirtyBox=!0,o.linkSeries(s),pick(t,!0)&&o.redraw(e)}!1!==i?fireEvent(r,"remove",null,a):a()}update(t,e){t=diffObjects(t,this.userOptions),fireEvent(this,"update",{options:t});const i=this,s=i.chart,r=i.userOptions,o=i.initialType||i.type,a=s.options.plotOptions,n=seriesTypes[o].prototype,l=i.finishedAnimating&&{animation:!1},h={};let d,p,c=["colorIndex","eventOptions","navigatorSeries","symbolIndex","baseSeries"],u=t.type||r.type||s.options.chart.type;var g=!(this.hasDerivedData||u&&u!==this.type||void 0!==t.pointStart||void 0!==t.pointInterval||void 0!==t.relativeXValue||t.joinBy||t.mapData||["dataGrouping","pointStart","pointInterval","pointIntervalUnit","keys"].some(t=>i.hasOptionChanged(t)));u=u||o,g&&(c.push("data","isDirtyData","isDirtyCanvas","points","processedData","processedXData","processedYData","xIncrement","cropped","_hasPointMarkers","hasDataLabels","clips","nodes","layout","level","mapMap","mapData","minY","maxY","minX","maxX"),!1!==t.visible&&c.push("area","graph"),i.parallelArrays.forEach(function(t){c.push(t+"Data")}),t.data&&(t.dataSorting&&extend(i.options.dataSorting,t.dataSorting),this.setData(t.data,!1))),t=merge(r,l,{index:(void 0===r.index?i:r).index,pointStart:pick(a?.series?.pointStart,r.pointStart,i.xData[0])},!g&&{data:i.options.data},t),g&&t.data&&(t.data=i.options.data),(c=["group","markerGroup","dataLabelsGroup","transformGroup"].concat(c)).forEach(function(t){c[t]=i[t],delete i[t]});let m=!1;if(seriesTypes[u]){if(m=u!==i.type,i.remove(!1,!1,!1,!0),m)if(Object.setPrototypeOf)Object.setPrototypeOf(i,seriesTypes[u].prototype);else{var f=Object.hasOwnProperty.call(i,"hcEvents")&&i.hcEvents;for(p in n)i[p]=void 0;extend(i,seriesTypes[u].prototype),f?i.hcEvents=f:delete i.hcEvents}}else error(17,!0,s,{missingModuleFor:u});if(c.forEach(function(t){i[t]=c[t]}),i.init(s,t),g&&this.points){!1===(d=i.options).visible?(h.graphic=1,h.dataLabel=1):(this.hasMarkerChanged(d,r)&&(h.graphic=1),i.hasDataLabels?.()||(h.dataLabel=1));for(const y of this.points)y&&y.series&&(y.resolveColor(),Object.keys(h).length&&y.destroyElements(h),!1===d.showInLegend&&y.legendItem&&s.legend.destroyItem(y))}i.initialType=o,s.linkSeries(),m&&i.linkedSeries.length&&(i.isDirtyData=!0),fireEvent(this,"afterUpdate"),pick(e,!0)&&s.redraw(g&&void 0)}setName(t){this.name=this.options.name=this.userOptions.name=t,this.chart.isDirtyLegend=!0}hasOptionChanged(t){var e=this.chart,i=this.options[t],e=e.options.plotOptions,s=this.userOptions[t],e=pick(e?.[this.type]?.[t],e?.series?.[t]);return s&&!defined(e)?i!==s:i!==pick(e,i)}onMouseOver(){const t=this,e=t.chart,i=e.hoverSeries,s=e.pointer;s.setHoverChartIndex(),i&&i!==t&&i.onMouseOut(),t.options.events.mouseOver&&fireEvent(t,"mouseOver"),t.setState("hover"),e.hoverSeries=t}onMouseOut(){const t=this,e=t.options,i=t.chart,s=i.tooltip,r=i.hoverPoint;i.hoverSeries=null,r&&r.onMouseOut(),t&&e.events.mouseOut&&fireEvent(t,"mouseOut"),!s||t.stickyTracking||s.shared&&!t.noSharedTooltip||s.hide(),i.series.forEach(function(t){t.setState("",!0)})}setState(e,t){const i=this,s=i.options,r=i.graph,o=s.inactiveOtherPoints,a=s.states,n=pick(a[e||"normal"]&&a[e||"normal"].animation,i.chart.options.chart.animation);let l,h=s.lineWidth,d=0,p=s.opacity;if(e=e||"",i.state!==e&&([i.group,i.markerGroup,i.dataLabelsGroup].forEach(function(t){t&&(i.state&&t.removeClass("highcharts-series-"+i.state),e&&t.addClass("highcharts-series-"+e))}),i.state=e,!i.chart.styledMode)){if(a[e]&&!1===a[e].enabled)return;if(e&&(h=a[e].lineWidth||h+(a[e].lineWidthPlus||0),p=pick(a[e].opacity,p)),r&&!r.dashstyle&&isNumber(h))for(l={"stroke-width":h},r.animate(l,n);i["zone-graph-"+d];)i["zone-graph-"+d].animate(l,n),d+=1;o||[i.group,i.markerGroup,i.dataLabelsGroup,i.labelBySeries].forEach(function(t){t&&t.animate({opacity:p},n)})}t&&o&&i.points&&i.setAllPointsToState(e||void 0)}setAllPointsToState(e){this.points.forEach(function(t){t.setState&&t.setState(e)})}setVisible(e,t){const i=this,s=i.chart,r=s.options.chart.ignoreHiddenSeries,o=i.visible,a=(i.visible=e=i.options.visible=i.userOptions.visible=void 0===e?!o:e,e?"show":"hide");["group","dataLabelsGroup","markerGroup","tracker","tt"].forEach(t=>{i[t]?.[a]()}),s.hoverSeries!==i&&s.hoverPoint?.series!==i||i.onMouseOut(),i.legendItem&&s.legend.colorizeItem(i,e),i.isDirty=!0,i.options.stacking&&s.series.forEach(t=>{t.options.stacking&&t.visible&&(t.isDirty=!0)}),i.linkedSeries.forEach(t=>{t.setVisible(e,!1)}),r&&(s.isDirtyBox=!0),fireEvent(i,a),!1!==t&&s.redraw()}show(){this.setVisible(!0)}hide(){this.setVisible(!1)}select(t){var e=this;e.selected=t=this.options.selected=void 0===t?!e.selected:t,e.checkbox&&(e.checkbox.checked=t),fireEvent(e,t?"select":"unselect")}shouldShowTooltip(t,e,i={}){return i.series=this,i.visiblePlotOnly=!0,this.chart.isInsidePlot(t,e,i)}drawLegendSymbol(t,e){LegendSymbol[this.options.legendSymbol||"rectangle"]?.call(this,t,e)}}Series.defaultOptions=SeriesDefaults,Series.types=SeriesRegistry.seriesTypes,Series.registerType=SeriesRegistry.registerSeriesType,extend(Series.prototype,{axisTypes:["xAxis","yAxis"],coll:"series",colorCounter:0,directTouch:!1,isCartesian:!0,kdAxisArray:["clientX","plotY"],parallelArrays:["x","y"],pointClass:Point,requireSorting:!0,sorted:!0});export default SeriesRegistry.series=Series;