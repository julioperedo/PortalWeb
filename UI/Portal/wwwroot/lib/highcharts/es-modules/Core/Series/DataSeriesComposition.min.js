"use strict";import DataTable from"../../Data/DataTable.js";import U from"../Utilities.js";const{addEvent,fireEvent,isNumber,merge,wrap}=U,composedMembers=[];function wrapSeriesGeneratePoints(t){if(this.hasGroupedData)return t.call(this);const s=this.pointClass,n=this.cropStart||0,a=this.data||[],i=[],o=this.processedXData,r=this.processedYData;let l,h;for(let t=0,e=o.length;t<e;++t)l=n+t,(h=(h=a[l])||(a[l]=(new s).init(this,r[l],o[t]))).index=l,i[t]=h;this.data=a,this.points=i,fireEvent(this,"afterGeneratePoints")}function wrapSeriesSetData(t,s=[],e=!0,n){const a=this.datas;if(this.hasGroupedData||!this.options.dataAsColumns)return t.call(this,s,e,n);s=this.options.data=this.userOptions.data=this.chart.options.chart.allowMutatingData?s||[]:merge(!0,s);const i={},o=(this.options.keys||this.parallelArrays).slice();if(isNumber(s[0])||1===o.length){const r=i.x=[];for(let t=0,e=s.length;t<e;++t)r.push(this.autoIncrement());i[o[1]||"y"]=s}else{if(-1===o.indexOf("x")&&o.length>s.length){const l=i.x=[];for(let t=0,e=s.length;t<e;++t)l.push(this.autoIncrement())}for(let t=0,e=Math.min(s.length,o.length);t<e;++t)s[t]instanceof Array&&(i[o[t]]=s[t])}a.setTable(new DataTable({columns:i,id:this.name}))}class DataSeriesAdditions{static compose(t){U.pushUnique(composedMembers,t)&&(addEvent(t,"init",function(){this.datas=new DataSeriesAdditions(this)}),t=t.prototype,wrap(t,"generatePoints",wrapSeriesGeneratePoints),wrap(t,"setData",wrapSeriesSetData))}constructor(t){this.unlisteners=[];const s={},n=t.parallelArrays;for(let t=0,e=n.length;t<e;++t)s[n[t]]=[];this.series=t,this.table=new DataTable}processTable(t,e){const s=this.series;if("point"===s.options.legendType&&(s.processData(),s.generatePoints()),t){const n=s.chart;s.isDirty=n.isDirtyBox=!0,s.isDirtyData=!0,n.redraw(e)}}setTable(n,t=!0,e){const s=this.series,a=s,i=s.points,o=s.parallelArrays,r=n.getRowCount();let l;if(i){const p=s.xAxis;s.colorCounter=0,s.data=[],delete a.points,delete a.processedXData,delete a.processedYData,delete a.xIncrement;for(let t=0,e=o.length;t<e;++t)l=o[t],a[l+"Data"]=[];for(let t=0,e=i.length;t<e;++t)i[t]&&i[t].destroy&&i[t].destroy();p&&(p.minRange=p.userMinRange)}let h,c=!1,f=!1;for(let t=0,e=o.length;t<e;++t){if(l=o[t],!(h=n.getColumn(l,!0))){if("x"===l){f=!0;continue}c=!0;break}a[l+"Data"]=h}if(c){const d=n.getColumnNames(),u=[];u.length=r;let s=0;d.length===o.length-1&&(s=1,f=!0);for(let t=s,e=o.length;t<e;++t)h=n.getColumn(d[t],!0),l=o[t],a[l+"Data"]=h||u.slice()}if((this.indexAsX=f)&&-1!==o.indexOf("x")){h=[];for(let t=0;t<r;++t)h.push(s.autoIncrement());a.xData=h}this.syncOff(),this.table=n,t&&this.syncOn(),this.processTable(t,i&&e)}syncOff(){const s=this.unlisteners;for(let t=0,e=s.length;t<e;++t)s[t]();s.length=0}syncOn(){if(!this.unlisteners.length){const n=this.series,t=this.table,a=n,e=s=>{if("afterDeleteColumns"===s.type)this.setTable(t,!0);else{if("afterDeleteRows"===s.type){if(0<s.rowIndex&&s.rowIndex+s.rowCount<n.points.length)return void this.setTable(t,!0);for(let t=s.rowIndex,e=t+s.rowCount;t<e;++t)n.removePoint(t,!1)}if(this.indexAsX)if("afterSetCell"===s.type)a.xData[s.rowIndex]=s.rowIndex;else if("afterSetRows"===s.type)for(let t=s.rowIndex,e=t+s.rowCount;t<e;++t)a.xData[t]=n.autoIncrement();this.processTable(!0)}};this.unlisteners.push(t.on("afterDeleteColumns",e),t.on("afterDeleteRows",e),t.on("afterSetCell",e),t.on("afterSetRows",e))}}}export default DataSeriesAdditions;