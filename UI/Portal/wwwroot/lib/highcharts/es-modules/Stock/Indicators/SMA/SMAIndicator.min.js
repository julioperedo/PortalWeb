"use strict";import Chart from"../../../Core/Chart/Chart.js";import SeriesRegistry from"../../../Core/Series/SeriesRegistry.js";const LineSeries=SeriesRegistry.seriesTypes["line"];import U from"../../../Core/Utilities.js";const{addEvent,fireEvent,error,extend,isArray,merge,pick,splat}=U;class SMAIndicator extends LineSeries{constructor(){super(...arguments),this.data=void 0,this.dataEventsToUnbind=void 0,this.linkedParent=void 0,this.options=void 0,this.points=void 0}destroy(){this.dataEventsToUnbind.forEach(function(a){a()}),super.destroy.apply(this,arguments)}getName(){const t=[];let a=this.name;return a||((this.nameComponents||[]).forEach(function(a,e){t.push(this.options.params[a]+pick(this.nameSuffixes[e],""))},this),a=(this.nameBase||this.type.toUpperCase())+(this.nameComponents?" ("+t.join(", ")+")":"")),a}getValues(a,e){const t=e.period,i=a.xData,n=a.yData,s=n.length,r=[],o=[],d=[];let l,p=-1,c=0,u,h=0;if(!(i.length<t)){for(isArray(n[0])&&(p=e.index||0);c<t-1;)h+=p<0?n[c]:n[c][p],c++;for(l=c;l<s;l++)h+=p<0?n[l]:n[l][p],u=[i[l],h/t],r.push(u),o.push(u[0]),d.push(u[1]),h-=p<0?n[l-c]:n[l-c][p];return{values:r,xData:o,yData:d}}}init(t,a){const i=this;super.init.call(i,t,a);a=addEvent(Chart,"afterLinkSeries",function({isUpdating:a}){if(!a){a=!!i.dataEventsToUnbind.length;if(!i.linkedParent)return error("Series "+i.options.linkedTo+" not found! Check `linkedTo`.",!1,t);if(a||(i.dataEventsToUnbind.push(addEvent(i.linkedParent,"updatedData",function(){i.recalculateValues()})),i.calculateOn.xAxis&&i.dataEventsToUnbind.push(addEvent(i.linkedParent.xAxis,i.calculateOn.xAxis,function(){i.recalculateValues()}))),"init"===i.calculateOn.chart)i.processedYData||i.recalculateValues();else if(!a){const e=addEvent(i.chart,i.calculateOn.chart,function(){i.recalculateValues(),e()})}}},{order:0});i.dataEventsToUnbind=[],i.eventsToUnbind.push(a)}recalculateValues(){const a=[],e=this,t=e.points||[],i=(e.xData||[]).length,n={values:[],xData:[],yData:[]};let s=!0,r,o,d,l,p,c;const u=e.linkedParent.options&&e.linkedParent.yData&&e.linkedParent.yData.length&&e.getValues(e.linkedParent,e.options.params)||n;if(i&&!e.hasGroupedData&&e.visible&&e.points)if(e.cropped){for(e.xAxis&&(l=e.xAxis.min,p=e.xAxis.max),d=e.cropData(u.xData,u.yData,l,p),c=0;c<d.xData.length;c++)a.push([d.xData[c]].concat(splat(d.yData[c])));r=u.xData.indexOf(e.xData[0]),o=u.xData.indexOf(e.xData[e.xData.length-1]),-1===r&&o===u.xData.length-2&&a[0][0]===t[0].x&&a.shift(),e.updateData(a)}else(e.updateAllPoints||u.xData.length!==i-1&&u.xData.length!==i+1)&&(s=!1,e.updateData(u.values));s&&(e.xData=u.xData,e.yData=u.yData,e.options.data=u.values),e.calculateOn.xAxis&&e.processedXData&&(delete e.processedXData,e.isDirty=!0,e.redraw()),e.isDirtyData=!!e.linkedSeries.length,fireEvent(e,"updatedData")}processData(){var a=this,e=a.options.compareToMain,t=a.linkedParent;super.processData.apply(a,arguments),a.dataModify&&t&&t.dataModify&&t.dataModify.compareValue&&e&&(a.dataModify.compareValue=t.dataModify.compareValue)}}SMAIndicator.defaultOptions=merge(LineSeries.defaultOptions,{name:void 0,tooltip:{valueDecimals:4},linkedTo:void 0,compareToMain:!1,params:{index:3,period:14}}),extend(SMAIndicator.prototype,{calculateOn:{chart:"init"},hasDerivedData:!0,nameComponents:["period"],nameSuffixes:[],useCommonDataGrouping:!0}),SeriesRegistry.registerSeriesType("sma",SMAIndicator);export default SMAIndicator;