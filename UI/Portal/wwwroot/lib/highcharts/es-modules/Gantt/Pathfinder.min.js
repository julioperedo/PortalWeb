"use strict";import Connection from"./Connection.js";import PathfinderAlgorithms from"./PathfinderAlgorithms.js";import PathfinderComposition from"./PathfinderComposition.js";import Point from"../Core/Series/Point.js";import U from"../Core/Utilities.js";const{addEvent,defined,pick,splat}=U,max=Math.max,min=Math.min;function getPointBB(t){var n=t.shapeArgs;if(n)return{xMin:n.x||0,xMax:(n.x||0)+(n.width||0),yMin:n.y||0,yMax:(n.y||0)+(n.height||0)};n=t.graphic&&t.graphic.getBBox();return n?{xMin:t.plotX-n.width/2,xMax:t.plotX+n.width/2,yMin:t.plotY-n.height/2,yMax:t.plotY+n.height/2}:null}function calculateObstacleDistance(t,n,i){var i=pick(i,10),e=t.yMax+i>n.yMin-i&&t.yMin-i<n.yMax+i,o=t.xMax+i>n.xMin-i&&t.xMin-i<n.xMax+i,r=e?t.xMin>n.xMax?t.xMin-n.xMax:n.xMin-t.xMax:1/0,a=o?t.yMin>n.yMax?t.yMin-n.yMax:n.yMin-t.yMax:1/0;return o&&e?i?calculateObstacleDistance(t,n,Math.floor(i/2)):1/0:min(r,a)}function calculateObstacleMargin(i){const e=i.length,o=[];var r;for(let n=0;n<e;++n)for(let t=n+1;t<e;++t)(r=calculateObstacleDistance(i[n],i[t]))<80&&o.push(r);return o.push(80),max(Math.floor(o.sort(function(t,n){return t-n})[Math.floor(o.length/10)]/2-1),1)}class Pathfinder{static compose(t,n){PathfinderComposition.compose(t,Pathfinder,n)}constructor(t){this.chart=void 0,this.chartObstacles=void 0,this.chartObstacleMetrics=void 0,this.connections=void 0,this.group=void 0,this.lineObstacles=void 0,this.init(t)}init(t){this.chart=t,this.connections=[],addEvent(t,"redraw",function(){this.pathfinder.update()})}update(t){const o=this.chart,r=this,a=r.connections;r.connections=[],o.series.forEach(function(t){t.visible&&!t.options.isInternal&&t.points.forEach(function(n){const t=n.options,i=(t&&t.dependency&&(t.connect=t.dependency),n.options?.connect&&splat(n.options.connect));let e;n.visible&&!1!==n.isInside&&i&&i.forEach(function(t){(e=o.get("string"==typeof t?t:t.to))instanceof Point&&e.series.visible&&e.visible&&!1!==e.isInside&&r.connections.push(new Connection(n,e,"string"==typeof t?{}:t))})})});for(let t=0,n,i,e=a.length,o=r.connections.length;t<e;++t){i=!1;const s=a[t];for(n=0;n<o;++n){const c=r.connections[n];if((s.options&&s.options.type)===(c.options&&c.options.type)&&s.fromPoint===c.fromPoint&&s.toPoint===c.toPoint){c.graphics=s.graphics,i=!0;break}}i||s.destroy()}delete this.chartObstacles,delete this.lineObstacles,r.renderConnections(t)}renderConnections(t){t?this.chart.series.forEach(function(i){function t(){const t=i.chart.pathfinder,n=t&&t.connections||[];n.forEach(function(t){t.fromPoint&&t.fromPoint.series===i&&t.render()}),i.pathfinderRemoveRenderEvent&&(i.pathfinderRemoveRenderEvent(),delete i.pathfinderRemoveRenderEvent)}!1===i.options.animation?t():i.pathfinderRemoveRenderEvent=addEvent(i,"afterAnimate",t)}):this.connections.forEach(function(t){t.render()})}getChartObstacles(t){var r=this.chart.series,a=pick(t.algorithmMargin,0);let s=[],n;for(let o=0,t=r.length;o<t;++o)if(r[o].visible&&!r[o].options.isInternal)for(let t=0,n=r[o].points.length,i,e;t<n;++t)(e=r[o].points[t]).visible&&(i=getPointBB(e))&&s.push({xMin:i.xMin-a,xMax:i.xMax+a,yMin:i.yMin-a,yMax:i.yMax+a});return s=s.sort(function(t,n){return t.xMin-n.xMin}),defined(t.algorithmMargin)||(n=t.algorithmMargin=calculateObstacleMargin(s),s.forEach(function(t){t.xMin-=n,t.xMax+=n,t.yMin-=n,t.yMax+=n})),s}getObstacleMetrics(t){let n=0,i=0,e,o,r=t.length;for(;r--;)e=t[r].xMax-t[r].xMin,o=t[r].yMax-t[r].yMin,n<e&&(n=e),i<o&&(i=o);return{maxHeight:i,maxWidth:n}}getAlgorithmStartDirection(t){var n="left"!==t.align&&"right"!==t.align,t="top"!==t.verticalAlign&&"bottom"!==t.verticalAlign;return n?t&&void 0:t||void 0}}Pathfinder.prototype.algorithms=PathfinderAlgorithms;export default Pathfinder;