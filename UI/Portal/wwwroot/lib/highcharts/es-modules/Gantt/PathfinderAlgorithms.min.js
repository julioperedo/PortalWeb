"use strict";import PathUtilities from"../Series/PathUtilities.js";import U from"../Core/Utilities.js";const pick=U["pick"],{min,max,abs}=Math;function findLastObstacleBefore(t,n,a){var i=n-1e-7;let x=a||0,s=t.length-1,e,r;for(;x<=s;)if(0<(r=i-t[e=s+x>>1].xMin))x=1+e;else{if(!(r<0))return e;s=e-1}return 0<x?x-1:0}function pointWithinObstacle(t,n){return n.x<=t.xMax&&n.x>=t.xMin&&n.y<=t.yMax&&n.y>=t.yMin}function findObstacleFromPoint(t,n){let a=findLastObstacleBefore(t,n.x+1)+1;for(;a--;)if(t[a].xMax>=n.x&&pointWithinObstacle(t[a],n))return a;return-1}function pathFromSegments(n){const a=[];if(n.length){a.push(["M",n[0].start.x,n[0].start.y]);for(let t=0;t<n.length;++t)a.push(["L",n[t].end.x,n[t].end.y])}return a}function limitObstacleToBounds(t,n){t.yMin=max(t.yMin,n.yMin),t.yMax=min(t.yMax,n.yMax),t.xMin=max(t.xMin,n.xMin),t.xMax=min(t.xMax,n.xMax)}function straight(t,n){return{path:[["M",t.x,t.y],["L",n.x,n.y]],obstacles:[{start:t,end:n}]}}const simpleConnect=function(t,n,a){const i=[],x=a.chartObstacles,s=findObstacleFromPoint(x,t),e=findObstacleFromPoint(x,n);let r,o=pick(a.startDirectionX,abs(n.x-t.x)>abs(n.y-t.y))?"x":"y",y,M,c,l,d;function u(t,n,a,i,x){const s={x:t.x,y:t.y};return s[n]=a[i||n]+(x||0),s}function f(t,n,a){var i=abs(n[a]-t[a+"Min"])>abs(n[a]-t[a+"Max"]);return u(n,a,t,a+(i?"Max":"Min"),i?1:-1)}d=-1<e?(M=x[e],c=f(M,n,o),r={start:c,end:n},c):n,-1<s&&(y=x[s],c=f(y,t,o),i.push({start:t,end:c}),c[o]>=t[o]==c[o]>=d[o]&&(l=t[o="y"===o?"x":"y"]<n[o],i.push({start:c,end:u(c,o,y,o+(l?"Max":"Min"),l?1:-1)}),o="y"===o?"x":"y"));n=i.length?i[i.length-1].end:t,c=u(n,o,d),i.push({start:n,end:c}),o="y"===o?"x":"y",t=u(c,o,d),i.push({start:c,end:t}),i.push(r),n=PathUtilities.applyRadius(pathFromSegments(i),a.radius);return{path:n,obstacles:i}};function fastAvoid(t,n,u){const a=pick(u.startDirectionX,abs(n.x-t.x)>abs(n.y-t.y)),i=a?"x":"y",x=[],s=u.obstacleMetrics,f=min(t.x,n.x)-s.maxWidth-10,m=max(t.x,n.x)+s.maxWidth+10,h=min(t.y,n.y)-s.maxHeight-10,b=max(t.y,n.y)+s.maxHeight+10;let e,r,o,p=!1,O=u.chartObstacles,y=findLastObstacleBefore(O,m);var M,c,l,d=findLastObstacleBefore(O,f);function g(t,n,a){var i=t.x<n.x?1:-1;let x,s,e,r,o=(s=t.x<n.x?(x=t,n):(x=n,t),e=t.y<n.y?(r=t,n):(r=n,t),i<0?min(findLastObstacleBefore(O,s.x),O.length-1):0);for(;O[o]&&(0<i&&O[o].xMin<=s.x||i<0&&O[o].xMax>=x.x);){if(O[o].xMin<=s.x&&O[o].xMax>=x.x&&O[o].yMin<=e.y&&O[o].yMax>=r.y)return a?{y:t.y,x:t.x<n.x?O[o].xMin-1:O[o].xMax+1,obstacle:O[o]}:{x:t.x,y:t.y<n.y?O[o].yMin-1:O[o].yMax+1,obstacle:O[o]};o+=i}return n}function B(t,n,a,i,x){const s=x.soft,e=x.hard,r=i?"x":"y",o={x:n.x,y:n.y},y={x:n.x,y:n.y},M=t[r+"Max"]>=s[r+"Max"],c=t[r+"Min"]<=s[r+"Min"],l=t[r+"Max"]>=e[r+"Max"],d=t[r+"Min"]<=e[r+"Min"],u=abs(t[r+"Min"]-n[r]),f=abs(t[r+"Max"]-n[r]);let m=abs(u-f)<10?n[r]<a[r]:f<u;y[r]=t[r+"Min"],o[r]=t[r+"Max"];x=g(n,y,i)[r]!==y[r],a=g(n,o,i)[r]!==o[r];return m=x?!a||m:!a&&m,m=c?!M||m:!M&&m,m=d?!l||m:!l&&m}for(O=O.slice(d,y+1),-1<(y=findObstacleFromPoint(O,n))&&(o=(d=O[y],M=n,c=t,l=min(d.xMax-M.x,M.x-d.xMin)<min(d.yMax-M.y,M.y-d.yMin),c=B(d,M,c,l,{soft:u.hardBounds,hard:u.hardBounds}),l?{y:M.y,x:d[c?"xMax":"xMin"]+(c?1:-1)}:{x:M.x,y:d[c?"yMax":"yMin"]+(c?1:-1)}),x.push({end:n,start:o}),n=o);-1<(y=findObstacleFromPoint(O,n));)r=n[i]-t[i]<0,(o={x:n.x,y:n.y})[i]=O[y][r?i+"Max":i+"Min"]+(r?1:-1),x.push({end:n,start:o}),n=o;return{path:pathFromSegments(e=(e=function t(n,a,i){if(n.x===a.x&&n.y===a.y)return[];var x=i?"x":"y",s=u.obstacleOptions.margin,e={soft:{xMin:f,xMax:m,yMin:h,yMax:b},hard:u.hardBounds};let r,o,y,M,c,l,d;return-1<(c=findObstacleFromPoint(O,n))?(c=O[c],M=B(c,n,a,i,e),limitObstacleToBounds(c,u.hardBounds),d=i?{y:n.y,x:c[M?"xMax":"xMin"]+(M?1:-1)}:{x:n.x,y:c[M?"yMax":"yMin"]+(M?1:-1)},-1<(l=findObstacleFromPoint(O,d))&&(limitObstacleToBounds(l=O[l],u.hardBounds),d[x]=M?max(c[x+"Max"]-s+1,(l[x+"Min"]+c[x+"Max"])/2):min(c[x+"Min"]+s-1,(l[x+"Max"]+c[x+"Min"])/2),p=n.x===d.x&&n.y===d.y&&(p&&(d[x]=M?max(c[x+"Max"],l[x+"Max"])+1:min(c[x+"Min"],l[x+"Min"])-1),!p)),o=[{start:n,end:d}]):(r=g(n,{x:(i?a:n).x,y:(i?n:a).y},i),o=[{start:n,end:{x:r.x,y:r.y}}],r[i?"x":"y"]!==a[i?"x":"y"]&&(M=B(r.obstacle,r,a,!i,e),limitObstacleToBounds(r.obstacle,u.hardBounds),y={x:i?r.x:r.obstacle[M?"xMax":"xMin"]+(M?1:-1),y:i?r.obstacle[M?"yMax":"yMin"]+(M?1:-1):r.y},i=!i,o=o.concat(t({x:r.x,y:r.y},y,i)))),o=o.concat(t(o[o.length-1].end,a,!i))}(t,n,a)).concat(x.reverse())),obstacles:e}}simpleConnect.requiresObstacles=!0,fastAvoid.requiresObstacles=!0;const algorithms={fastAvoid:fastAvoid,straight:straight,simpleConnect:simpleConnect};export default algorithms;