"use strict";import H from"../Core/Globals.js";import U from"../Core/Utilities.js";const{defined,error,merge,objectEach}=U,deg2rad=H.deg2rad,max=Math.max,min=Math.min;class Connection{constructor(t,r,i){this.chart=void 0,this.fromPoint=void 0,this.graphics=void 0,this.pathfinder=void 0,this.toPoint=void 0,this.init(t,r,i)}init(t,r,i){this.fromPoint=t,this.toPoint=r,this.options=i,this.chart=t.series.chart,this.pathfinder=this.chart.pathfinder}renderPath(t,r,i){const e=this.chart,a=e.styledMode,o=e.pathfinder,s=!e.options.chart.forExport&&!1!==i,h={};let n=this.graphics&&this.graphics.path;o.group||(o.group=e.renderer.g().addClass("highcharts-pathfinder-group").attr({zIndex:-1}).add(e.seriesGroup)),o.group.translate(e.plotLeft,e.plotTop),n&&n.renderer||(n=e.renderer.path().add(o.group),a||n.attr({opacity:0})),n.attr(r),h.d=t,a||(h.opacity=1),n[s?"animate":"attr"](h,i),this.graphics=this.graphics||{},this.graphics.path=n}addMarker(t,r,i){const e=this,a=e.fromPoint.series.chart,o=a.pathfinder,s=a.renderer,h="start"===t?e.fromPoint:e.toPoint,n=h.getPathfinderAnchorPoint(r);let c,d,l,g,p,m,f,M;r.enabled&&((M="start"===t?i[1]:i[i.length-2])&&"M"===M[0]||"L"===M[0])&&(f={x:M[1],y:M[2]},d=h.getRadiansToVector(f,n),c=h.getMarkerVector(d,r.radius,n),l=-d/deg2rad,r.width&&r.height?(p=r.width,m=r.height):p=m=2*r.radius,e.graphics=e.graphics||{},g={x:c.x-p/2,y:c.y-m/2,width:p,height:m,rotation:l,rotationOriginX:c.x,rotationOriginY:c.y},e.graphics[t]?e.graphics[t].animate(g):(e.graphics[t]=s.symbol(r.symbol).addClass("highcharts-point-connecting-path-"+t+"-marker highcharts-color-"+this.fromPoint.colorIndex).attr(g).add(o.group),s.styledMode||e.graphics[t].attr({fill:r.color||e.fromPoint.color,stroke:r.lineColor,"stroke-width":r.lineWidth,opacity:0}).animate({opacity:1},h.series.options.animation)))}getPath(t){const r=this.pathfinder,i=this.chart,e=r.algorithms[t.type];let a=r.chartObstacles;return"function"!=typeof e?(error('"'+t.type+'" is not a Pathfinder algorithm.'),{path:[],obstacles:[]}):(e.requiresObstacles&&!a&&(a=r.chartObstacles=r.getChartObstacles(t),i.options.connectors.algorithmMargin=t.algorithmMargin,r.chartObstacleMetrics=r.getObstacleMetrics(a)),e(this.fromPoint.getPathfinderAnchorPoint(t.startMarker),this.toPoint.getPathfinderAnchorPoint(t.endMarker),merge({chartObstacles:a,lineObstacles:r.lineObstacles||[],obstacleMetrics:r.chartObstacleMetrics,hardBounds:{xMin:0,xMax:i.plotWidth,yMin:0,yMax:i.plotHeight},obstacleOptions:{margin:t.algorithmMargin},startDirectionX:r.getAlgorithmStartDirection(t.startMarker)},t)))}render(){const t=this,r=t.fromPoint,i=r.series,e=i.chart,a=e.pathfinder,o={};let s=merge(e.options.connectors,i.options.connectors,r.options.connectors,t.options);e.styledMode||(o.stroke=s.lineColor||r.color,o["stroke-width"]=s.lineWidth,s.dashStyle&&(o.dashstyle=s.dashStyle)),o.class="highcharts-point-connecting-path highcharts-color-"+r.colorIndex,s=merge(o,s),defined(s.marker.radius)||(s.marker.radius=min(max(Math.ceil((s.algorithmMargin||8)/2)-1,1),5));var h=t.getPath(s),n=h.path;h.obstacles&&(a.lineObstacles=a.lineObstacles||[],a.lineObstacles=a.lineObstacles.concat(h.obstacles)),t.renderPath(n,o,i.options.animation),t.addMarker("start",merge(s.marker,s.startMarker),n),t.addMarker("end",merge(s.marker,s.endMarker),n)}destroy(){this.graphics&&(objectEach(this.graphics,function(t){t.destroy()}),delete this.graphics)}}export default Connection;