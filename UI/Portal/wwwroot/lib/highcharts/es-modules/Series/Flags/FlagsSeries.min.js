"use strict";import FlagsPoint from"./FlagsPoint.js";import FlagsSeriesDefaults from"./FlagsSeriesDefaults.js";import FlagsSymbols from"./FlagsSymbols.js";import H from"../../Core/Globals.js";const noop=H["noop"];import OnSeriesComposition from"../OnSeriesComposition.js";import R from"../../Core/Renderer/RendererUtilities.js";const distribute=R["distribute"];import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{series:Series,seriesTypes:{column:ColumnSeries}}=SeriesRegistry;import SVGElement from"../../Core/Renderer/SVG/SVGElement.js";import U from"../../Core/Utilities.js";const{addEvent,defined,extend,merge,objectEach,wrap}=U;class FlagsSeries extends ColumnSeries{constructor(){super(...arguments),this.data=void 0,this.options=void 0,this.points=void 0}animate(e){e&&this.setClip()}drawPoints(){const e=this,i=e.points,t=e.chart,s=t.renderer,o=t.inverted,r=e.options,l=r.y,a=e.yAxis,n={},p=[];let d,h,c,m,g,u,f,S,y,C,w;for(m=i.length;m--;)g=i[m],C=(o?g.plotY:g.plotX)>e.xAxis.len,d=g.plotX,f=g.stackIndex,c=g.options.shape||r.shape,void 0!==(h=g.plotY)&&(h=g.plotY+l-(void 0!==f&&f*r.stackDistance)),g.anchorX=f?void 0:g.plotX,S=f?void 0:g.plotY,w="flag"!==c,u=g.graphic,void 0!==h&&0<=d&&!C?((u=u&&g.hasNewShapeType()?u.destroy():u)||(u=g.graphic=s.label("",null,null,c,null,null,r.useHTML).addClass("highcharts-point").add(e.markerGroup),g.graphic.div&&(g.graphic.div.point=g),u.isNew=!0),u.attr({align:w?"center":"left",width:r.width,height:r.height,"text-align":r.textAlign}),t.styledMode||u.attr(e.pointAttribs(g)).css(merge(r.style,g.style)).shadow(r.shadow),0<d&&(d-=u.strokeWidth()%2),y={y:h,anchorY:S},r.allowOverlapX&&(y.x=d,y.anchorX=g.anchorX),u.attr({text:g.options.title||r.title||"A"})[u.isNew?"attr":"animate"](y),r.allowOverlapX||(n[g.plotX]?n[g.plotX].size=Math.max(n[g.plotX].size,u.width||0):n[g.plotX]={align:w?.5:0,size:u.width||0,target:d,anchorX:d}),g.tooltipPos=[d,h+a.pos-t.plotTop]):u&&(g.graphic=u.destroy());if(!r.allowOverlapX){let t=100;objectEach(n,function(e){e.plotX=e.anchorX,p.push(e),t=Math.max(e.size,t)}),distribute(p,(o?a:this.xAxis).len,t);for(const g of i){const d=g.plotX,u=g.graphic,v=u&&n[d];v&&u&&(defined(v.pos)?u[u.isNew?"attr":"animate"]({x:v.pos+(v.align||0)*v.size,anchorX:g.anchorX}).show().isNew=!1:u.hide().isNew=!0)}}r.useHTML&&e.markerGroup&&wrap(e.markerGroup,"on",function(e){return SVGElement.prototype.on.apply(e.apply(this,[].slice.call(arguments,1)),[].slice.call(arguments,1))})}drawTracker(){const t=this.points;super.drawTracker();for(const i of t){const s=i.graphic;s&&(i.unbindMouseOver&&i.unbindMouseOver(),i.unbindMouseOver=addEvent(s.element,"mouseover",function(){0<i.stackIndex&&!i.raised&&(i._y=s.y,s.attr({y:i._y-8}),i.raised=!0);for(const e of t)e!==i&&e.raised&&e.graphic&&(e.graphic.attr({y:e._y}),e.raised=!1)}))}}pointAttribs(e,t){var i=this.options,s=e&&e.color||this.color;let o=i.lineColor,r=e&&e.lineWidth,l=e&&e.fillColor||i.fillColor;return t&&(l=i.states[t].fillColor,o=i.states[t].lineColor,r=i.states[t].lineWidth),{fill:l||s,stroke:o||s,"stroke-width":r||i.lineWidth||0}}setClip(){Series.prototype.setClip.apply(this,arguments),!1!==this.options.clip&&this.sharedClipKey&&this.markerGroup&&this.markerGroup.clip(this.chart.sharedClips[this.sharedClipKey])}}FlagsSeries.compose=FlagsSymbols.compose,FlagsSeries.defaultOptions=merge(ColumnSeries.defaultOptions,FlagsSeriesDefaults),OnSeriesComposition.compose(FlagsSeries),extend(FlagsSeries.prototype,{allowDG:!1,forceCrop:!0,invertible:!1,noSharedTooltip:!0,pointClass:FlagsPoint,sorted:!1,takeOrdinalPosition:!1,trackerGroups:["markerGroup"],buildKDTree:noop,init:Series.prototype.init}),SeriesRegistry.registerSeriesType("flags",FlagsSeries);export default FlagsSeries;