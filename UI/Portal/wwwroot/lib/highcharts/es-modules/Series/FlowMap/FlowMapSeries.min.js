"use strict";import FlowMapPoint from"./FlowMapPoint.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{series:{prototype:{pointClass:Point}},seriesTypes:{column:ColumnSeries,map:MapSeries,mapline:MapLineSeries}}=SeriesRegistry;import U from"../../Core/Utilities.js";const{addEvent,arrayMax,arrayMin,defined,extend,isArray,merge,pick,relativeLength}=U;class FlowMapSeries extends MapLineSeries{constructor(){super(...arguments),this.data=void 0,this.options=void 0,this.points=void 0,this.smallestWeight=void 0,this.greatestWeight=void 0,this.centerOfPoints=void 0}static getLength(t,i){return Math.sqrt(t*t+i*i)}static normalize(t,i){var o=this.getLength(t,i);return[t/o,i/o]}static markerEndPath(t,i,o,e){var s,r,n=relativeLength(e.width||0,this.getLength(i[0]-t[0],i[1]-t[1])),e=e.markerType||"arrow",[a,p]=this.normalize(i[0]-t[0],i[1]-t[1]);const h=[];return"arrow"===e&&([s,r]=t,s-=a*n,r-=p*n,h.push(["L",s,r]),h.push(["L",o[0],o[1]]),[s,r]=i,s+=a*n,r+=p*n,h.push(["L",s,r])),"mushroom"===e&&([s,r]=t,[e,t]=i,[i,o]=o,i=2*(i-(i=(e-s)/2+s))+i,o=2*(o-(o=(t-r)/2+r))+o,s-=a*n,r-=p*n,h.push(["L",s,r]),e+=a*n,t+=p*n,h.push(["Q",i,o,e,t])),h}animate(t){const i=this.points;t||i.forEach(t=>{if(t.shapeArgs&&isArray(t.shapeArgs.d)&&t.shapeArgs.d.length){var o=t.shapeArgs.d,e=o[0][1],s=o[0][2];if(e&&s){const r=[];for(let i=0;i<o.length;i++){r.push([...o[i]]);for(let t=1;t<o[i].length;t++)r[i][t]=t%2?e:s}t.graphic&&(t.graphic.attr({d:r}),t.graphic.animate({d:o}))}}})}getLinkWidth(t){var i=this.options.width,o=t.options.weight||this.options.weight;if(t.options.weight=o,i&&!o)return i;t=this.smallestWeight,i=this.greatestWeight;if(!defined(o)||!t||!i)return 0;var e=this.options.minWidth;return(o-t)*(this.options.maxWidth-e)/(i-t||1)+e}autoCurve(t,i,o,e,s,r){const n=o-t,a=e-i,p=(o-t)/2+t,h=(e-i)/2+i,l=p-s,d=h-r;o=n*l+a*d,t=n*d-a*l;let c=Math.atan2(t,o),g=180*c/Math.PI;return c=(g=g<0?360+g:g)*Math.PI/180,.7*-Math.sin(c)}pointAttribs(t,i){const o=MapSeries.prototype.pointAttribs.call(this,t,i);return o.fill=pick(t.options.fillColor,t.options.color,"none"===this.options.fillColor?null:this.options.fillColor,this.color),o["fill-opacity"]=pick(t.options.fillOpacity,this.options.fillOpacity),o["stroke-width"]=pick(t.options.lineWidth,this.options.lineWidth,1),t.options.opacity&&(o.opacity=t.options.opacity),o}translate(){!this.chart.hasRendered||!this.isDirtyData&&this.hasRendered||(this.processData(),this.generatePoints());const h=[];let l=0,d=0;this.points.forEach(t=>{const i=this.chart,o=i.mapView,e=t.options,s=()=>{t.series.isDirty=!0},r=t=>{t=i.get(t);if(t instanceof Point&&t.plotX&&t.plotY)return addEvent(t,"update",s),{x:t.plotX,y:t.plotY}},n=t=>isArray(t)?{lon:t[0],lat:t[1]}:t;let a,p;"string"==typeof e.from?a=r(e.from):"object"==typeof e.from&&o&&(a=o.lonLatToPixels(n(e.from))),"string"==typeof e.to?p=r(e.to):"object"==typeof e.to&&o&&(p=o.lonLatToPixels(n(e.to))),t.fromPos=a,t.toPos=p,a&&p&&(l+=(a.x+p.x)/2,d+=(a.y+p.y)/2),pick(t.options.weight,this.options.weight)&&h.push(pick(t.options.weight,this.options.weight))}),this.smallestWeight=arrayMin(h),this.greatestWeight=arrayMax(h),this.centerOfPoints={x:l/this.points.length,y:d/this.points.length},this.points.forEach(t=>{this.getLinkWidth(t)?(t.fromPos&&(t.plotX=t.fromPos.x,t.plotY=t.fromPos.y),t.shapeType="path",t.shapeArgs=this.getPointShapeArgs(t),t.color=pick(t.options.color,t.series.color)):t.shapeArgs={d:[]}})}getPointShapeArgs(t){var{fromPos:i,toPos:o}=t;if(!i||!o)return{};var e=this.getLinkWidth(t)/2,s=t.options,r=merge(this.options.markerEnd,s.markerEnd),n=pick(s.growTowards,this.options.growTowards),a=i.x||0,i=i.y||0;let p=o.x||0,h=o.y||0,l=pick(s.curveFactor,this.options.curveFactor),d=r&&r.enabled&&r.height||0;if(defined(l)||(l=this.autoCurve(a,i,p,h,this.centerOfPoints.x,this.centerOfPoints.y)),d){d=relativeLength(d,4*e);var s=p-a,c=h-i;const g=a+(s*=.5),m=i+(c*=.5),f=s,M=(s=c,c=-f,g+s*l),v=m+c*l;var[s,c]=FlowMapSeries.normalize(M-p,v-h);s*=d,c*=d,p+=s,h+=c}s=p-a,c=h-i;const g=a+(s*=.5),m=i+(c*=.5);let f=s,[y,w]=(s=c,c=-f,FlowMapSeries.normalize(s,c));var u=1+.25*Math.sqrt(l*l);y*=e*u,w*=e*u;const M=g+s*l,v=m+c*l;let[P,S]=FlowMapSeries.normalize(M-a,v-i);f=P,P=S,S=-f,P*=e,S*=e;var[u,s]=FlowMapSeries.normalize(M-p,v-h);f=u,u=-s,s=f,u*=e,s*=e,n&&(P/=e,S/=e,y/=4,w/=4);const k={d:[["M",a-P,i-S],["Q",M-y,v-w,p-u,h-s],["L",p+u,h+s],["Q",M+y,v+w,a+P,i+S],["Z"]]};r&&r.enabled&&k.d&&(c=FlowMapSeries.markerEndPath([p-u,h-s],[p+u,h+s],[o.x,o.y],r),k.d.splice(2,0,...c));n=t.options.from,e=t.options.to,a=n.lat,i=n.lon,u=e.lat,s=e.lon;return a&&i&&(t.options.from=+a+", "+ +i),u&&s&&(t.options.to=+u+", "+ +s),k}}FlowMapSeries.defaultOptions=merge(MapLineSeries.defaultOptions,{animation:!0,dataLabels:{enabled:!1},fillOpacity:.5,markerEnd:{enabled:!0,height:"40%",width:"40%",markerType:"arrow"},width:1,maxWidth:25,minWidth:5,lineWidth:void 0,tooltip:{headerFormat:'<span style="font-size: 0.8em">{series.name}</span><br/>',pointFormat:"{point.options.from} â†’ {point.options.to}: <b>{point.options.weight}</b>"}}),extend(FlowMapSeries.prototype,{pointClass:FlowMapPoint,pointArrayMap:["from","to","weight"],drawPoints:ColumnSeries.prototype.drawPoints,useMapGeometry:!0}),SeriesRegistry.registerSeriesType("flowmap",FlowMapSeries);export default FlowMapSeries;