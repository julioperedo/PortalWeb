"use strict";import PU from"../PathUtilities.js";const getLinkPath=PU["getLinkPath"];import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{series:{prototype:seriesProto},seriesTypes:{treemap:TreemapSeries,column:ColumnSeries}}=SeriesRegistry;import SVGRenderer from"../../Core/Renderer/SVG/SVGRenderer.js";const{symbols}=SVGRenderer["prototype"];import TreegraphNode from"./TreegraphNode.js";import TreegraphPoint from"./TreegraphPoint.js";import TU from"../TreeUtilities.js";const getLevelOptions=TU["getLevelOptions"];import U from"../../Core/Utilities.js";const{extend,merge,pick,relativeLength,splat}=U;import TreegraphLink from"./TreegraphLink.js";import TreegraphLayout from"./TreegraphLayout.js";import TreegraphSeriesDefaults from"./TreegraphSeriesDefaults.js";class TreegraphSeries extends TreemapSeries{constructor(){super(...arguments),this.data=void 0,this.options=void 0,this.points=void 0,this.layoutModifier=void 0,this.nodeMap=void 0,this.tree=void 0,this.nodeList=[],this.layoutAlgorythm=void 0,this.links=[],this.mapOptionsToLevel=void 0}init(){super.init.apply(this,arguments),this.layoutAlgorythm=new TreegraphLayout}getLayoutModifiers(){const e=this.chart,p=this,h=e.plotSizeX,d=e.plotSizeY;let g=1/0,c=-1/0,k=1/0,m=-1/0,y=0,v=0,T=0,u=0;this.points.forEach(t=>{if(!this.options.fillSpace||t.visible){const i=t.node,s=p.mapOptionsToLevel[t.node.level]||{},o=merge(this.options.marker,s.marker,t.options.marker),r=relativeLength(o.radius||0,Math.min(h,d)),a=o.symbol,l="circle"!==a&&o.height?relativeLength(o.height,d):2*r,n="circle"!==a&&o.width?relativeLength(o.width,h):2*r;i.nodeSizeX=n,i.nodeSizeY=l;let e;i.xPosition<=g&&(g=i.xPosition,e=o.lineWidth||0,v=Math.max(n+e,v)),i.xPosition>=c&&(c=i.xPosition,e=o.lineWidth||0,y=Math.max(n+e,y)),i.yPosition<=k&&(k=i.yPosition,e=o.lineWidth||0,u=Math.max(l+e,u)),i.yPosition>=m&&(m=i.yPosition,e=o.lineWidth||0,T=Math.max(l+e,T))}});var t=m===k?1:(d-(u+T)/2)/(m-k),i=m===k?d/2:-t*k+u/2,s=c===g?1:(h-(y+y)/2)/(c-g);return{ax:s,bx:c===g?h/2:-s*g+v/2,ay:t,by:i}}getLinks(){const s=this,o=[];return this.data.forEach((e,t)=>{var i=s.mapOptionsToLevel[e.node.level||0]||{};e.node.parent?(i=merge(i,e.options),!e.linkToParent||e.linkToParent.destroyed?(i=(new s.LinkClass).init(s,i,void 0,e),e.linkToParent=i):(e.collapsed=pick(e.collapsed,(this.mapOptionsToLevel[e.node.level]||{}).collapsed),e.linkToParent.visible=e.linkToParent.toNode.visible),e.linkToParent.index=o.push(e.linkToParent)-1):e.linkToParent&&(s.links.splice(e.linkToParent.index),e.linkToParent.destroy(),delete e.linkToParent)}),o}buildTree(e,t,i,s,o){var r=this.points[t];return i=r&&r.level||i,super.buildTree.call(this,e,t,i,s,o)}markerAttribs(){return{}}setCollapsedStatus(e,t){const i=e.point;i&&(i.collapsed=pick(i.collapsed,(this.mapOptionsToLevel[e.level]||{}).collapsed),t=!1!==(i.visible=t)&&!i.collapsed),e.children.forEach(e=>{this.setCollapsedStatus(e,t)})}drawTracker(){ColumnSeries.prototype.drawTracker.apply(this,arguments),ColumnSeries.prototype.drawTracker.call(this,this.links)}translate(){var e=this,t=e.options;let i=TU.updateRootId(e),s;seriesProto.translate.call(e);var o=e.tree=e.getTree();s=e.nodeMap[i],""===i||s&&s.children.length||(e.setRootNode("",!1),i=e.rootNode,s=e.nodeMap[i]),e.mapOptionsToLevel=getLevelOptions({from:s.level+1,levels:t.levels,to:o.height,defaults:{levelIsConstant:e.options.levelIsConstant,colorByPoint:t.colorByPoint}}),this.setCollapsedStatus(o,!0),e.links=e.getLinks(),e.setTreeValues(o),this.layoutAlgorythm.calculatePositions(e),e.layoutModifier=this.getLayoutModifiers(),this.points.forEach(e=>{this.translateNode(e)}),this.points.forEach(e=>{e.linkToParent&&this.translateLink(e.linkToParent)}),t.colorByPoint||e.setColorRecursive(e.tree)}translateLink(i){var s=i.fromNode,o=i.toNode,r=this.options.link.lineWidth,a=Math.round(r)%2/2,l=pick(this.options.link.curveFactor,.5),n=pick(i.options.link&&i.options.link.type,this.options.link.type);if(s.shapeArgs&&o.shapeArgs){var p=s.shapeArgs.width||0,h=this.chart.inverted,d=Math.floor((s.shapeArgs.y||0)+(s.shapeArgs.height||0)/2)+a,g=Math.floor((o.shapeArgs.y||0)+(o.shapeArgs.height||0)/2)+a;let e=Math.floor((s.shapeArgs.x||0)+p)+a,t=Math.floor(o.shapeArgs.x||0)+a;h&&(e-=p,t+=o.shapeArgs.width||0);var s=o.node.xPosition-s.node.xPosition,c=(i.shapeType="path",Math.abs(t-e)+p),c=c/s-p,s=c*l*(h?-1:1),p=Math.floor((t+e)/2)+a;i.plotX=p,i.plotY=g,i.shapeArgs={d:getLinkPath[n]({x1:e,y1:d,x2:t,y2:g,width:c,offset:s,inverted:h,parentVisible:o.visible,radius:this.options.link.radius})},i.dlBox={x:(e+t)/2,y:(d+g)/2,height:r,width:0},i.tooltipPos=h?[(this.chart.plotSizeY||0)-i.dlBox.y,(this.chart.plotSizeX||0)-i.dlBox.x]:[i.dlBox.x,i.dlBox.y]}}drawNodeLabels(e){var t=this.mapOptionsToLevel;let i,s;for(const o of e)s=t[o.node.level],i={style:{}},s&&s.dataLabels&&(i=merge(i,s.dataLabels),this.hasDataLabels=()=>!0),o.shapeArgs&&!splat(this.options.dataLabels)[0].style.width&&(i.style.width=o.shapeArgs.width,o.dataLabel&&o.dataLabel.css({width:o.shapeArgs.width+"px"})),o.dlOptions=merge(i,o.options.dataLabels);seriesProto.drawDataLabels.call(this,e)}alignDataLabel(e,t){const i=e.visible;e.visible=!0,super.alignDataLabel.apply(this,arguments),t.animate({opacity:!1===i?0:1},void 0,function(){i||t.hide()}),e.visible=i}drawDataLabels(){this.options.dataLabels&&(this.options.dataLabels=splat(this.options.dataLabels),this.drawNodeLabels(this.points),seriesProto.drawDataLabels.call(this,this.links))}destroy(){if(this.links){for(const e of this.links)e.destroy();this.links.length=0}return seriesProto.destroy.apply(this,arguments)}pointAttribs(e,t){var i=this,s=e&&i.mapOptionsToLevel[e.node.level||0]||{},o=e&&e.options,r=s.states&&s.states[t]||{};e&&(e.options.marker=merge(i.options.marker,s.marker,e.options.marker));const a=pick(r&&r.link&&r.link.color,o&&o.link&&o.link.color,s&&s.link&&s.link.color,i.options.link&&i.options.link.color),l=pick(r&&r.link&&r.link.lineWidth,o&&o.link&&o.link.lineWidth,s&&s.link&&s.link.lineWidth,i.options.link&&i.options.link.lineWidth),n=seriesProto.pointAttribs.call(i,e,t);return e&&(e.isLink&&(n.stroke=a,n["stroke-width"]=l,delete n.fill),e.visible||(n.opacity=0)),n}drawPoints(){TreemapSeries.prototype.drawPoints.apply(this,arguments),ColumnSeries.prototype.drawPoints.call(this,this.links)}translateNode(e){const t=this.chart,i=e.node,s=t.plotSizeY,o=t.plotSizeX,{ax:r,bx:a,ay:l,by:n}=this.layoutModifier,p=r*i.xPosition+a,h=l*i.yPosition+n,d=this.mapOptionsToLevel[i.level]||{},g=merge(this.options.marker,d.marker,e.options.marker),c=g.symbol,k=i.nodeSizeY,m=i.nodeSizeX,y=this.options.reversed,v=i.x=t.inverted?o-m/2-p:p-m/2,T=i.y=y?h-k/2:s-h-k/2,u=pick(e.options.borderRadius,d.borderRadius,this.options.borderRadius),L=symbols[c||"circle"];if(void 0===L?(e.hasImage=!0,e.shapeType="image",e.imageUrl=c.match(/^url\((.*?)\)$/)[1]):e.shapeType="path",!e.visible&&e.linkToParent){var f=e.linkToParent.fromNode;if(f){const P=f.shapeArgs||{},{x:p=0,y:h=0,width:m=0,height:k=0}=P;e.shapeArgs||(e.shapeArgs={}),e.hasImage||extend(e.shapeArgs,{d:L(p,h,m,k,u?{r:u}:void 0)}),extend(e.shapeArgs,{x:p,y:h}),e.plotX=f.plotX,e.plotY=f.plotY}}else e.plotX=v,e.plotY=T,e.shapeArgs={x:v,y:T,width:m,height:k,cursor:e.node.isLeaf?"default":"pointer"},e.hasImage||(e.shapeArgs.d=L(v,T,m,k,u?{r:u}:void 0));e.tooltipPos=t.inverted?[s-T-k/2,o-v-m/2]:[v+m/2,T]}}TreegraphSeries.defaultOptions=merge(TreemapSeries.defaultOptions,TreegraphSeriesDefaults),extend(TreegraphSeries.prototype,{pointClass:TreegraphPoint,NodeClass:TreegraphNode,LinkClass:TreegraphLink}),SeriesRegistry.registerSeriesType("treegraph",TreegraphSeries);export default TreegraphSeries;