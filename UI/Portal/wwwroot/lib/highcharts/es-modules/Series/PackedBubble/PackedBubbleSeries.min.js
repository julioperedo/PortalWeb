"use strict";import Color from"../../Core/Color/Color.js";const color=Color["parse"];import DragNodesComposition from"../DragNodesComposition.js";import GraphLayout from"../GraphLayoutComposition.js";import H from"../../Core/Globals.js";const noop=H["noop"];import PackedBubblePoint from"./PackedBubblePoint.js";import PackedBubbleSeriesDefaults from"./PackedBubbleSeriesDefaults.js";import PackedBubbleLayout from"./PackedBubbleLayout.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{series:{prototype:seriesProto},seriesTypes:{bubble:BubbleSeries}}=SeriesRegistry;import D from"../SimulationSeriesUtilities.js";const{initDataLabels,initDataLabelsDefer}=D;import U from"../../Core/Utilities.js";const{addEvent,clamp,defined,extend,fireEvent,isArray,isNumber,merge,pick,syncTimeout}=U;import A from"../../Core/Animation/AnimationUtilities.js";const animObject=A["animObject"];class PackedBubbleSeries extends BubbleSeries{constructor(){super(...arguments),this.chart=void 0,this.data=void 0,this.layout=void 0,this.options=void 0,this.parentNodeMass=0,this.points=void 0,this.xData=void 0,this.deferDataLabels=!0}static compose(t,e,o,a){BubbleSeries.compose(t,e,o,a),DragNodesComposition.compose(e),PackedBubbleLayout.compose(e)}accumulateAllPoints(){const t=this.chart,e=[];var o;for(const a of t.series)if(a.is("packedbubble")&&a.reserveSpace()){o=a.yData||[];for(let t=0;t<o.length;t++)e.push([null,null,o[t],a.index,t,{id:t,marker:{radius:0}}])}return e}addLayout(){const t=this.options.layoutAlgorithm=this.options.layoutAlgorithm||{},e=t.type||"packedbubble",o=this.chart.options.chart;let a=this.chart.graphLayoutsStorage,i=this.chart.graphLayoutsLookup,s;a||(this.chart.graphLayoutsStorage=a={},this.chart.graphLayoutsLookup=i=[]),(s=a[e])||(t.enableSimulation=defined(o.forExport)?!o.forExport:t.enableSimulation,a[e]=s=new GraphLayout.layouts[e],s.init(t),i.splice(s.index,0,s)),this.layout=s,this.points.forEach(t=>{t.mass=2,t.degree=1,t.collisionNmb=1}),s.setArea(0,0,this.chart.plotWidth,this.chart.plotHeight),s.addElementsToCollection([this],s.series),s.addElementsToCollection(this.points,s.nodes)}addSeriesLayout(){const t=this.options.layoutAlgorithm=this.options.layoutAlgorithm||{},e=t.type||"packedbubble",o=this.chart.graphLayoutsStorage,a=this.chart.graphLayoutsLookup,i=merge(t,t.parentNodeOptions,{enableSimulation:this.layout.options.enableSimulation});let s=o[e+"-series"];s||(o[e+"-series"]=s=new GraphLayout.layouts[e],s.init(i),a.splice(s.index,0,s)),this.parentNodeLayout=s,this.createParentNodes()}calculateParentRadius(){var t=this.seriesBox();this.parentNodeRadius=clamp(Math.sqrt(2*this.parentNodeMass/Math.PI)+20,20,t?Math.max(Math.sqrt(Math.pow(t.width,2)+Math.pow(t.height,2))/2+20,20):Math.sqrt(2*this.parentNodeMass/Math.PI)+20),this.parentNode&&(this.parentNode.marker.radius=this.parentNode.radius=this.parentNodeRadius)}calculateZExtremes(){const t=this.chart,e=t.series;let o=this.options.zMin,a=this.options.zMax,i=1/0,s=-1/0;return o&&a||(e.forEach(t=>{t.yData.forEach(t=>{defined(t)&&(t>s&&(s=t),t<i&&(i=t))})}),o=pick(o,i),a=pick(a,s)),[o,a]}checkOverlap(t,e){var o=t[0]-e[0],a=t[1]-e[1],t=t[2]+e[2];return Math.sqrt(o*o+a*a)-Math.abs(t)<-.001}createParentNodes(){const t=this.pointClass,e=this.chart,o=this.parentNodeLayout,a=this.layout.options;let i,s=this.parentNode,r={radius:this.parentNodeRadius,lineColor:this.color,fillColor:color(this.color).brighten(.4).get()};a.parentNodeOptions&&(r=merge(a.parentNodeOptions.marker||{},r)),this.parentNodeMass=0,this.points.forEach(t=>{this.parentNodeMass+=Math.PI*Math.pow(t.marker.radius,2)}),this.calculateParentRadius(),o.nodes.forEach(t=>{t.seriesIndex===this.index&&(i=!0)}),o.setArea(0,0,e.plotWidth,e.plotHeight),i||(s=s||(new t).init(this,{mass:this.parentNodeRadius/2,marker:r,dataLabels:{inside:!1},states:{normal:{marker:r},hover:{marker:r}},dataLabelOnNull:!0,degree:this.parentNodeRadius,isParentNode:!0,seriesIndex:this.index}),this.parentNode&&(s.plotX=this.parentNode.plotX,s.plotY=this.parentNode.plotY),this.parentNode=s,o.addElementsToCollection([this],o.series),o.addElementsToCollection([s],o.nodes))}deferLayout(){var t=this.options.layoutAlgorithm;this.visible&&(this.addLayout(),t.splitSeries&&this.addSeriesLayout())}destroy(){this.chart.graphLayoutsLookup&&this.chart.graphLayoutsLookup.forEach(t=>{t.removeElementFromCollection(this,t.series)},this),this.parentNode&&this.parentNodeLayout&&(this.parentNodeLayout.removeElementFromCollection(this.parentNode,this.parentNodeLayout.nodes),this.parentNode.dataLabel&&(this.parentNode.dataLabel=this.parentNode.dataLabel.destroy())),seriesProto.destroy.apply(this,arguments)}drawDataLabels(){this.deferDataLabels||(seriesProto.drawDataLabels.call(this,this.points),this.parentNode&&(this.parentNode.formatPrefix="parentNode",seriesProto.drawDataLabels.call(this,[this.parentNode])))}drawGraph(){if(this.layout&&this.layout.options.splitSeries){const e=this.chart,o=this.layout.options.parentNodeOptions.marker,a={fill:o.fillColor||color(this.color).brighten(.4).get(),opacity:o.fillOpacity,stroke:o.lineColor||this.color,"stroke-width":pick(o.lineWidth,this.options.lineWidth)};var t;this.parentNodesGroup=this.plotGroup("parentNodesGroup","parentNode",this.visible?"inherit":"hidden",.1,e.seriesGroup),this.group?.attr({zIndex:2}),this.calculateParentRadius(),this.parentNode&&defined(this.parentNode.plotX)&&defined(this.parentNode.plotY)&&defined(this.parentNodeRadius)&&(t=merge({x:this.parentNode.plotX-this.parentNodeRadius,y:this.parentNode.plotY-this.parentNodeRadius,width:2*this.parentNodeRadius,height:2*this.parentNodeRadius},a),this.parentNode.graphic||(this.graph=this.parentNode.graphic=e.renderer.symbol(a.symbol).add(this.parentNodesGroup)),this.parentNode.graphic.attr(t))}}drawTracker(){const e=this.parentNode;let t;super.drawTracker(),e&&(t=isArray(e.dataLabels)?e.dataLabels:e.dataLabel?[e.dataLabel]:[],e.graphic&&(e.graphic.element.point=e),t.forEach(t=>{t.div?t.div.point=e:t.element.point=e}))}getPointRadius(){const t=this.chart,e=t.plotWidth,o=t.plotHeight,a=this.options,i=a.useSimulation,s=Math.min(e,o),r={},n=[],l=t.allDataPoints||[],h=l.length;let p,d,u,c;["minSize","maxSize"].forEach(t=>{var e=parseInt(a[t],10),o=/%$/.test(a[t]);r[t]=o?s*e/100:e*Math.sqrt(h)}),t.minRadius=p=r.minSize/Math.sqrt(h),t.maxRadius=d=r.maxSize/Math.sqrt(h);const m=i?this.calculateZExtremes():[p,d];l.forEach((t,e)=>{u=i?clamp(t[2],m[0],m[1]):t[2],0===(c=this.getRadius(m[0],m[1],p,d,u))&&(c=null),l[e][2]=c,n.push(c)}),this.radii=n}init(){return seriesProto.init.apply(this,arguments),initDataLabelsDefer.call(this),this.eventsToUnbind.push(addEvent(this,"updatedData",function(){this.chart.series.forEach(t=>{t.type===this.type&&(t.isDirty=!0)},this)})),this}onMouseUp(t){const a=t;if(a.fixedPosition&&!a.removed){const i=this.layout,s=this.parentNodeLayout;let e,o;s&&i.options.dragBetweenSeries&&s.nodes.forEach(t=>{a&&a.marker&&t!==a.series.parentNode&&(e=i.getDistXY(a,t),(o=i.vectorLength(e)-t.marker.radius-a.marker.radius)<0&&(t.series.addPoint(merge(a.options,{plotX:a.plotX,plotY:a.plotY}),!1),i.removeElementFromCollection(a,i.nodes),a.remove()))}),DragNodesComposition.onMouseUp.apply(this,arguments)}}placeBubbles(t){const e=this.checkOverlap,o=this.positionBubble,a=[];let i=1,s=0,r=0,n,l=[],h;const p=t.sort((t,e)=>e[2]-t[2]);if(p.length){if(a.push([[0,0,p[0][2],p[0][3],p[0][4]]]),1<p.length)for(a.push([[0,0-p[1][2]-p[0][2],p[1][2],p[1][3],p[1][4]]]),h=2;h<p.length;h++)p[h][2]=p[h][2]||1,n=o(a[i][s],a[i-1][r],p[h]),e(n,a[i][0])?(a.push([]),r=0,a[i+1].push(o(a[i][s],a[i][0],p[h])),i++,s=0):1<i&&a[i-1][r+1]&&e(n,a[i-1][r+1])?(r++,a[i].push(o(a[i][s],a[i-1][r],p[h])),s++):(s++,a[i].push(n));this.chart.stages=a,this.chart.rawPositions=[].concat.apply([],a),this.resizeRadius(),l=this.chart.rawPositions}return l}pointAttribs(t,e){var o=this.options,a=t&&t.isParentNode;let i=o.marker;const s=(i=a&&o.layoutAlgorithm&&o.layoutAlgorithm.parentNodeOptions?o.layoutAlgorithm.parentNodeOptions.marker:i).fillOpacity,r=seriesProto.pointAttribs.call(this,t,e);return 1!==s&&(r["fill-opacity"]=s),r}positionBubble(t,e,o){const a=Math.sqrt,i=Math.asin,s=Math.acos,r=Math.pow,n=Math.abs,l=a(r(t[0]-e[0],2)+r(t[1]-e[1],2)),h=s((r(l,2)+r(o[2]+e[2],2)-r(o[2]+t[2],2))/(2*(o[2]+e[2])*l)),p=i(n(t[0]-e[0])/l),d=t[1]-e[1]<0?0:Math.PI,u=(t[0]-e[0])*(t[1]-e[1])<0?1:-1,c=d+h+p*u,m=Math.cos(c),b=Math.sin(c),y=e[0]+(e[2]+o[2])*b,N=e[1]-(e[2]+o[2])*m;return[y,N,o[2],o[3],o[4]]}render(){const e=[];seriesProto.render.apply(this,arguments),this.options.dataLabels.allowOverlap||(this.data.forEach(t=>{isArray(t.dataLabels)&&t.dataLabels.forEach(t=>{e.push(t)})}),this.options.useSimulation&&this.chart.hideOverlappingLabels(e))}resizeRadius(){const t=this.chart,e=t.rawPositions,o=Math.min,a=Math.max,i=t.plotLeft,s=t.plotTop,r=t.plotHeight,n=t.plotWidth;let l,h,p,d,u;l=p=Number.POSITIVE_INFINITY,h=d=Number.NEGATIVE_INFINITY;for(const b of e)u=b[2],l=o(l,b[0]-u),h=a(h,b[0]+u),p=o(p,b[1]-u),d=a(d,b[1]+u);var c=[h-l,d-p],m=o.apply([],[(n-i)/c[0],(r-s)/c[1]]);if(1e-10<Math.abs(m-1)){for(const y of e)y[2]*=m;this.placeBubbles(e)}else t.diffY=r/2+s-p-(d-p)/2,t.diffX=n/2+i-l-(h-l)/2}seriesBox(){const t=this.chart,e=this.data,o=Math.max,a=Math.min,i=[t.plotLeft,t.plotLeft+t.plotWidth,t.plotTop,t.plotTop+t.plotHeight];let s;return e.forEach(t=>{defined(t.plotX)&&defined(t.plotY)&&t.marker.radius&&(s=t.marker.radius,i[0]=a(i[0],t.plotX-s),i[1]=o(i[1],t.plotX+s),i[2]=a(i[2],t.plotY-s),i[3]=o(i[3],t.plotY+s))}),isNumber(i.width/i.height)?i:null}setVisible(){const e=this;seriesProto.setVisible.apply(e,arguments),e.parentNodeLayout&&e.graph?e.visible?(e.graph.show(),e.parentNode.dataLabel&&e.parentNode.dataLabel.show()):(e.graph.hide(),e.parentNodeLayout.removeElementFromCollection(e.parentNode,e.parentNodeLayout.nodes),e.parentNode.dataLabel&&e.parentNode.dataLabel.hide()):e.layout&&(e.visible?e.layout.addElementsToCollection(e.points,e.layout.nodes):e.points.forEach(t=>{e.layout.removeElementFromCollection(t,e.layout.nodes)}))}translate(){const t=this.chart,e=this.data,o=this.index,a=this.options.useSimulation;let i,s,r;this.processedXData=this.xData,this.generatePoints(),defined(t.allDataPoints)||(t.allDataPoints=this.accumulateAllPoints(),this.getPointRadius()),a?r=t.allDataPoints:(r=this.placeBubbles(t.allDataPoints),this.options.draggable=!1);for(const n of r)n[3]===o&&(i=e[n[4]],s=pick(n[2],void 0),a||(i.plotX=n[0]-t.plotLeft+t.diffX,i.plotY=n[1]-t.plotTop+t.diffY),isNumber(s)&&(i.marker=extend(i.marker,{radius:s,width:2*s,height:2*s}),i.radius=s));a&&this.deferLayout(),fireEvent(this,"afterTranslate")}}PackedBubbleSeries.defaultOptions=merge(BubbleSeries.defaultOptions,PackedBubbleSeriesDefaults),extend(PackedBubbleSeries.prototype,{pointClass:PackedBubblePoint,axisTypes:[],directTouch:!0,forces:["barycenter","repulsive"],hasDraggableNodes:!0,isCartesian:!1,noSharedTooltip:!0,pointArrayMap:["value"],pointValKey:"value",requireSorting:!1,trackerGroups:["group","dataLabelsGroup","parentNodesGroup"],initDataLabels:initDataLabels,alignDataLabel:seriesProto.alignDataLabel,indexateNodes:noop,onMouseDown:DragNodesComposition.onMouseDown,onMouseMove:DragNodesComposition.onMouseMove,redrawHalo:DragNodesComposition.redrawHalo,searchPoint:noop}),SeriesRegistry.registerSeriesType("packedbubble",PackedBubbleSeries);export default PackedBubbleSeries;