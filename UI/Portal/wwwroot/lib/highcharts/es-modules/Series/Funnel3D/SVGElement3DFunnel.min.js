"use strict";import Color from"../../Core/Color/Color.js";const color=Color["parse"];import H from"../../Core/Globals.js";const charts=H["charts"];import RendererRegistry from"../../Core/Renderer/RendererRegistry.js";const SVGElement3D=RendererRegistry.getRendererType().prototype["Element3D"];import U from"../../Core/Utilities.js";const merge=U["merge"];class SVGElement3DFunnel extends SVGElement3D{constructor(){super(...arguments),this.mainParts=["top","bottom"],this.parts=["top","bottom","frontUpper","backUpper","frontLower","backLower","rightUpper","rightLower"],this.sideGroups=["upperGroup","lowerGroup"],this.sideParts={upperGroup:["frontUpper","backUpper","rightUpper"],lowerGroup:["frontLower","backLower","rightLower"]},this.pathType="funnel3d"}opacitySetter(e,r,t){const o=this,i=parseFloat(e),n=o.parts,s=charts[o.renderer.chartIndex],a="group-opacity-"+i+"-"+s.index;if(o.parts=o.mainParts,o.singleSetterForParts("opacity",i),o.parts=n,!s.renderer.filterId){s.renderer.definition({tagName:"filter",attributes:{id:a},children:[{tagName:"feComponentTransfer",children:[{tagName:"feFuncA",attributes:{type:"table",tableValues:"0 "+i}}]}]});for(const d of o.sideGroups)o[d].attr({filter:"url(#"+a+")"});if(o.renderer.styledMode){s.renderer.definition({tagName:"style",textContent:".highcharts-"+a+" {filter:url(#"+a+")}"});for(const p of o.sideGroups)o[p].addClass("highcharts-"+a)}}return o}fillSetter(e){let r=color(e);const t=this,o=r.rgba[3],i={top:color(e).brighten(.1).get(),bottom:color(e).brighten(-.2).get()};if(o<1?(r.rgba[3]=1,r=r.get("rgb"),t.attr({opacity:o})):r=e,(r=r.linearGradient||r.radialGradient||!t.gradientForSides?r:{linearGradient:{x1:0,x2:1,y1:1,y2:1},stops:[[0,color(e).brighten(-.2).get()],[.5,e],[1,color(e).brighten(-.2).get()]]}).linearGradient)for(const f of t.sideGroups){var n=t[f].gradientBox,s=r.linearGradient,a=merge(r,{linearGradient:{x1:n.x+s.x1*n.width,y1:n.y+s.y1*n.height,x2:n.x+s.x2*n.width,y2:n.y+s.y2*n.height}});for(const c of t.sideParts[f])i[c]=a}else if(merge(!0,i,{frontUpper:r,backUpper:r,rightUpper:r,frontLower:r,backLower:r,rightLower:r}),r.radialGradient)for(const g of t.sideGroups){var d=t[g].gradientBox,p=d.x+d.width/2,l=d.y+d.height/2,h=Math.min(d.width,d.height);for(const u of t.sideParts[g])t[u].setRadialReference([p,l,h])}if(t.singleSetterForParts("fill",null,i),t.color=t.fill=e,r.linearGradient)for(const m of[t.frontLower,t.frontUpper]){const y=m.element,x=y&&t.renderer.gradients[y.gradient];x&&"userSpaceOnUse"!==x.attr("gradientUnits")&&x.attr({gradientUnits:"userSpaceOnUse"})}return t}adjustForGradient(){var t,o=this;for(const i of o.sideGroups){let e={x:Number.MAX_VALUE,y:Number.MAX_VALUE},r={x:-Number.MAX_VALUE,y:-Number.MAX_VALUE};for(const n of o.sideParts[i]){const s=o[n];t=s.getBBox(!0),e={x:Math.min(e.x,t.x),y:Math.min(e.y,t.y)},r={x:Math.max(r.x,t.x+t.width),y:Math.max(r.y,t.y+t.height)}}o[i].gradientBox={x:e.x,width:r.x-e.x,y:e.y,height:r.y-e.y}}}zIndexSetter(){return this.finishedOnAdd&&this.adjustForGradient(),this.renderer.Element.prototype.zIndexSetter.apply(this,arguments)}onAdd(){this.adjustForGradient(),this.finishedOnAdd=!0}}export default SVGElement3DFunnel;