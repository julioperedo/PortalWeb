"use strict";import CandlestickSeriesDefaults from"./CandlestickSeriesDefaults.js";import D from"../../Core/Defaults.js";const defaultOptions=D["defaultOptions"];import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{column:ColumnSeries,ohlc:OHLCSeries}=SeriesRegistry.seriesTypes;import U from"../../Core/Utilities.js";const merge=U["merge"];class CandlestickSeries extends OHLCSeries{constructor(){super(...arguments),this.data=void 0,this.options=void 0,this.points=void 0}pointAttribs(t,e){const o=ColumnSeries.prototype.pointAttribs.call(this,t,e),s=this.options,i=t.open<t.close,r=s.lineColor||this.color,l=t.color||this.color;return o["stroke-width"]=s.lineWidth,o.fill=t.options.color||i&&s.upColor||l,o.stroke=t.options.lineColor||i&&s.upLineColor||r,e&&(t=s.states[e],o.fill=t.color||o.fill,o.stroke=t.lineColor||o.stroke,o["stroke-width"]=t.lineWidth||o["stroke-width"]),o}drawPoints(){const h=this,t=h.points,c=h.chart,u=h.yAxis.reversed;for(const m of t){let t=m.graphic,e,o,s,i,r,l,n,a,d,p;var C=!t;void 0!==m.plotY&&(t||(m.graphic=t=c.renderer.path().add(h.group)),h.chart.styledMode||t.attr(h.pointAttribs(m,m.selected&&"select")).shadow(h.options.shadow),n=t.strokeWidth()%2/2,a=Math.round(m.plotX)-n,e=m.plotOpen,o=m.plotClose,s=Math.min(e,o),i=Math.max(e,o),p=Math.round(m.shapeArgs.width/2),r=u?i!==m.yBottom:Math.round(s)!==Math.round(m.plotHigh),l=u?Math.round(s)!==Math.round(m.plotHigh):i!==m.yBottom,s=Math.round(s)+n,i=Math.round(i)+n,(d=[]).push(["M",a-p,i],["L",a-p,s],["L",a+p,s],["L",a+p,i],["Z"],["M",a,s],["L",a,r?Math.round(u?m.yBottom:m.plotHigh):s],["M",a,i],["L",a,l?Math.round(u?m.plotHigh:m.yBottom):i]),t[C?"attr":"animate"]({d:d}).addClass(m.getClassName(),!0))}}}CandlestickSeries.defaultOptions=merge(OHLCSeries.defaultOptions,defaultOptions.plotOptions,{tooltip:OHLCSeries.defaultOptions.tooltip},CandlestickSeriesDefaults),SeriesRegistry.registerSeriesType("candlestick",CandlestickSeries);export default CandlestickSeries;