"use strict";import ItemPoint from"./ItemPoint.js";import ItemSeriesDefaults from"./ItemSeriesDefaults.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const PieSeries=SeriesRegistry.seriesTypes["pie"];import U from"../../Core/Utilities.js";const{defined,extend,fireEvent,isNumber,merge,pick}=U;class ItemSeries extends PieSeries{constructor(){super(...arguments),this.data=void 0,this.options=void 0,this.points=void 0}animate(t){const e=this.group;e&&(t?e.attr({opacity:0}):e.animate({opacity:1},this.options.animation))}drawDataLabels(){if(this.center&&this.slots)super.drawDataLabels();else for(const t of this.points)t.destroyElements({dataLabel:1})}drawPoints(){const h=this,d=this.options,c=h.chart.renderer,t=d.marker,e=this.borderWidth,p=e%2?.5:1,g=this.getRows(),m=Math.ceil(this.total/g),f=this.chart.plotWidth/m,u=this.chart.plotHeight/g,S=this.itemSize||Math.min(f,u);let y=0;for(const R of h.points){var M,v=R.marker||{},b=v.symbol||t.symbol,w=pick(v.radius,t.radius),A=defined(w)?2*w:S,I=A*d.itemPadding;let s,i,o,r,a,n,l;if(R.graphics=i=R.graphics||[],h.chart.styledMode||(o=h.pointAttribs(R,R.selected&&"select")),!R.isNull&&R.visible){R.graphic||(R.graphic=c.g("point").add(h.group));for(let e=0;e<(R.y||0);++e){a=h.center&&h.slots?(M=h.slots.shift(),r=M.x-S/2,M.y-S/2):"horizontal"===d.layout?(r=f*(y%m),u*Math.floor(y/m)):(r=f*Math.floor(y/g),u*(y%g)),r+=I,a+=I,l=n=Math.round(A-2*I),h.options.crisp&&(r=Math.round(r)-p,a=Math.round(a)+p),s={x:r,y:a,width:n,height:l},void 0!==w&&(s.r=w),o&&extend(s,o);let t=i[e];t?t.animate(s):t=c.symbol(b,void 0,void 0,void 0,void 0,{backgroundSize:"within"}).attr(s).add(R.graphic),t.isActive=!0,i[e]=t,++y}}for(let t=0;t<i.length;t++){const P=i[t];if(!P)return;P.isActive?P.isActive=!1:(P.destroy(),i.splice(t,1),t--)}}}getRows(){var t=this.chart,e=this.total||0;let s=this.options.rows,i,o;if(!s)if(o=t.plotWidth/t.plotHeight,s=Math.sqrt(e),1<o)for(s=Math.ceil(s);0<s&&!((i=e/s)/s>o);)s--;else for(s=Math.floor(s);s<e&&!((i=e/s)/s<o);)s++;return s}getSlots(){const t=this,s=t.center,e=s[2],i=t.slots=t.slots||[],o=t.endAngleRad-t.startAngleRad,r=t.options.rows,a=o%(2*Math.PI)==0,n=t.total||0;let l=s[3],h,d,c,p,g,m,f,u,S=0,y,M=Number.MAX_VALUE,v,b,w,A=(e-l)/e;for(;M>n+(b&&a?b.length:0);){v=M,i.length=0,M=0,b=w,w=[],S++,y=e/S/2,r?0<=(l=(y-r)/y*e)?y=r:(l=0,A=1):y=Math.floor(y*A);for(let t=y;0<t;t--)p=o*(c=(l+t/y*(e-l-S))/2),g=Math.ceil(p/S),w.push({rowRadius:c,rowLength:p,colCount:g}),M+=g+1}if(b){let e=v-t.total-(a?b.length:0);for(var I=t=>{0<e&&(t.row.colCount--,e--)};0<e;)b.map(t=>({angle:t.colCount/t.rowLength,row:t})).sort((t,e)=>e.angle-t.angle).slice(0,Math.min(e,Math.ceil(b.length/2))).forEach(I);for(const R of b){const c=R.rowRadius,g=R.colCount;for(m=g?o/g:0,u=0;u<=g;u+=1)f=t.startAngleRad+u*m,h=s[0]+Math.cos(f)*c,d=s[1]+Math.sin(f)*c,i.push({x:h,y:d,angle:f})}return i.sort((t,e)=>t.angle-e.angle),t.itemSize=S,i}}translate(t){0===this.total&&isNumber(this.options.startAngle)&&isNumber(this.options.endAngle)&&(this.center=this.getCenter()),this.slots||(this.slots=[]),isNumber(this.options.startAngle)&&isNumber(this.options.endAngle)?(super.translate(t),this.slots=this.getSlots()):(this.generatePoints(),fireEvent(this,"afterTranslate"))}}ItemSeries.defaultOptions=merge(PieSeries.defaultOptions,ItemSeriesDefaults),extend(ItemSeries.prototype,{markerAttribs:void 0,pointClass:ItemPoint}),SeriesRegistry.registerSeriesType("item",ItemSeries);export default ItemSeries;