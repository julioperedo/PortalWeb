"use strict";import CU from"../../Core/Geometry/CircleUtilities.js";const{getAreaOfCircle,getCircleCircleIntersection,getOverlapBetweenCircles:getOverlapBetweenCirclesByDistance,isPointInsideAllCircles,isPointInsideCircle,isPointOutsideAllCircles}=CU;import GU from"../../Core/Geometry/GeometryUtilities.js";const getDistanceBetweenPoints=GU["getDistanceBetweenPoints"];import U from"../../Core/Utilities.js";const{extend,isArray,isNumber,isObject,isString}=U;function addOverlapToSets(e){const s={};return e.filter(e=>2===e.sets.length).forEach(n=>{n.sets.forEach((e,t,r)=>{isObject(s[e])||(s[e]={totalOverlap:0,overlapping:{}}),s[e]={totalOverlap:(s[e].totalOverlap||0)+n.value,overlapping:{...s[e].overlapping||{},[r[1-t]]:n.value}}})}),e.filter(isSet).forEach(e=>{var t=s[e.sets[0]];extend(e,t)}),e}function bisect(e,t,r,n,s){let i=e(t),o=e(r),l=s||100,a=n||1e-10,c=r-t,u=1,f,d;if(r<=t)throw new Error("a must be smaller than b.");if(0<i*o)throw new Error("f(a) and f(b) must have opposite signs.");if(0===i)f=t;else if(0===o)f=r;else for(;u++<=l&&0!==d&&c>a;)c=(r-t)/2,f=t+c,0<i*(d=e(f))?t=f:r=f;return f}function getCentroid(e){const t=e.slice(0,-1),r=t.length,n=[],s=(e,t)=>(e.sum+=t[e.i],e);for(let e=0;e<r;e++)n[e]=t.reduce(s,{sum:0,i:e}).sum/r;return n}function getDistanceBetweenCirclesByOverlap(t,r,n){let e=t+r,s;return s=n<=0?e:getAreaOfCircle(t<r?t:r)<=n?0:bisect(e=>{e=getOverlapBetweenCirclesByDistance(t,r,e);return n-e},0,e)}function getLabelWidth(s,i,e){const t=i.reduce((e,t)=>Math.min(t.r,e),1/0),o=e.filter(e=>!isPointInsideCircle(s,e));function r(r,n){return bisect(e=>{var t={x:s.x+n*e,y:s.y},t=isPointInsideAllCircles(t,i)&&isPointOutsideAllCircles(t,o);return-(r-e)+(t?0:Number.MAX_VALUE)},0,r)}return 2*Math.min(r(t,-1),r(t,1))}function getMarginFromCircles(r,e,t){e=e.reduce((e,t)=>{t=t.r-getDistanceBetweenPoints(r,t);return t<=e?t:e},Number.MAX_VALUE);return t.reduce((e,t)=>{t=getDistanceBetweenPoints(r,t)-t.r;return t<=e?t:e},e)}function getOverlapBetweenCircles(e){let t=0;var r;return 2===e.length&&(r=e[0],e=e[1],t=getOverlapBetweenCirclesByDistance(r.r,e.r,getDistanceBetweenPoints(r,e))),t}function isSet(e){return isArray(e.sets)&&1===e.sets.length}function isValidRelation(e){const r={};return isObject(e)&&isNumber(e.value)&&-1<e.value&&isArray(e.sets)&&0<e.sets.length&&!e.sets.some(function(e){let t=!1;return!r[e]&&isString(e)?r[e]=!0:t=!0,t})}function isValidSet(e){return isValidRelation(e)&&isSet(e)&&0<e.value}function layoutGreedyVenn(e){const f=[],d={};e.filter(e=>1===e.sets.length).forEach(e=>{d[e.sets[0]]=e.circle={x:Number.MAX_VALUE,y:Number.MAX_VALUE,r:Math.sqrt(e.value/Math.PI)}});var t=(e,t)=>{const r=e.circle;r&&(r.x=t.x,r.y=t.y),f.push(e)};addOverlapToSets(e);const r=e.filter(isSet).sort(sortByTotalOverlap),v=(t(r.shift(),{x:0,y:0}),e.filter(e=>2===e.sets.length));for(const s of r){const g=s.circle;if(g){const p=g.r,y=s.overlapping;var n=f.reduce((e,t,r)=>{var n=t.circle;if(!n||!y)return e;var t=y[t.sets[0]],s=getDistanceBetweenCirclesByOverlap(p,n.r,t);let i=[{x:n.x+s,y:n.y},{x:n.x-s,y:n.y},{x:n.x,y:n.y+s},{x:n.x,y:n.y-s}];for(const c of f.slice(r+1)){var o=c.circle,l=y[c.sets[0]];o&&(l=getDistanceBetweenCirclesByOverlap(p,o.r,l),i=i.concat(getCircleCircleIntersection({x:n.x,y:n.y,r:s},{x:o.x,y:o.y,r:l})))}for(const u of i){g.x=u.x,g.y=u.y;var a=loss(d,v);a<e.loss&&(e.loss=a,e.coordinates=u)}return e},{loss:Number.MAX_VALUE,coordinates:void 0});t(s,n.coordinates)}}return d}function loss(n,e){return e.reduce(function(e,t){let r=0;return 1<t.sets.length&&(t=t.value-getOverlapBetweenCircles(t.sets.map(function(e){return n[e]})),r=Math.round(t*t*1e11)/1e11),e+r},0)}function nelderMead(i,e){function t(e,t){return e.fx-t.fx}const o=(r,e,n,s)=>e.map((e,t)=>r*e+n*s[t]);var r=(e,t)=>(t.fx=i(t),e[e.length-1]=t,e),n=e=>{const r=e[0];return e.map(e=>{const t=o(.5,r,.5,e);return t.fx=i(t),t})},s=(e,t,r,n)=>{const s=o(r,e,n,t);return s.fx=i(s),s};let l=(t=>{const r=t.length,n=new Array(r+1);n[0]=t,n[0].fx=i(t);for(let e=0;e<r;++e){const s=t.slice();s[e]=s[e]?1.05*s[e]:.001,s.fx=i(s),n[e+1]=s}return n})(e);for(let e=0;e<100;e++){l.sort(t);var a=l[l.length-1],c=getCentroid(l),u=s(c,a,2,-1);if(u.fx<l[0].fx){var f=s(c,a,3,-2);l=r(l,f.fx<u.fx?f:u)}else if(u.fx>=l[l.length-2].fx){let e;l=u.fx>a.fx?(e=s(c,a,.5,.5)).fx<a.fx?r(l,e):n(l):(e=s(c,a,1.5,-.5)).fx<u.fx?r(l,e):n(l)}else l=r(l,u)}return l[0]}function processVennData(e,i){const t=isArray(e)?e:[],r=t.reduce(function(e,t){return t.sets&&isValidSet(t)&&-1===e.indexOf(t.sets[0])&&e.push(t.sets[0]),e},[]).sort(),n=t.reduce(function(e,t){return t.sets&&isValidRelation(t)&&!t.sets.some(function(e){return-1===r.indexOf(e)})&&(e[t.sets.sort().join(i)]={sets:t.sets,value:t.value||0}),e},{});return r.reduce(function(t,r,e,n){const s=n.slice(e+1);return s.forEach(function(e){t.push(r+i+e)}),t},[]).forEach(function(e){var t;n[e]||(t={sets:e.split(i),value:0},n[e]=t)}),Object.keys(n).map(function(e){return n[e]})}function sortByTotalOverlap(e,t){return void 0!==t.totalOverlap&&void 0!==e.totalOverlap?t.totalOverlap-e.totalOverlap:NaN}const VennUtils={geometry:GU,geometryCircles:CU,addOverlapToSets:addOverlapToSets,getCentroid:getCentroid,getDistanceBetweenCirclesByOverlap:getDistanceBetweenCirclesByOverlap,getLabelWidth:getLabelWidth,getMarginFromCircles:getMarginFromCircles,isSet:isSet,layoutGreedyVenn:layoutGreedyVenn,loss:loss,nelderMead:nelderMead,processVennData:processVennData,sortByTotalOverlap:sortByTotalOverlap};export default VennUtils;