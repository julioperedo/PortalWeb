"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const animObject=A["animObject"];import Color from"../../Core/Color/Color.js";const color=Color["parse"];import CU from"../../Core/Geometry/CircleUtilities.js";const{getAreaOfIntersectionBetweenCircles,getCirclesIntersectionPolygon,isCircle1CompletelyOverlappingCircle2,isPointInsideAllCircles,isPointOutsideAllCircles}=CU;import DPU from"../DrawPointUtilities.js";import GU from"../../Core/Geometry/GeometryUtilities.js";const getCenterOfPoints=GU["getCenterOfPoints"];import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const ScatterSeries=SeriesRegistry.seriesTypes["scatter"];import VennPoint from"./VennPoint.js";import VennSeriesDefaults from"./VennSeriesDefaults.js";import VennUtils from"./VennUtils.js";import U from"../../Core/Utilities.js";const{addEvent,extend,isArray,isNumber,isObject,merge}=U;class VennSeries extends ScatterSeries{constructor(){super(...arguments),this.data=void 0,this.mapOfIdToRelation=void 0,this.options=void 0,this.points=void 0}static getLabelPosition(r,s){let e=r.reduce((e,t)=>{var i=t.r/2;return[{x:t.x,y:t.y},{x:t.x+i,y:t.y},{x:t.x-i,y:t.y},{x:t.x,y:t.y+i},{x:t.x,y:t.y-i}].reduce((e,t)=>{var i=VennUtils.getMarginFromCircles(t,r,s);return e.margin<i&&(e.point=t,e.margin=i),e},e)},{point:void 0,margin:-Number.MAX_VALUE}).point;var t=VennUtils.nelderMead(e=>-VennUtils.getMarginFromCircles({x:e[0],y:e[1]},r,s),[e.x,e.y]);return e={x:t[0],y:t[1]},e=isPointInsideAllCircles(e,r)&&isPointOutsideAllCircles(e,s)?e:1<r.length?getCenterOfPoints(getCirclesIntersectionPolygon(r)):{x:r[0].x,y:r[0].y}}static getLabelValues(e,t){const r=e.sets,i=t.reduce((e,t)=>{var i=-1<r.indexOf(t.sets[0]);return t.circle&&e[i?"internal":"external"].push(t.circle),e},{internal:[],external:[]});i.external=i.external.filter(t=>i.internal.some(e=>!isCircle1CompletelyOverlappingCircle2(t,e)));e=VennSeries.getLabelPosition(i.internal,i.external);return{position:e,width:VennUtils.getLabelWidth(e,i.internal,i.external)}}static layout(e){const t={},i={};if(0<e.length){const o=VennUtils.layoutGreedyVenn(e);var r=e.filter(VennUtils.isSet);for(const a of e){const l=a.sets;var s=l.join(),n=VennUtils.isSet(a)?o[s]:getAreaOfIntersectionBetweenCircles(l.map(e=>o[e]));n&&(t[s]=n,i[s]=VennSeries.getLabelValues(a,r))}}return{mapOfIdToShape:t,mapOfIdToLabelValues:i}}static getScale(e,t,i){var r=i.bottom-i.top,s=i.right-i.left,n=(i.right+i.left)/2,i=(i.top+i.bottom)/2,s=Math.min(0<s?1/s*e:1,0<r?1/r*t:1);return{scale:s,centerX:e/2-n*s,centerY:t/2-i*s}}static updateFieldBoundaries(e,t){var i=t.x-t.r,r=t.x+t.r,s=t.y+t.r,t=t.y-t.r;return(!isNumber(e.left)||e.left>i)&&(e.left=i),(!isNumber(e.right)||e.right<r)&&(e.right=r),(!isNumber(e.top)||e.top>t)&&(e.top=t),(!isNumber(e.bottom)||e.bottom<s)&&(e.bottom=s),e}animate(e){if(!e){var t=animObject(this.options.animation);for(const r of this.points){var i=r.shapeArgs;if(r.graphic&&i){const s={},n={};i.d?s.opacity=.001:(s.r=0,n.r=i.r),r.graphic.attr(s).animate(n,t),i.d&&setTimeout(()=>{r&&r.graphic&&r.graphic.animate({opacity:1})},t.duration)}}}}drawPoints(){var e=this.chart,t=this.group,i=this.points||[],r=e.renderer;for(const o of i){var s={zIndex:isArray(o.sets)?o.sets.length:0},n=o.shapeArgs;e.styledMode||extend(s,this.pointAttribs(o,o.state)),DPU.draw(o,{isNew:!o.graphic,animatableAttribs:n,attribs:s,group:t,renderer:r,shapeType:n&&n.d?"path":"circle"})}}init(){ScatterSeries.prototype.init.apply(this,arguments),delete this.opacity}pointAttribs(e,t){var i=this.options||{},r=e&&e.options||{},t=t&&i.states[t]||{},i=merge(i,{color:e&&e.color},r,t);return{fill:color(i.color).brighten(i.brightness).get(),opacity:i.opacity,stroke:i.borderColor,"stroke-width":i.borderWidth,dashstyle:i.borderDashStyle}}translate(){var e=this.chart,t=(this.processedXData=this.xData,this.generatePoints(),VennUtils.processVennData(this.options.data,VennSeries.splitter));const{mapOfIdToShape:l,mapOfIdToLabelValues:c}=VennSeries.layout(t),i=Object.keys(l).filter(e=>{e=l[e];return e&&isNumber(e.r)}).reduce((e,t)=>VennSeries.updateFieldBoundaries(e,l[t]),{top:0,bottom:0,left:0,right:0}),r=VennSeries.getScale(e.plotWidth,e.plotHeight,i),p=r.scale,d=r.centerX,m=r.centerY;for(const h of this.points){let e=isArray(h.sets)?h.sets:[],t=e.join(),i=l[t],r,s=c[t]||{},n=s.width,o=s.position,a=h.options&&h.options.dataLabels;if(i){if(i.r)r={x:d+i.x*p,y:m+i.y*p,r:i.r*p};else if(i.d){const g=i.d;g.forEach(e=>{"M"===e[0]?(e[1]=d+e[1]*p,e[2]=m+e[2]*p):"A"===e[0]&&(e[1]=e[1]*p,e[2]=e[2]*p,e[6]=d+e[6]*p,e[7]=m+e[7]*p)}),r={d:g}}o?(o.x=d+o.x*p,o.y=m+o.y*p):o={},isNumber(n)&&(n=Math.round(n*p))}h.shapeArgs=r,o&&r&&(h.plotX=o.x,h.plotY=o.y),n&&r&&(h.dlOptions=merge(!0,{style:{width:n}},isObject(a,!0)?a:void 0)),h.name=h.options.name||e.join("âˆ©")}}}VennSeries.splitter="highcharts-split",VennSeries.defaultOptions=merge(ScatterSeries.defaultOptions,VennSeriesDefaults),extend(VennSeries.prototype,{axisTypes:[],directTouch:!0,isCartesian:!1,pointArrayMap:["value"],pointClass:VennPoint,utils:VennUtils}),addEvent(VennSeries,"afterSetOptions",function(e){const t=e.options,i=t.states||{};if(this.is("venn"))for(const r of Object.keys(i))i[r].halo=!1}),SeriesRegistry.registerSeriesType("venn",VennSeries);export default VennSeries;