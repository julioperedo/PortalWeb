"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const{animObject,stop}=A;import GeoHeatmapPoint from"./GeoHeatmapPoint.js";import H from"../../Core/Globals.js";const noop=H["noop"];import IU from"../InterpolationUtilities.js";const{colorFromPoint,getContext}=IU;import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{map:MapSeries}=SeriesRegistry["seriesTypes"];import U from"../../Core/Utilities.js";const{addEvent,extend,isNumber,isObject,merge,pick}=U;function normalizeLonValue(t){return t-360*Math.floor((t+180)/360)}function scaledPointPos(t,e,i,o,a,r){return Math.ceil(i*(o-1-(e+90)/r)+(t+180)/a)}class GeoHeatmapSeries extends MapSeries{constructor(){super(...arguments),this.options=void 0,this.data=void 0,this.points=void 0,this.canvas=void 0,this.context=void 0,this.isDirtyCanvas=!0}update(){var t=this;t.options=merge(t.options,arguments[0]),t.getInterpolation().enabled&&(t.isDirtyCanvas=!0,t.points.forEach(t=>{t.graphic&&(t.graphic.destroy(),delete t.graphic)})),super.update.apply(t,arguments)}translate(){this.getInterpolation().enabled&&this.image&&!this.isDirty&&!this.isDirtyData||super.translate.apply(this,arguments)}getInterpolation(){return isObject(this.options.interpolation)?this.options.interpolation:{blur:1,enabled:this.options.interpolation}}drawPoints(){const t=this,e=t.chart,i=e.mapView,o=t.options;if(t.getInterpolation().enabled&&i&&t.bounds){const m=t.context||getContext(t),{canvas:g,colorAxis:c,image:y,chart:e,points:u}=t,[b,x]=[pick(o.colsize,1),pick(o.rowsize,1)],f=i.projectedUnitsToPixels({x:t.bounds.x1,y:t.bounds.y2}),w=i.projectedUnitsToPixels({x:t.bounds.x2,y:t.bounds.y1});if(g&&m&&c&&f&&w){const v={x:f.x,y:f.y,width:w.x-f.x,height:w.y-f.y};if(t.isDirtyCanvas||t.isDirtyData||"Orthographic"===i.projection.options.name){t.isDirtyCanvas=!0;const D=g.width=1+~~(360/b),C=g.height=1+~~(180/x),P=D*C,j=new Uint8ClampedArray(4*P);t.directTouch=!1;for(let t=0;t<u.length;t++){var a=u[t],r=new Uint8ClampedArray(colorFromPoint(a.value,a)),{lon:a,lat:n}=a.options;isNumber(a)&&isNumber(n)&&j.set(r,4*scaledPointPos(a,n,D,C,b,x))}var s=t.getInterpolation().blur,s=0===s?1:11*s,p=~~(D*s),s=~~(C*s),l=~~v.width,h=~~v.height,d=new ImageData(j,D,C),p=(g.width=p,g.height=s,m.putImageData(d,0,0),m.globalCompositeOperation="copy",m.drawImage(g,0,0,d.width,d.height,0,0,g.width,g.height),m.getImageData(0,0,g.width,g.height)),s=this.getProjectedImageData(i,l,h,p,g,v.x,v.y),d=new ImageData(s,l,h);m.globalCompositeOperation="copy",g.width=l,g.height=h,m.putImageData(d,0,0)}if(y)if(e.renderer.globalAnimation&&e.hasRendered){const U=Number(y.attr("x")),I=Number(y.attr("y")),S=Number(y.attr("width")),A=Number(y.attr("height")),L=merge(animObject(e.renderer.globalAnimation)),T=L.step;L.step=function(){T&&T.apply(this,arguments),((t,e)=>{y.attr({x:U+(v.x-U)*e.pos,y:I+(v.y-I)*e.pos,width:S+(v.width-S)*e.pos,height:A+(v.height-A)*e.pos})}).apply(this,arguments)},y.attr(merge({animator:0},t.isDirtyCanvas?{href:g.toDataURL("image/png",1)}:void 0)).animate({animator:1},L)}else stop(y),y.attr(merge(v,t.isDirtyCanvas?{href:g.toDataURL("image/png",1)}:void 0));else t.image=e.renderer.image(g.toDataURL("image/png",1)).attr(v).add(t.group);t.isDirtyCanvas=!1}}else super.drawPoints.apply(t,arguments)}getProjectedImageData(e,i,t,o,a,r,n){const s=new Uint8ClampedArray(i*t*4),p=pick(e.projection.options.rotation?.[0],0),l=a.width/360,h=-1*a.height/180;let d=-1;for(let t=0;t<s.length;t+=4){var m,g=t/4%i;0==g&&d++;const c=e.pixelsToLonLat({x:r+g,y:n+d});c&&(c.lon>-180-p&&c.lon<180-p&&(c.lon=normalizeLonValue(c.lon)),m=(g=[c.lon,c.lat])[0]*l+a.width/2,g=g[1]*h+a.height/2,0<=m&&m<=a.width&&0<=g&&g<=a.height&&(g=Math.floor(g)*a.width*4+4*Math.round(m),s[t]=o.data[g],s[t+1]=o.data[1+g],s[t+2]=o.data[2+g],s[t+3]=o.data[3+g]))}return s}searchPoint(t,e){const i=this,o=this.chart,a=o.mapView;if(a&&i.bounds&&i.image&&o.tooltip&&o.tooltip.options.enabled)if(!1===o.pointer.hasDragged&&(+i.image.attr("animator")<=.01||.99<=+i.image.attr("animator"))){var r=a.projectedUnitsToPixels({x:i.bounds.x1,y:i.bounds.y2}),n=a.projectedUnitsToPixels({x:i.bounds.x2,y:i.bounds.y1});if(o.pointer.normalize(t),t.lon&&t.lat&&r&&n&&t.chartX-o.plotLeft>r.x&&t.chartX-o.plotLeft<n.x&&t.chartY-o.plotTop>r.y&&t.chartY-o.plotTop<n.y)return this.searchKDTree({clientX:t.chartX,lon:normalizeLonValue(t.lon),lat:t.lat},e,t)}else o.tooltip.destroy()}}GeoHeatmapSeries.defaultOptions=merge(MapSeries.defaultOptions,{nullColor:"transparent",tooltip:{pointFormat:"Lat: {point.lat}, Lon: {point.lon}, Value: {point.value}<br/>"},borderWidth:0,colsize:1,rowsize:1,stickyTracking:!0,interpolation:{enabled:!1,blur:1}}),addEvent(GeoHeatmapSeries,"afterDataClassLegendClick",function(){this.isDirtyCanvas=!0,this.drawPoints()}),extend(GeoHeatmapSeries.prototype,{type:"geoheatmap",applyJitter:noop,pointClass:GeoHeatmapPoint,pointArrayMap:["lon","lat","value"],kdAxisArray:["lon","lat"]}),SeriesRegistry.registerSeriesType("geoheatmap",GeoHeatmapSeries);export default GeoHeatmapSeries;