"use strict";import H from"../../Core/Globals.js";const deg2rad=H["deg2rad"];import U from"../../Core/Utilities.js";const{extend,find,isNumber,isObject,merge}=U;function isRectanglesIntersecting(t,e){return!(e.left>t.right||e.right<t.left||e.top>t.bottom||e.bottom<t.top)}function getNormals(t,e){var o=e[0]-t[0],e=e[1]-t[1];return[[-e,o],[e,-o]]}function getAxesFromPolygon(t){let e,n=t.axes||[];return n.length||(n=[],e=e=t.concat([t[0]]),e.reduce((t,e)=>{const o=getNormals(t,e),i=o[0];return find(n,t=>t[0]===i[0]&&t[1]===i[1])||n.push(i),e}),t.axes=n),n}function project(t,o){t=t.map(t=>{var e=t[0],t=t[1];return e*o[0]+t*o[1]});return{min:Math.min.apply(this,t),max:Math.max.apply(this,t)}}function isPolygonsOverlappingOnAxis(t,e,o){e=project(e,t),o=project(o,t);return!!(o.min>e.max||o.max<e.min)}function isPolygonsColliding(e,o){const t=getAxesFromPolygon(e),i=getAxesFromPolygon(o),n=t.concat(i),r=!find(n,t=>isPolygonsOverlappingOnAxis(t,e,o));return r}function intersectsAnyWord(o,t){function i(t){let e=isRectanglesIntersecting(n,t.rect);return e=e&&(o.rotation%90||t.rotation%90)?isPolygonsColliding(r,t.polygon):e}const n=o.rect,r=o.polygon,e=o.lastCollidedWith;let a=!1;return e&&!(a=i(e))&&delete o.lastCollidedWith,a=a||!!find(t,function(t){var e=i(t);return e&&(o.lastCollidedWith=t),e})}function archimedeanSpiral(t,e){var e=e.field,e=e.width*e.width+e.height*e.height,o=.8*t;let i=!1;return t<=1e4&&(i={x:o*Math.cos(o),y:o*Math.sin(o)},Math.min(Math.abs(i.x),Math.abs(i.y))<e||(i=!1)),i}function squareSpiral(t,e){var o=4*t,i=Math.ceil((Math.sqrt(o)-1)/2),n=t=>"boolean"==typeof t;let r=2*i+1,a=Math.pow(r,2),l=!1;return--r,t<=1e4&&(n(l)&&o>=a-r&&(l={x:i-(a-o),y:-i}),a-=r,n(l)&&o>=a-r&&(l={x:-i,y:-i+(a-o)}),a-=r,(l=n(l)?o>=a-r?{x:-i+(a-o),y:i}:{x:i,y:i-(a-o-r)}:l).x*=5,l.y*=5),l}function rectangularSpiral(t,e){const o=squareSpiral(t,e),i=e.field;return o&&(o.x*=i.ratioX,o.y*=i.ratioY),o}function getRandomPosition(t){return Math.round(t*(Math.random()+.5)/2)}function getScale(t,e,o){var i=2*Math.max(Math.abs(o.top),Math.abs(o.bottom)),o=2*Math.max(Math.abs(o.left),Math.abs(o.right));return Math.min(0<o?1/o*t:1,0<i?1/i*e:1)}function getPlayingField(t,e,o){var o=o.reduce(function(t,e){var e=e.dimensions,o=Math.max(e.width,e.height);return t.maxHeight=Math.max(t.maxHeight,e.height),t.maxWidth=Math.max(t.maxWidth,e.width),t.area+=o*o,t},{maxHeight:0,maxWidth:0,area:0}),o=Math.max(o.maxHeight,o.maxWidth,.85*Math.sqrt(o.area)),i=e<t?t/e:1,e=t<e?e/t:1;return{width:o*i,height:o*e,ratioX:i,ratioY:e}}function getRotation(t,e,o,i){let n=!1;return n=isNumber(t)&&isNumber(e)&&isNumber(o)&&isNumber(i)&&0<t&&-1<e&&o<i?o+e%t*((i-o)/(t-1||1)):n}function getSpiral(e,o){const i=[];for(let t=1;t<1e4;t++)i.push(e(t,o));return t=>t<=1e4&&i[t-1]}function outsidePlayingField(t,e){const o=-e.width/2,i=e.width/2,n=-e.height/2,r=e.height/2;return!(o<t.left&&i>t.right&&n<t.top&&r>t.bottom)}function movePolygon(e,o,t){return t.map(function(t){return[t[0]+e,t[1]+o]})}function intersectionTesting(t,e){const o=e.placed,i=e.field,n=e.rectangle,r=e.polygon,a=e.spiral,l=t.rect=extend({},n);let g=1,s={x:0,y:0};for(t.polygon=r,t.rotation=e.rotation;!1!==s&&(intersectsAnyWord(t,o)||outsidePlayingField(l,i));)s=a(g),isObject(s)&&(l.left=n.left+s.x,l.right=n.right+s.x,l.top=n.top+s.y,l.bottom=n.bottom+s.y,t.polygon=movePolygon(s.x,s.y,r)),g++;return s}function extendPlayingField(t,e){let o,i,n,r,a,l,g,s;return s=isObject(t)&&isObject(e)?(o=e.bottom-e.top,i=e.right-e.left,n=t.ratioX,l=(a=o*(r=t.ratioY)<i*n?i:o)*n,g=a*r,merge(t,{width:t.width+2*l,height:t.height+2*g})):t}function updateFieldBoundaries(t,e){return(!isNumber(t.left)||t.left>e.left)&&(t.left=e.left),(!isNumber(t.right)||t.right<e.right)&&(t.right=e.right),(!isNumber(t.top)||t.top>e.top)&&(t.top=e.top),(!isNumber(t.bottom)||t.bottom<e.bottom)&&(t.bottom=e.bottom),t}function correctFloat(t,e){e=isNumber(e)?e:14,e=Math.pow(10,e);return Math.round(t*e)/e}function getBoundingBoxFromPolygon(t){return t.reduce(function(t,e){var o=e[0],e=e[1];return t.left=Math.min(o,t.left),t.right=Math.max(o,t.right),t.bottom=Math.max(e,t.bottom),t.top=Math.min(e,t.top),t},{left:Number.MAX_VALUE,right:-Number.MAX_VALUE,bottom:-Number.MAX_VALUE,top:Number.MAX_VALUE})}function getPolygon(t,e,o,i,n){const r=[t,e],a=t-o/2,l=t+o/2,g=e-i/2,s=e+i/2,u=[[a,g],[l,g],[l,s],[a,s]];return u.map(function(t){return rotate2DToPoint(t,r,-n)})}function rotate2DToOrigin(t,e){var o=t[0],t=t[1],e=deg2rad*-e,i=Math.cos(e),e=Math.sin(e);return[correctFloat(o*i-t*e),correctFloat(o*e+t*i)]}function rotate2DToPoint(t,e,o){t=rotate2DToOrigin([t[0]-e[0],t[1]-e[1]],o);return[t[0]+e[0],t[1]+e[1]]}const WordcloudUtils={archimedeanSpiral:archimedeanSpiral,extendPlayingField:extendPlayingField,getBoundingBoxFromPolygon:getBoundingBoxFromPolygon,getPlayingField:getPlayingField,getPolygon:getPolygon,getRandomPosition:getRandomPosition,getRotation:getRotation,getScale:getScale,getSpiral:getSpiral,intersectionTesting:intersectionTesting,isPolygonsColliding:isPolygonsColliding,isRectanglesIntersecting:isRectanglesIntersecting,rectangularSpiral:rectangularSpiral,rotate2DToOrigin:rotate2DToOrigin,rotate2DToPoint:rotate2DToPoint,squareSpiral:squareSpiral,updateFieldBoundaries:updateFieldBoundaries};export default WordcloudUtils;