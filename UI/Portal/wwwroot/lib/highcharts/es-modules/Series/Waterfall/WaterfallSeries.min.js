"use strict";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{column:ColumnSeries,line:LineSeries}=SeriesRegistry.seriesTypes;import U from"../../Core/Utilities.js";const{addEvent,arrayMax,arrayMin,correctFloat,extend,isNumber,merge,objectEach,pick}=U;import WaterfallAxis from"../../Core/Axis/WaterfallAxis.js";import WaterfallPoint from"./WaterfallPoint.js";import WaterfallSeriesDefaults from"./WaterfallSeriesDefaults.js";function ownProp(t,e){return Object.hasOwnProperty.call(t,e)}class WaterfallSeries extends ColumnSeries{constructor(){super(...arguments),this.chart=void 0,this.data=void 0,this.options=void 0,this.points=void 0,this.stackedYNeg=void 0,this.stackedYPos=void 0,this.stackKey=void 0,this.xData=void 0,this.yAxis=void 0,this.yData=void 0}generatePoints(){ColumnSeries.prototype.generatePoints.apply(this);for(let t=0,e=this.points.length;t<e;t++){const a=this.points[t],s=this.processedYData[t];isNumber(s)&&(a.isIntermediateSum||a.isSum)&&(a.y=correctFloat(s))}}processData(t){const e=this,a=e.options,s=e.yData,i=a.data,o=s.length,r=a.threshold||0;let l,n,h,d,c,p;for(let t=h=n=d=c=0;t<o;t++)p=s[t],l=i&&i[t]?i[t]:{},"sum"===p||l.isSum?s[t]=correctFloat(h):"intermediateSum"===p||l.isIntermediateSum?(s[t]=correctFloat(n),n=0):(h+=p,n+=p),d=Math.min(h,d),c=Math.max(h,c);super.processData.call(this,t),a.stacking||(e.dataMin=d+r,e.dataMax=c)}toYData(t){return t.isSum?"sum":t.isIntermediateSum?"intermediateSum":t.y}updateParallelArrays(t,e){super.updateParallelArrays.call(this,t,e),"sum"!==this.yData[0]&&"intermediateSum"!==this.yData[0]||(this.yData[0]=null)}pointAttribs(t,e){var a=this.options.upColor;a&&!t.options.color&&isNumber(t.y)&&(t.color=0<t.y?a:void 0);const s=ColumnSeries.prototype.pointAttribs.call(this,t,e);return delete s.dashstyle,s}getGraphPath(){return[["M",0,0]]}getCrispPath(){const t=this.data.filter(t=>isNumber(t.y)),a=this.yAxis,s=t.length,i=Math.round(this.graph.strokeWidth())%2/2,o=Math.round(this.borderWidth)%2/2,r=this.xAxis.reversed,l=this.yAxis.reversed,n=this.options.stacking,h=[];for(let e=1;e<s;e++)if(this.options.connectNulls||isNumber(this.data[t[e].index-1].y)){var d=t[e].box,c=t[e-1],p=c.y||0,u=t[e-1].box;if(d&&u){var g=a.waterfall.stacks[this.stackKey],y=0<p?-u.height:0;if(g&&u&&d){var g=g[e-1];let t;t=n?(g=g.connectorThreshold,Math.round(a.translate(g,!1,!0,!1,!0)+(l?y:0))-i):u.y+c.minPointLengthOffset+o-i,h.push(["M",(u.x||0)+(!r&&u.width||0),t],["L",(d.x||0)+(r&&d.width||0),t])}if(u&&h.length&&(!n&&p<0&&!l||0<p&&l)){const m=h[h.length-2],f=(m&&"number"==typeof m[2]&&(m[2]+=u.height||0),h[h.length-1]);f&&"number"==typeof f[2]&&(f[2]+=u.height||0)}}}return h}drawGraph(){LineSeries.prototype.drawGraph.call(this),this.graph&&this.graph.attr({d:this.getCrispPath()})}setStackedPoints(t){const e=this,a=e.options,s=t.waterfall?.stacks,i=a.threshold||0,o=e.stackKey,r=e.xData,l=r.length;let n=i,h=n,d,c=0,p=0,u=0,g,y,m,f,S,b,x,k;var P=(t,e,a,s)=>{if(d){if(g)for(;a<g;a++)d.stackState[a]+=s;else d.stackState[0]=t,g=d.stackState.length;d.stackState.push(d.stackState[g-1]+e)}};if(t.stacking&&s&&e.reserveSpace()){k=s.changed,(x=s.alreadyChanged)&&x.indexOf(o)<0&&(k=!0),s[o]||(s[o]={});const v=s[o];if(v)for(let t=0;t<l;t++)b=r[t],v[b]&&!k||(v[b]={negTotal:0,posTotal:0,stackTotal:0,threshold:0,stateIndex:0,stackState:[],label:k&&v[b]?v[b].label:void 0}),d=v[b],0<=(S=e.yData[t])?d.posTotal+=S:d.negTotal+=S,f=a.data[t],y=d.absolutePos=d.posTotal,m=d.absoluteNeg=d.negTotal,d.stackTotal=y+m,g=d.stackState.length,f&&f.isIntermediateSum?(P(u,p,0,u),u=p,p=i,n^=h,h^=n,n^=h):f&&f.isSum?(P(i,c,g,0),n=i):(P(n,S,0,c),f&&(c+=S,p+=S)),d.stateIndex++,d.threshold=n,n+=d.stackTotal;s.changed=!1,s.alreadyChanged||(s.alreadyChanged=[]),s.alreadyChanged.push(o)}}getExtremes(){var t=this.options.stacking;let e,a,s;return t?(e=this.yAxis.waterfall.stacks,a=this.stackedYNeg=[],s=this.stackedYPos=[],"overlap"===t?objectEach(e[this.stackKey],function(t){a.push(arrayMin(t.stackState)),s.push(arrayMax(t.stackState))}):objectEach(e[this.stackKey],function(t){a.push(t.negTotal+t.threshold),s.push(t.posTotal+t.threshold)}),{dataMin:arrayMin(a),dataMax:arrayMax(s)}):{dataMin:this.dataMin,dataMax:this.dataMax}}}WaterfallSeries.defaultOptions=merge(ColumnSeries.defaultOptions,WaterfallSeriesDefaults),WaterfallSeries.compose=WaterfallAxis.compose,extend(WaterfallSeries.prototype,{getZonesGraphs:LineSeries.prototype.getZonesGraphs,pointValKey:"y",showLine:!0,pointClass:WaterfallPoint}),addEvent(WaterfallSeries,"afterColumnTranslate",function(){const e=this,{options:t,points:a,yAxis:s}=e,i=pick(t.minPointLength,5),o=i/2,r=t.threshold||0,l=t.stacking,n=s.waterfall.stacks[e.stackKey];let h=r,d=r,c,p,u,g;for(let t=0;t<a.length;t++){const f=a[t],S=e.processedYData[t],b=f.shapeArgs,x=extend({x:0,y:0,width:0,height:0},b||{});f.box=x;var y=[0,S],m=f.y||0;if(l){if(n){const k=n[t],P=("overlap"===l?(p=k.stackState[k.stateIndex--],c=0<=m?p:p-m,ownProp(k,"absolutePos")&&delete k.absolutePos,ownProp(k,"absoluteNeg")&&delete k.absoluteNeg):(c=0<=m?(p=k.threshold+k.posTotal,k.posTotal-=m,p):(p=k.threshold+k.negTotal,k.negTotal-=m,p-m),k.posTotal||isNumber(k.absolutePos)&&ownProp(k,"absolutePos")&&(k.posTotal=k.absolutePos,delete k.absolutePos),k.negTotal||isNumber(k.absoluteNeg)&&ownProp(k,"absoluteNeg")&&(k.negTotal=k.absoluteNeg,delete k.absoluteNeg)),f.isSum||(k.connectorThreshold=k.threshold+k.stackTotal),g=s.reversed?(u=0<=m?c-m:c+m,c):(u=c)-m,f.below=u<=r,x.y=s.translate(u,!1,!0,!1,!0),x.height=Math.abs(x.y-s.translate(g,!1,!0,!1,!0)),s.waterfall.dummyStackItem);P&&(P.x=t,P.label=n[t].label,P.setOffset(e.pointXOffset||0,e.barW||0,e.stackedYNeg[t],e.stackedYPos[t],void 0,this.xAxis))}}else c=Math.max(d,d+m)+y[0],x.y=s.translate(c,!1,!0,!1,!0),f.isSum?(x.y=s.translate(y[1],!1,!0,!1,!0),x.height=Math.min(s.translate(y[0],!1,!0,!1,!0),s.len)-x.y,f.below=y[1]<=r):f.isIntermediateSum?(g=0<=m?(u=y[1]+h,h):(u=h,y[1]+h),s.reversed&&(u^=g,g^=u,u^=g),x.y=s.translate(u,!1,!0,!1,!0),x.height=Math.abs(x.y-Math.min(s.translate(g,!1,!0,!1,!0),s.len)),h+=y[1],f.below=u<=r):(x.height=0<S?s.translate(d,!1,!0,!1,!0)-x.y:s.translate(d,!1,!0,!1,!0)-s.translate(d-S,!1,!0,!1,!0),d+=S,f.below=d<r),x.height<0&&(x.y+=x.height,x.height*=-1);f.plotY=x.y=Math.round(x.y||0)-e.borderWidth%2/2,x.height=Math.max(Math.round(x.height||0),.001),f.yBottom=x.y+x.height,x.height<=i&&!f.isNull?(x.height=i,x.y-=o,f.plotY=x.y,f.minPointLengthOffset=m<0?-o:o):(f.isNull&&(x.width=0),f.minPointLengthOffset=0);y=f.plotY+(f.negative?x.height:0);f.below&&(f.plotY+=x.height),f.tooltipPos&&(e.chart.inverted?f.tooltipPos[0]=s.len-y:f.tooltipPos[1]=y),f.isInside=this.isPointInside(f),merge(!0,f.shapeArgs,x)}},{order:2}),SeriesRegistry.registerSeriesType("waterfall",WaterfallSeries);export default WaterfallSeries;