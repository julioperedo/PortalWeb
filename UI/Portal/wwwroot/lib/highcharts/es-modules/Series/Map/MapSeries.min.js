"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const{animObject,stop}=A;import ColorMapComposition from"../ColorMapComposition.js";import CU from"../CenteredUtilities.js";import H from"../../Core/Globals.js";const noop=H["noop"];import MapChart from"../../Core/Chart/MapChart.js";const splitPath=MapChart["splitPath"];import MapPoint from"./MapPoint.js";import MapSeriesDefaults from"./MapSeriesDefaults.js";import MapView from"../../Maps/MapView.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{column:ColumnSeries,scatter:ScatterSeries}=SeriesRegistry.seriesTypes;import U from"../../Core/Utilities.js";const{extend,find,fireEvent,getNestedProperty,isArray,defined,isNumber,isObject,merge,objectEach,pick,splat}=U;class MapSeries extends ScatterSeries{constructor(){super(...arguments),this.chart=void 0,this.data=void 0,this.group=void 0,this.joinBy=void 0,this.options=void 0,this.points=void 0,this.processedData=[]}animate(t){const{chart:e,group:s}=this,o=animObject(this.options.animation);t?s.attr({translateX:e.plotLeft+e.plotWidth/2,translateY:e.plotTop+e.plotHeight/2,scaleX:.001,scaleY:.001}):s.animate({translateX:e.plotLeft,translateY:e.plotTop,scaleX:1,scaleY:1},o)}clearBounds(){this.points.forEach(t=>{delete t.bounds,delete t.insetIndex,delete t.projectedPath}),delete this.bounds}doFullTranslate(){return Boolean(this.isDirtyData||this.chart.isResizing||!this.hasRendered)}drawMapDataLabels(){super.drawDataLabels(),this.dataLabelsGroup&&this.dataLabelsGroup.clip(this.chart.clipRect)}drawPoints(){const m=this,{chart:u,group:s,transformGroups:o=[]}=this,{mapView:f,renderer:g}=u;if(f){(this.transformGroups=o)[0]||(o[0]=g.g().add(s));for(let t=0,e=f.insets.length;t<e;++t)o[t+1]||o.push(g.g().add(s));this.doFullTranslate()&&(this.points.forEach(t=>{const e=t["graphic"];t.group=o["number"==typeof t.insetIndex?t.insetIndex+1:0],e&&e.parentGroup!==t.group&&e.add(t.group)}),ColumnSeries.prototype.drawPoints.apply(this),this.points.forEach(e=>{const a=e.graphic;if(a){const n=a.animate;let t="";e.name&&(t+="highcharts-name-"+e.name.replace(/ /g,"-").toLowerCase()),e.properties&&e.properties["hc-key"]&&(t+=" highcharts-key-"+e.properties["hc-key"].toString().toLowerCase()),t&&a.addClass(t),u.styledMode&&a.css(this.pointAttribs(e,e.selected?"select":void 0)),a.animate=function(t,e,s){var o,i=isNumber(t["stroke-width"])&&!isNumber(a["stroke-width"]),r=isNumber(a["stroke-width"])&&!isNumber(t["stroke-width"]),i=((i||r)&&(o=pick(m.getStrokeWidth(m.options),1)/(u.mapView&&u.mapView.getScale()||1),i&&(a["stroke-width"]=o),r&&(t["stroke-width"]=o)),n.call(a,t,e,r?function(){a.element.removeAttribute("stroke-width"),delete a["stroke-width"],s&&s.apply(this,arguments)}:s));return i}}})),o.forEach((o,t)=>{const e=0===t?f:f.insets[t-1],i=e.getSVGTransform(),r=pick(this.getStrokeWidth(this.options),1),a=i.scaleX,n=0<i.scaleY?1:-1,p=o=>{(m.points||[]).forEach(t=>{const e=t.graphic;let s;e&&e["stroke-width"]&&(s=this.getStrokeWidth(t.options))&&e.attr({"stroke-width":s/o})})};if(g.globalAnimation&&u.hasRendered&&f.allowTransformAnimation){const l=Number(o.attr("translateX")),h=Number(o.attr("translateY")),d=Number(o.attr("scaleX")),s=merge(animObject(g.globalAnimation)),c=s.step;s.step=function(){c&&c.apply(this,arguments),((t,e)=>{var s=d+(a-d)*e.pos;o.attr({translateX:l+(i.translateX-l)*e.pos,translateY:h+(i.translateY-h)*e.pos,scaleX:s,scaleY:s*n,"stroke-width":r/s}),p(s)}).apply(this,arguments)},o.attr({animator:0}).animate({animator:1},s,function(){"boolean"!=typeof g.globalAnimation&&g.globalAnimation.complete&&g.globalAnimation.complete({applyDrilldown:!0})})}else stop(o),o.attr(merge(i,{"stroke-width":r/a})),p(a)}),this.isDrilling||this.drawMapDataLabels()}}getProjectedBounds(){if(!this.bounds&&this.chart.mapView){const{insets:r,projection:a}=this.chart.mapView,t=[];(this.points||[]).forEach(e=>{if(e.path||e.geometry){if("string"==typeof e.path?e.path=splitPath(e.path):isArray(e.path)&&"M"===e.path[0]&&(e.path=this.chart.renderer.pathToSegments(e.path)),!e.bounds){let t=e.getProjectedBounds(a);if(t){e.labelrank=pick(e.labelrank,(t.x2-t.x1)*(t.y2-t.y1));const{midX:s,midY:o}=t;if(r&&isNumber(s)&&isNumber(o)){const i=find(r,t=>t.isInside({x:s,y:o}));i&&(delete e.projectedPath,(t=e.getProjectedBounds(i.projection))&&i.allBounds.push(t),e.insetIndex=r.indexOf(i))}e.bounds=t}}e.bounds&&void 0===e.insetIndex&&t.push(e.bounds)}}),this.bounds=MapView.compositeBounds(t)}return this.bounds}getStrokeWidth(t){var e=this.pointAttrToOptions;return t[e&&e["stroke-width"]||"borderWidth"]}hasData(){return!!this.processedXData.length}pointAttribs(t,e){const{mapView:s,styledMode:o}=t.series.chart,i=o?this.colorAttribs(t):ColumnSeries.prototype.pointAttribs.call(this,t,e);let r=this.getStrokeWidth(t.options);e&&(e=merge(this.options.states&&this.options.states[e],t.options.states&&t.options.states[e]||{}),a=this.getStrokeWidth(e),defined(a)&&(r=a),i.stroke=e.borderColor??t.color),r&&s&&(r/=s.getScale());var a=this.getStrokeWidth(this.options);return i.dashstyle&&s&&isNumber(a)&&(r=a/s.getScale()),t.visible||(i.fill=this.options.nullColor),defined(r)?i["stroke-width"]=r:delete i["stroke-width"],i["stroke-linecap"]=i["stroke-linejoin"]=this.options.linecap,i}updateData(){return!this.processedData&&super.updateData.apply(this,arguments)}setData(t,e=!0,s,o){delete this.bounds,super.setData(t,!1,void 0,o),this.processData(),this.generatePoints(),e&&this.chart.redraw(s)}processData(){const o=this.options,e=o.data,t=this.chart,s=t.options.chart,i=this.joinBy,r=o.keys||this.pointArrayMap,a=[],n={},p=this.chart.mapView,l=p&&(isObject(o.mapData,!0)?p.getGeoMap(o.mapData):p.geoMap),h=t.mapTransforms=s.mapTransforms||l&&l["hc-transform"]||t.mapTransforms;let d,c;h&&objectEach(h,t=>{t.rotation&&(t.cosAngle=Math.cos(t.rotation),t.sinAngle=Math.sin(t.rotation))});let m;isArray(o.mapData)?m=o.mapData:l&&"FeatureCollection"===l.type&&(this.mapTitle=l.title,m=H.geojson(l,this.type,this)),this.processedData=[];const u=this.processedData;var f;if(e)for(let s=0,t=e.length;s<t;++s){if(f=e[s],isNumber(f))u[s]={value:f};else if(isArray(f)){let e=0;u[s]={},!o.keys&&f.length>r.length&&"string"==typeof f[0]&&(u[s]["hc-key"]=f[0],++e);for(let t=0;t<r.length;++t,++e)r[t]&&void 0!==f[e]&&(0<r[t].indexOf(".")?MapPoint.prototype.setNestedProperty(u[s],f[e],r[t]):u[s][r[t]]=f[e])}else u[s]=e[s];i&&"_i"===i[0]&&(u[s]._i=s)}if(m){this.mapData=m,this.mapMap={};for(let t=0;t<m.length;t++)c=(d=m[t]).properties,d._i=t,i[0]&&c&&c[i[0]]&&(d[i[0]]=c[i[0]]),n[d[i[0]]]=d;if(this.mapMap=n,i[1]){const g=i[1];u.forEach(t=>{t=getNestedProperty(g,t);n[t]&&a.push(n[t])})}if(o.allAreas){if(i[1]){const y=i[1];u.forEach(t=>{a.push(getNestedProperty(y,t))})}const b="|"+a.map(function(t){return t&&t[i[0]]}).join("|")+"|";m.forEach(t=>{i[0]&&-1!==b.indexOf("|"+t[i[0]]+"|")||u.push(merge(t,{value:null}))})}}this.processedXData=new Array(u.length)}setOptions(t){t=super.setOptions(t);let e=t.joinBy;return null===t.joinBy&&(e="_i"),(e=this.joinBy=splat(e))[1]||(e[1]=e[0]),t}translate(){const s=this.doFullTranslate(),o=this.chart.mapView,i=o&&o.projection;if(!this.chart.hasRendered||!this.isDirtyData&&this.hasRendered||(this.processData(),this.generatePoints(),delete this.bounds,!o||o.userOptions.center||isNumber(o.userOptions.zoom)||o.zoom!==o.minZoom?this.getProjectedBounds():o.fitToBounds(void 0,void 0,!1)),o){const r=o.getSVGTransform();this.points.forEach(t=>{var e=isNumber(t.insetIndex)&&o.insets[t.insetIndex].getSVGTransform()||r;e&&t.bounds&&isNumber(t.bounds.midX)&&isNumber(t.bounds.midY)&&(t.plotX=t.bounds.midX*e.scaleX+e.translateX,t.plotY=t.bounds.midY*e.scaleY+e.translateY),s&&(t.shapeType="path",t.shapeArgs={d:MapPoint.getProjectedPath(t,i)}),t.projectedPath&&!t.projectedPath.length?t.setVisible(!1):t.visible||t.setVisible(!0)})}fireEvent(this,"afterTranslate")}}MapSeries.defaultOptions=merge(ScatterSeries.defaultOptions,MapSeriesDefaults),extend(MapSeries.prototype,{type:"map",axisTypes:ColorMapComposition.seriesMembers.axisTypes,colorAttribs:ColorMapComposition.seriesMembers.colorAttribs,colorKey:ColorMapComposition.seriesMembers.colorKey,directTouch:!0,drawDataLabels:noop,drawGraph:noop,forceDL:!0,getCenter:CU.getCenter,getExtremesFromAll:!0,getSymbol:noop,isCartesian:!1,parallelArrays:ColorMapComposition.seriesMembers.parallelArrays,pointArrayMap:ColorMapComposition.seriesMembers.pointArrayMap,pointClass:MapPoint,preserveAspectRatio:!0,searchPoint:noop,trackerGroups:ColorMapComposition.seriesMembers.trackerGroups,useMapGeometry:!0}),ColorMapComposition.compose(MapSeries),SeriesRegistry.registerSeriesType("map",MapSeries);export default MapSeries;