"use strict";import ColorMapComposition from"../ColorMapComposition.js";import MU from"../../Maps/MapUtilities.js";const boundsFromPath=MU["boundsFromPath"];import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const ScatterPoint=SeriesRegistry.seriesTypes.scatter.prototype.pointClass;import U from"../../Core/Utilities.js";const{extend,isNumber,pick}=U;class MapPoint extends ScatterPoint{constructor(){super(...arguments),this.options=void 0,this.path=void 0,this.series=void 0}static getProjectedPath(e,t){return e.projectedPath||(t&&e.geometry?(t.hasCoordinates=!0,e.projectedPath=t.path(e.geometry)):e.projectedPath=e.path),e.projectedPath||[]}applyOptions(e,t){const i=this.series,s=super.applyOptions(e,t),o=i.joinBy;return i.mapData&&i.mapMap&&(e=o[1],(e=void 0!==(t=super.getNestedProperty(e))&&i.mapMap[t])?extend(s,e):-1!==i.pointArrayMap.indexOf("value")&&(s.value=s.value||null)),s}getProjectedBounds(e){const t=MapPoint.getProjectedPath(this,e),i=boundsFromPath(t),s=this.properties,o=this.series.chart.mapView;if(i){var r=s&&s["hc-middle-lon"],a=s&&s["hc-middle-lat"];if(o&&isNumber(r)&&isNumber(a)){e=e.forward([r,a]);i.midX=e[0],i.midY=e[1]}else{r=s&&s["hc-middle-x"],a=s&&s["hc-middle-y"];i.midX=i.x1+(i.x2-i.x1)*pick(this.middleX,isNumber(r)?r:.5);let e=pick(this.middleY,isNumber(a)?a:.5);this.geometry||(e=1-e),i.midY=i.y2-(i.y2-i.y1)*e}return i}}onMouseOver(e){U.clearTimeout(this.colorInterval),!this.isNull&&this.visible||this.series.options.nullInteraction?super.onMouseOver.call(this,e):this.series.onMouseOut()}setVisible(e){var t=e?"show":"hide";this.visible=this.options.visible=!!e,this.dataLabel&&this.dataLabel[t](),this.graphic&&this.graphic.attr(this.series.pointAttribs(this))}zoomTo(e){const t=this,i=t.series.chart,s=i.mapView;let o=t.bounds;if(s&&o){const p=isNumber(t.insetIndex)&&s.insets[t.insetIndex];var r,a;p&&(r=p.projectedUnitsToPixels({x:o.x1,y:o.y1}),a=p.projectedUnitsToPixels({x:o.x2,y:o.y2}),r=s.pixelsToProjectedUnits({x:r.x,y:r.y}),a=s.pixelsToProjectedUnits({x:a.x,y:a.y}),o={x1:r.x,y1:r.y,x2:a.x,y2:a.y}),s.fitToBounds(o,void 0,!1),t.series.isDirty=!0,i.redraw(e)}}}extend(MapPoint.prototype,{dataLabelOnNull:ColorMapComposition.pointMembers.dataLabelOnNull,moveToTopOnHover:ColorMapComposition.pointMembers.moveToTopOnHover,isValid:ColorMapComposition.pointMembers.isValid});export default MapPoint;