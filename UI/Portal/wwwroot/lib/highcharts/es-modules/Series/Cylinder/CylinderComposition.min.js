"use strict";import H from"../../Core/Globals.js";const{charts,deg2rad}=H;import Math3D from"../../Core/Math3D.js";const perspective=Math3D["perspective"];import SVGElement3DCylinder from"./SVGElement3DCylinder.js";import U from"../../Core/Utilities.js";const{extend,pick,pushUnique}=U,composedMembers=[];function compose(e){if(pushUnique(composedMembers,e)){const r=e.prototype;r.Element3D.types.cylinder=SVGElement3DCylinder,extend(r,{cylinder:rendererCylinder,cylinderPath:rendererCylinderPath,getCurvedPath:rendererGetCurvedPath,getCylinderBack:rendererGetCylinderBack,getCylinderEnd:rendererGetCylinderEnd,getCylinderFront:rendererGetCylinderFront})}}function isSimplified(e){return!e.some(e=>"C"===e[0])}function rendererCylinder(e){return this.element3d("cylinder",e)}function rendererCylinderPath(e){var r=this,t=charts[r.chartIndex],n=this.cuboidPath(e),i=!n.isTop,o=!n.isFront,s=r.getCylinderEnd(t,e),t=r.getCylinderEnd(t,e,!0);return{front:r.getCylinderFront(s,t),back:r.getCylinderBack(s,t),top:s,bottom:t,zIndexes:{top:i?3:0,bottom:i?0:3,front:o?2:1,back:o?1:2,group:n.zIndexes.group}}}function rendererGetCurvedPath(r){const t=[["M",r[0].x,r[0].y]],n=r.length-2;for(let e=1;e<n;e+=3)t.push(["C",r[e].x,r[e].y,r[e+1].x,r[e+1].y,r[e+2].x,r[e+2].y]);return t}function rendererGetCylinderBack(e,r){const t=[];var n,i;return isSimplified(e)?(n=e[0],i=e[2],"M"===n[0]&&"L"===i[0]&&(t.push(["M",i[1],i[2]]),t.push(e[3]),t.push(["L",n[1],n[2]]))):("C"===e[2][0]&&t.push(["M",e[2][5],e[2][6]]),t.push(e[3],e[4])),isSimplified(r)?"M"===(i=r[0])[0]&&(t.push(["L",i[1],i[2]]),t.push(r[3]),t.push(r[2])):(n=r[2],e=r[3],i=r[4],"C"===n[0]&&"C"===e[0]&&"C"===i[0]&&(t.push(["L",i[5],i[6]]),t.push(["C",i[3],i[4],i[1],i[2],e[5],e[6]]),t.push(["C",e[3],e[4],e[1],e[2],n[5],n[6]]))),t.push(["Z"]),t}function rendererGetCylinderEnd(e,r,t){var{width:n=0,height:i=0,alphaCorrection:o=0}=r,s=pick(r.depth,n,0),d=Math.min(n,s)/2,o=deg2rad*(e.options.chart.options3d.beta-90+o),t=(r.y||0)+(t?i:0),i=.5519*d,p=n/2+(r.x||0),h=s/2+(r.z||0),n=[{x:0,y:t,z:d},{x:i,y:t,z:d},{x:d,y:t,z:i},{x:d,y:t,z:0},{x:d,y:t,z:-i},{x:i,y:t,z:-d},{x:0,y:t,z:-d},{x:-i,y:t,z:-d},{x:-d,y:t,z:-i},{x:-d,y:t,z:0},{x:-d,y:t,z:i},{x:-i,y:t,z:d},{x:0,y:t,z:d}],y=Math.cos(o),u=Math.sin(o);let c,l,C;for(const a of n)l=a.x,C=a.z,a.x=l*y-C*u+p,a.z=C*y+l*u+h;s=perspective(n,e,!0);return c=Math.abs(s[3].y-s[9].y)<2.5&&Math.abs(s[0].y-s[6].y)<2.5?this.toLinePath([s[0],s[3],s[6],s[9]],!0):this.getCurvedPath(s)}function rendererGetCylinderFront(e,r){const t=e.slice(0,3);var n;return isSimplified(r)?"M"===(e=r[0])[0]&&(t.push(r[2]),t.push(r[1]),t.push(["L",e[1],e[2]])):(e=r[0],n=r[1],r=r[2],"M"===e[0]&&"C"===n[0]&&"C"===r[0]&&(t.push(["L",r[5],r[6]]),t.push(["C",r[3],r[4],r[1],r[2],n[5],n[6]]),t.push(["C",n[3],n[4],n[1],n[2],e[1],e[2]]))),t.push(["Z"]),t}const CylinderComposition={compose:compose};export default CylinderComposition;