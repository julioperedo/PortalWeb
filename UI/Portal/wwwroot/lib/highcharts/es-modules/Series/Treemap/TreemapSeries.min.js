"use strict";import Breadcrumbs from"../../Extensions/Breadcrumbs/Breadcrumbs.js";import Color from"../../Core/Color/Color.js";const color=Color["parse"];import ColorMapComposition from"../ColorMapComposition.js";import H from"../../Core/Globals.js";const noop=H["noop"];import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{column:ColumnSeries,scatter:ScatterSeries}=SeriesRegistry.seriesTypes;import TreemapAlgorithmGroup from"./TreemapAlgorithmGroup.js";import TreemapNode from"./TreemapNode.js";import TreemapPoint from"./TreemapPoint.js";import TreemapSeriesDefaults from"./TreemapSeriesDefaults.js";import TreemapUtilities from"./TreemapUtilities.js";import TU from"../TreeUtilities.js";const{getColor,getLevelOptions,updateRootId}=TU;import U from"../../Core/Utilities.js";const{addEvent,correctFloat,defined,error,extend,fireEvent,isArray,isNumber,isObject,isString,merge,pick,pushUnique,stableSort}=U,axisMax=100,composedMembers=[];let treemapAxisDefaultValues=!1;function onSeriesAfterBindAxes(){const e=this,t=e.xAxis,o=e.yAxis;var r;t&&o&&(e.is("treemap")?(r={endOnTick:!1,gridLineWidth:0,lineWidth:0,min:0,minPadding:0,max:axisMax,maxPadding:0,startOnTick:!1,title:void 0,tickPositions:[]},extend(o.options,r),extend(t.options,r),treemapAxisDefaultValues=!0):treemapAxisDefaultValues&&(o.setOptions(o.userOptions),t.setOptions(t.userOptions),treemapAxisDefaultValues=!1))}class TreemapSeries extends ScatterSeries{constructor(){super(...arguments),this.axisRatio=void 0,this.data=void 0,this.mapOptionsToLevel=void 0,this.nodeMap=void 0,this.nodeList=void 0,this.options=void 0,this.points=void 0,this.rootNode=void 0,this.tree=void 0,this.level=void 0}static compose(e){pushUnique(composedMembers,e)&&addEvent(e,"afterBindAxes",onSeriesAfterBindAxes)}algorithmCalcPoints(e,t,o,r){const i=o.plot,s=o.elArr.length-1;let a,n,l,d,p=o.lW,h=o.lH,c,u=0;t?(p=o.nW,h=o.nH):c=o.elArr[s];for(const m of o.elArr)(t||u<s)&&(0===o.direction?(a=i.x,n=i.y,l=p,d=m/l):(a=i.x,n=i.y,d=h,l=m/d),r.push({x:a,y:n,width:l,height:correctFloat(d)}),0===o.direction?i.y=i.y+d:i.x=i.x+l),u+=1;o.reset(),0===o.direction?o.width=o.width-p:o.height=o.height-h,i.y=i.parent.y+(i.parent.height-o.height),i.x=i.parent.x+(i.parent.width-o.width),e&&(o.direction=1-o.direction),t||o.addElement(c)}algorithmFill(e,t,o){const r=[];let i,s=t.direction,a=t.x,n=t.y,l=t.width,d=t.height,p,h,c,u;for(const m of o)i=t.width*t.height*(m.val/t.val),p=a,h=n,0===s?(u=d,c=i/u,l-=c,a+=c):(c=l,u=i/c,d-=u,n+=u),r.push({x:p,y:h,width:c,height:u}),e&&(s=1-s);return r}algorithmLowAspectRatio(e,t,o){const r=[],i={x:t.x,y:t.y,parent:t},s=t.direction,a=o.length-1,n=new TreemapAlgorithmGroup(t.height,t.width,s,i);let l,d=0;for(const p of o)l=t.width*t.height*(p.val/t.val),n.addElement(l),n.lP.nR>n.lP.lR&&this.algorithmCalcPoints(e,!1,n,r,i),d===a&&this.algorithmCalcPoints(e,!0,n,r,i),++d;return r}alignDataLabel(e,t,o){const r=o.style;r&&!defined(r.textOverflow)&&t.text&&t.getBBox().width>t.text.textWidth&&t.css({textOverflow:"ellipsis",width:r.width+="px"}),ColumnSeries.prototype.alignDataLabel.apply(this,arguments),e.dataLabel&&e.dataLabel.attr({zIndex:(e.node.zIndex||0)+1})}calculateChildrenAreas(e,t){var o,r=this,i=r.options,s=r.mapOptionsToLevel[e.level+1],a=pick(r[s&&s.layoutAlgorithm]&&s.layoutAlgorithm,i.layoutAlgorithm),n=i.alternateStartingDirection,i=e.children.filter(e=>!e.ignore);s&&s.layoutStartingDirection&&(t.direction="vertical"===s.layoutStartingDirection?0:1),o=r[a](t,i);let l=-1;for(const p of i){var d=o[++l];p.values=merge(d,{val:p.childrenTotal,direction:n?1-t.direction:t.direction}),p.pointValues=merge(d,{x:d.x/r.axisRatio,y:axisMax-d.y-d.height,width:d.width/r.axisRatio}),p.children.length&&r.calculateChildrenAreas(p,p.values)}}createList(o){const r=this.chart,e=r.breadcrumbs,i=[];if(e){let e=0,t=(i.push({level:e,levelOptions:r.series[0]}),o.target.nodeMap[o.newRootId]);const s=[];for(;t.parent||""===t.parent;)s.push(t),t=o.target.nodeMap[t.parent];for(const a of s.reverse())i.push({level:++e,levelOptions:a});i.length<=1&&(i.length=0)}return i}drawDataLabels(){var e=this.mapOptionsToLevel;let t,o;for(const r of this.points.filter(function(e){return e.node.visible}))o=e[r.node.level],t={style:{}},r.node.isLeaf||(t.enabled=!1),o&&o.dataLabels&&(t=merge(t,o.dataLabels),this.hasDataLabels=()=>!0),r.shapeArgs&&(t.style.width=r.shapeArgs.width,r.dataLabel&&r.dataLabel.css({width:r.shapeArgs.width+"px"})),r.dlOptions=merge(t,r.options.dataLabels);super.drawDataLabels()}drawPoints(e=this.points){const t=this,o=t.chart,r=o.renderer,i=o.styledMode,s=t.options,a=i?{}:s.shadow,n=s.borderRadius,l=o.pointCount<s.animationLimit,d=s.allowTraversingTree;for(const p of e){const h=p.node.levelDynamic,c={},u={},m={},v="level-group-"+p.node.level,g=!!p.graphic,x=l&&g,f=p.shapeArgs;p.shouldDraw()&&(p.isInside=!0,n&&(u.r=n),merge(!0,x?c:u,g?f:{},i?{}:t.pointAttribs(p,p.selected?"select":void 0)),t.colorAttribs&&i&&extend(m,t.colorAttribs(p)),t[v]||(t[v]=r.g(v).attr({zIndex:1e3-(h||0)}).add(t.group),t[v].survive=!0)),p.draw({animatableAttribs:c,attribs:u,css:m,group:t[v],imageUrl:p.imageUrl,renderer:r,shadow:a,shapeArgs:f,shapeType:p.shapeType}),d&&p.graphic&&(p.drillId=s.interactByLeaf?t.drillToByLeaf(p):t.drillToByGroup(p))}}drillToByGroup(e){let t=!1;return t=e.node.isLeaf||e.node.level-this.nodeMap[this.rootNode].level!=1?t:e.id}drillToByLeaf(e){let t=!1,o;if(e.node.parent!==this.rootNode&&e.node.isLeaf)for(o=e.node;!t;)(o=this.nodeMap[o.parent]).parent===this.rootNode&&(t=o.id);return t}drillToNode(e,t){error(32,!1,void 0,{"treemap.drillToNode":"use treemap.setRootNode"}),this.setRootNode(e,t)}drillUp(){var e=this.nodeMap[this.rootNode];e&&isString(e.parent)&&this.setRootNode(e.parent,!0,{trigger:"traverseUpButton"})}getExtremes(){var{dataMin:e,dataMax:t}=super.getExtremes(this.colorValueData);return this.valueMin=e,this.valueMax=t,super.getExtremes()}getListOfParents(e,t){const o=isArray(e)?e:[],r=isArray(t)?t:[],i=o.reduce(function(e,t,o){t=pick(t.parent,"");return void 0===e[t]&&(e[t]=[]),e[t].push(o),e},{"":[]});for(const a of Object.keys(i)){var s=i[a];if(""!==a&&-1===r.indexOf(a)){for(const n of s)i[""].push(n);delete i[a]}}return i}getTree(){var e=this.data.map(function(e){return e.id}),e=this.getListOfParents(this.data,e);return this.nodeMap={},this.nodeList=[],this.buildTree("",-1,0,e)}buildTree(e,t,o,r,i){const s=this,a=[],n=s.points[t];let l=0,d;for(const h of r[e]||[])d=s.buildTree(s.points[h].id,h,o+1,r,e),l=Math.max(d.height+1,l),a.push(d);const p=(new s.NodeClass).init(e,t,a,l,o,s,i);for(const d of a)d.parentNode=p;return s.nodeMap[p.id]=p,s.nodeList.push(p),n&&((n.node=p).point=n),p}hasData(){return!!this.processedXData.length}init(e,t){const o=this,r=merge(t.drillUpButton,t.breadcrumbs),i=addEvent(o,"setOptions",e=>{const t=e.userOptions;defined(t.allowDrillToNode)&&!defined(t.allowTraversingTree)&&(t.allowTraversingTree=t.allowDrillToNode,delete t.allowDrillToNode),defined(t.drillUpButton)&&!defined(t.traverseUpButton)&&(t.traverseUpButton=t.drillUpButton,delete t.drillUpButton)});super.init(e,t),delete o.opacity,o.eventsToUnbind.push(i),o.options.allowTraversingTree&&(o.eventsToUnbind.push(addEvent(o,"click",o.onClickDrillToNode)),o.eventsToUnbind.push(addEvent(o,"setRootNode",function(e){const t=o.chart;t.breadcrumbs&&t.breadcrumbs.updateProperties(o.createList(e))})),o.eventsToUnbind.push(addEvent(o,"update",function(e,t){const o=this.chart.breadcrumbs;o&&e.options.breadcrumbs&&o.update(e.options.breadcrumbs)})),o.eventsToUnbind.push(addEvent(o,"destroy",function(e){const t=this.chart;t.breadcrumbs&&!e.keepEventsForUpdate&&(t.breadcrumbs.destroy(),t.breadcrumbs=void 0)}))),e.breadcrumbs||(e.breadcrumbs=new Breadcrumbs(e,r)),o.eventsToUnbind.push(addEvent(e.breadcrumbs,"up",function(e){var t=this.level-e.newLevel;for(let e=0;e<t;e++)o.drillUp()}))}onClickDrillToNode(e){const t=e.point,o=t&&t.drillId;isString(o)&&(t.setState(""),this.setRootNode(o,!0,{trigger:"click"}))}pointAttribs(e,t){const o=isObject(this.mapOptionsToLevel)?this.mapOptionsToLevel:{},r=e&&o[e.node.level]||{},i=this.options,s=t&&i.states&&i.states[t]||{},a=e&&e.getClassName()||"",n={stroke:e&&e.borderColor||r.borderColor||s.borderColor||i.borderColor,"stroke-width":pick(e&&e.borderWidth,r.borderWidth,s.borderWidth,i.borderWidth),dashstyle:e&&e.borderDashStyle||r.borderDashStyle||s.borderDashStyle||i.borderDashStyle,fill:e&&e.color||this.color};return-1!==a.indexOf("highcharts-above-level")?(n.fill="none",n["stroke-width"]=0):-1!==a.indexOf("highcharts-internal-node-interactive")?(e=pick(s.opacity,i.opacity),n.fill=color(n.fill).setOpacity(e).get(),n.cursor="pointer"):-1!==a.indexOf("highcharts-internal-node")?n.fill="none":t&&(n.fill=color(n.fill).brighten(s.brightness).get()),n}setColorRecursive(t,o,r,i,s){var a=this,n=a&&a.chart,n=n&&n.options&&n.options.colors;if(t){const l=getColor(t,{colors:n,index:i,mapOptionsToLevel:a.mapOptionsToLevel,parentColor:o,parentColorIndex:r,series:a,siblings:s}),d=a.points[t.i];d&&(d.color=l.color,d.colorIndex=l.colorIndex);let e=-1;for(const p of t.children||[])a.setColorRecursive(p,l.color,l.colorIndex,++e,t.children.length)}}setPointValues(){const e=this,{points:t,xAxis:o,yAxis:r}=e,i=e.chart.styledMode;for(const h of t){var s,a,n,l,{pointValues:d,visible:p}=h.node;d&&p?({height:p,width:d,x:n,y:l}=d,s=h,s=i?0:(e.pointAttribs(s)["stroke-width"]||0)%2/2,a=Math.round(o.toPixels(n,!0))-s,n=Math.round(o.toPixels(n+d,!0))-s,d=Math.round(r.toPixels(l,!0))-s,l=Math.round(r.toPixels(l+p,!0))-s,p={x:Math.min(a,n),y:Math.min(d,l),width:Math.abs(n-a),height:Math.abs(l-d)},h.plotX=p.x+p.width/2,h.plotY=p.y+p.height/2,h.shapeArgs=p):(delete h.plotX,delete h.plotY)}}setRootNode(e,t,o){e=extend({newRootId:e,previousRootId:this.rootNode,redraw:pick(t,!0),series:this},o);fireEvent(this,"setRootNode",e,function(e){const t=e.series;t.idPreviousRoot=e.previousRootId,t.rootNode=e.newRootId,t.isDirty=!0,e.redraw&&t.chart.redraw()})}setState(e){this.options.inactiveOtherPoints=!0,super.setState(e,!1),this.options.inactiveOtherPoints=!1}setTreeValues(e){const t=this,o=t.options,r=t.rootNode,i=t.nodeMap,s=i[r],a="boolean"!=typeof o.levelIsConstant||o.levelIsConstant,n=[],l=t.points[e.i];let d=0;for(var p of e.children)p=t.setTreeValues(p),n.push(p),p.ignore||(d+=p.val);stableSort(n,(e,t)=>(e.sortIndex||0)-(t.sortIndex||0));var h=pick(l&&l.options.value,d);return l&&(l.value=h),extend(e,{children:n,childrenTotal:d,ignore:!(pick(l&&l.visible,!0)&&0<h),isLeaf:e.visible&&!d,levelDynamic:e.level-(a?0:s.level),name:pick(l&&l.name,""),sortIndex:pick(l&&l.sortIndex,-h),val:h}),e}sliceAndDice(e,t){return this.algorithmFill(!0,e,t)}squarified(e,t){return this.algorithmLowAspectRatio(!0,e,t)}strip(e,t){return this.algorithmLowAspectRatio(!1,e,t)}stripes(e,t){return this.algorithmFill(!1,e,t)}translate(){const r=this,e=r.options;let t=updateRootId(r),o,i,s,a;super.translate();var n=r.tree=r.getTree();o=r.nodeMap[t],""===t||o&&o.children.length||(r.setRootNode("",!1),t=r.rootNode,o=r.nodeMap[t]),r.mapOptionsToLevel=getLevelOptions({from:o.level+1,levels:e.levels,to:n.height,defaults:{levelIsConstant:r.options.levelIsConstant,colorByPoint:e.colorByPoint}}),TreemapUtilities.recursive(r.nodeMap[r.rootNode],e=>{var t=e.parent;let o=!1;return e.visible=!0,o=!t&&""!==t?o:r.nodeMap[t]}),TreemapUtilities.recursive(r.nodeMap[r.rootNode].children,e=>{let t=!1;for(const o of e)o.visible=!0,o.children.length&&(t=(t||[]).concat(o.children));return t}),r.setTreeValues(n),r.axisRatio=r.xAxis.len/r.yAxis.len,r.nodeMap[""].pointValues=i={x:0,y:0,width:axisMax,height:axisMax},r.nodeMap[""].values=s=merge(i,{width:i.width*r.axisRatio,direction:"vertical"===e.layoutStartingDirection?0:1,val:n.val}),r.calculateChildrenAreas(n,s),r.colorAxis||e.colorByPoint||r.setColorRecursive(r.tree),e.allowTraversingTree&&(a=o.pointValues,r.xAxis.setExtremes(a.x,a.x+a.width,!1),r.yAxis.setExtremes(a.y,a.y+a.height,!1),r.xAxis.setScale(),r.yAxis.setScale()),r.setPointValues()}}TreemapSeries.defaultOptions=merge(ScatterSeries.defaultOptions,TreemapSeriesDefaults),extend(TreemapSeries.prototype,{buildKDTree:noop,colorAttribs:ColorMapComposition.seriesMembers.colorAttribs,colorKey:"colorValue",directTouch:!0,getExtremesFromAll:!0,getSymbol:noop,optionalAxis:"colorAxis",parallelArrays:["x","y","value","colorValue"],pointArrayMap:["value"],pointClass:TreemapPoint,NodeClass:TreemapNode,trackerGroups:["group","dataLabelsGroup"],utils:TreemapUtilities}),ColorMapComposition.compose(TreemapSeries),SeriesRegistry.registerSeriesType("treemap",TreemapSeries);export default TreemapSeries;