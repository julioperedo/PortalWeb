"use strict";class QuadTreeNode{constructor(t){this.body=!1,this.isEmpty=!1,this.isInternal=!1,this.nodes=[],this.box=t,this.boxSize=Math.min(t.width,t.height)}divideBox(){var t=this.box.width/2,s=this.box.height/2;this.nodes[0]=new QuadTreeNode({left:this.box.left,top:this.box.top,width:t,height:s}),this.nodes[1]=new QuadTreeNode({left:this.box.left+t,top:this.box.top,width:t,height:s}),this.nodes[2]=new QuadTreeNode({left:this.box.left+t,top:this.box.top+s,width:t,height:s}),this.nodes[3]=new QuadTreeNode({left:this.box.left,top:this.box.top+s,width:t,height:s})}getBoxPosition(t){var s=t.plotX<this.box.left+this.box.width/2,t=t.plotY<this.box.top+this.box.height/2;let i;return i=s?t?0:3:t?1:2}insert(t,s){let i;this.isInternal?this.nodes[this.getBoxPosition(t)].insert(t,s-1):(this.isEmpty=!1,this.body?s?(this.isInternal=!0,this.divideBox(),!0!==this.body&&(this.nodes[this.getBoxPosition(this.body)].insert(this.body,s-1),this.body=!0),this.nodes[this.getBoxPosition(t)].insert(t,s-1)):((i=new QuadTreeNode({top:t.plotX||NaN,left:t.plotY||NaN,width:.1,height:.1})).body=t,i.isInternal=!1,this.nodes.push(i)):(this.isInternal=!1,this.body=t))}updateMassAndCenter(){let t=0,s=0,i=0;if(this.isInternal){for(const o of this.nodes)o.isEmpty||(t+=o.mass,s+=o.plotX*o.mass,i+=o.plotY*o.mass);s/=t,i/=t}else this.body&&(t=this.body.mass,s=this.body.plotX,i=this.body.plotY);this.mass=t,this.plotX=s,this.plotY=i}}export default QuadTreeNode;