"use strict";import H from"../../Core/Globals.js";const noop=H["noop"];import MapPointPoint from"./MapPointPoint.js";import MapPointSeriesDefaults from"./MapPointSeriesDefaults.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{map:MapSeries,scatter:ScatterSeries}=SeriesRegistry.seriesTypes;import SVGRenderer from"../../Core/Renderer/SVG/SVGRenderer.js";import U from"../../Core/Utilities.js";const{extend,fireEvent,isNumber,merge}=U;import"../../Core/Defaults.js";import"../Scatter/ScatterSeries.js";class MapPointSeries extends ScatterSeries{constructor(){super(...arguments),this.chart=void 0,this.data=void 0,this.options=void 0,this.points=void 0,this.clearBounds=MapSeries.prototype.clearBounds}drawDataLabels(){super.drawDataLabels(),this.dataLabelsGroup&&this.dataLabelsGroup.clip(this.chart.clipRect)}projectPoint(t){const s=this.chart.mapView;if(s){var{geometry:t,lon:r,lat:i}=t;let e=t&&"Point"===t.type&&t.coordinates;if(e=isNumber(r)&&isNumber(i)?[r,i]:e)return s.lonLatToProjectedUnits({lon:e[0],lat:e[1]})}}translate(){const a=this.chart.mapView;if(this.processedXData||this.processData(),this.generatePoints(),this.getProjectedBounds&&this.isDirtyData&&(delete this.bounds,this.getProjectedBounds()),a){const n=a.getSVGTransform(),p=a.projection["hasCoordinates"];this.points.forEach(e=>{let{x:t=void 0,y:s=void 0}=e;var r=isNumber(e.insetIndex)&&a.insets[e.insetIndex].getSVGTransform()||n,i=this.projectPoint(e.options)||e.properties&&this.projectPoint(e.properties);let o;i?(t=i.x,s=i.y):e.bounds&&(t=e.bounds.midX,s=e.bounds.midY,r&&isNumber(t)&&isNumber(s)&&(e.plotX=t*r.scaleX+r.translateX,e.plotY=s*r.scaleY+r.translateY,o=!0)),isNumber(t)&&isNumber(s)?o||(i=a.projectedUnitsToPixels({x:t,y:s}),e.plotX=i.x,e.plotY=p?i.y:this.chart.plotHeight-i.y):e.y=e.plotX=e.plotY=void 0,e.isInside=this.isPointInside(e),e.zone=this.zones.length?e.getZone():void 0})}fireEvent(this,"afterTranslate")}}MapPointSeries.defaultOptions=merge(ScatterSeries.defaultOptions,MapPointSeriesDefaults);const mapmarker=(e,t,s,r,i)=>{var o=i&&"legend"===i.context;let a,n;o?(a=e+s/2,n=t+r):i&&"number"==typeof i.anchorX&&"number"==typeof i.anchorY?(a=i.anchorX,n=i.anchorY):(a=e+s/2,n=t+r/2,t-=r);i=o?r/3:r/2;return[["M",a,n],["C",a,n,a-i,t+1.5*i,a-i,t+i],["A",i,i,1,1,1,a+i,t+i],["C",a+i,t+1.5*i,a,n,a,n],["Z"]]};SVGRenderer.prototype.symbols.mapmarker=mapmarker,extend(MapPointSeries.prototype,{type:"mappoint",axisTypes:["colorAxis"],forceDL:!0,isCartesian:!1,pointClass:MapPointPoint,searchPoint:noop,useMapGeometry:!0}),SeriesRegistry.registerSeriesType("mappoint",MapPointSeries);export default MapPointSeries;