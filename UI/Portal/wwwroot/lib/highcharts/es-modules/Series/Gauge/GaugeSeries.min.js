"use strict";import GaugePoint from"./GaugePoint.js";import H from"../../Core/Globals.js";const noop=H["noop"];import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{series:Series,seriesTypes:{column:ColumnSeries}}=SeriesRegistry;import U from"../../Core/Utilities.js";const{clamp,isNumber,extend,merge,pick,pInt,defined}=U;class GaugeSeries extends Series{constructor(){super(...arguments),this.data=void 0,this.points=void 0,this.options=void 0,this.yAxis=void 0}translate(){const e=this,p=e.yAxis,h=e.options,c=p.center;e.generatePoints(),e.points.forEach(e=>{var t=merge(h.dial,e.dial),r=pInt(t.radius)*c[2]/200,o=pInt(t.baseLength)*r/100,i=pInt(t.rearLength)*r/100,a=t.baseWidth,s=t.topWidth;let n=h.overshoot,d=p.startAngleRad+p.translate(e.y,void 0,void 0,void 0,!0);!isNumber(n)&&!1!==h.wrap||(n=isNumber(n)?n/180*Math.PI:0,d=clamp(d,p.startAngleRad-n,p.endAngleRad+n)),d=180*d/Math.PI,e.shapeType="path";t=t.path||[["M",-i,-a/2],["L",o,-a/2],["L",r,-s/2],["L",r,s/2],["L",o,a/2],["L",-i,a/2],["Z"]];e.shapeArgs={d:t,translateX:c[0],translateY:c[1],rotation:d},e.plotX=c[0],e.plotY=c[1],defined(e.y)&&p.max-p.min&&(e.percentage=(e.y-p.min)/(p.max-p.min)*100)})}drawPoints(){const a=this,s=a.chart,e=a.yAxis.center,t=a.pivot,n=a.options,r=n.pivot,d=s.renderer;a.points.forEach(e=>{const t=e.graphic,r=e.shapeArgs,o=r.d,i=merge(n.dial,e.dial);t?(t.animate(r),r.d=o):e.graphic=d[e.shapeType](r).addClass("highcharts-dial").add(a.group),s.styledMode||e.graphic[t?"animate":"attr"]({stroke:i.borderColor,"stroke-width":i.borderWidth,fill:i.backgroundColor})}),t?t.animate({translateX:e[0],translateY:e[1]}):r&&(a.pivot=d.circle(0,0,r.radius).attr({zIndex:2}).addClass("highcharts-pivot").translate(e[0],e[1]).add(a.group),s.styledMode||a.pivot.attr({fill:r.backgroundColor,stroke:r.borderColor,"stroke-width":r.borderWidth}))}animate(e){const r=this;e||r.points.forEach(e=>{const t=e.graphic;t&&(t.attr({rotation:180*r.yAxis.startAngleRad/Math.PI}),t.animate({rotation:e.shapeArgs.rotation},r.options.animation))})}render(){this.group=this.plotGroup("group","series",this.visible?"inherit":"hidden",this.options.zIndex,this.chart.seriesGroup),Series.prototype.render.call(this),this.group.clip(this.chart.clipRect)}setData(e,t){Series.prototype.setData.call(this,e,!1),this.processData(),this.generatePoints(),pick(t,!0)&&this.chart.redraw()}hasData(){return!!this.points.length}}GaugeSeries.defaultOptions=merge(Series.defaultOptions,{dataLabels:{borderColor:"#cccccc",borderRadius:3,borderWidth:1,crop:!1,defer:!1,enabled:!0,verticalAlign:"top",y:15,zIndex:2},dial:{backgroundColor:"#000000",baseLength:"70%",baseWidth:3,borderColor:"#cccccc",borderWidth:0,radius:"80%",rearLength:"10%",topWidth:1},pivot:{radius:5,borderWidth:0,borderColor:"#cccccc",backgroundColor:"#000000"},tooltip:{headerFormat:""},showInLegend:!1}),extend(GaugeSeries.prototype,{angular:!0,directTouch:!0,drawGraph:noop,drawTracker:ColumnSeries.prototype.drawTracker,fixedBox:!0,forceDL:!0,noSharedTooltip:!0,pointClass:GaugePoint,trackerGroups:["group","dataLabelsGroup"]}),SeriesRegistry.registerSeriesType("gauge",GaugeSeries);export default GaugeSeries;