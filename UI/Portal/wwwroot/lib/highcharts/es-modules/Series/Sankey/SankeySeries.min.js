"use strict";import H from"../../Core/Globals.js";import NodesComposition from"../NodesComposition.js";import SankeyPoint from"./SankeyPoint.js";import SankeySeriesDefaults from"./SankeySeriesDefaults.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";import SankeyColumnComposition from"./SankeyColumnComposition.js";const{column:ColumnSeries,line:LineSeries}=SeriesRegistry.seriesTypes;import Color from"../../Core/Color/Color.js";const color=Color["parse"];import TU from"../TreeUtilities.js";const getLevelOptions=TU["getLevelOptions"];import U from"../../Core/Utilities.js";const{clamp,extend,isObject,merge,pick,relativeLength,stableSort}=U;class SankeySeries extends ColumnSeries{constructor(){super(...arguments),this.colDistance=void 0,this.data=void 0,this.group=void 0,this.nodeLookup=void 0,this.nodePadding=void 0,this.nodes=void 0,this.nodeWidth=void 0,this.options=void 0,this.points=void 0,this.translationFactor=void 0}static getDLOptions(o){var t=isObject(o.optionsPoint)?o.optionsPoint.dataLabels:{},o=isObject(o.level)?o.level.dataLabels:{};return merge({style:{}},o,t)}createNodeColumns(){const t=[];for(const o of this.nodes)o.setNodeColumn(),t[o.column]||(t[o.column]=SankeyColumnComposition.compose([],this)),t[o.column].push(o);for(let o=0;o<t.length;o++)void 0===t[o]&&(t[o]=SankeyColumnComposition.compose([],this));return t}order(o,t){if(void 0===o.level){o.level=t;for(const e of o.linksFrom)e.toNode&&this.order(e.toNode,t+1)}}generatePoints(){if(NodesComposition.generatePoints.apply(this,arguments),this.orderNodes){for(const o of this.nodes)0===o.linksTo.length&&this.order(o,0);stableSort(this.nodes,(o,t)=>o.level-t.level)}}getNodePadding(){let o=this.options.nodePadding||0;var t;return o=this.nodeColumns&&(t=this.nodeColumns.reduce((o,t)=>Math.max(o,t.length),0))*o>this.chart.plotSizeY?this.chart.plotSizeY/t:o}hasData(){return!!this.processedXData.length}pointAttribs(o,t){if(!o)return{};const e=this,i=(o.isNode?o:o.fromNode).level,s=e.mapOptionsToLevel[i||0]||{},r=o.options,n=s.states&&s.states[t||""]||{},l=["colorByPoint","borderColor","borderWidth","linkOpacity","opacity"].reduce((o,t)=>(o[t]=pick(n[t],r[t],s[t],e.options[t]),o),{}),a=pick(n.color,r.color,(l.colorByPoint?o:s).color);return o.isNode?{fill:a,stroke:l.borderColor,"stroke-width":l.borderWidth,opacity:l.opacity}:{fill:Color.parse(a).setOpacity(l.linkOpacity).get()}}drawTracker(){ColumnSeries.prototype.drawTracker.call(this,this.points),ColumnSeries.prototype.drawTracker.call(this,this.nodes)}drawPoints(){ColumnSeries.prototype.drawPoints.call(this,this.points),ColumnSeries.prototype.drawPoints.call(this,this.nodes)}drawDataLabels(){ColumnSeries.prototype.drawDataLabels.call(this,this.points),ColumnSeries.prototype.drawDataLabels.call(this,this.nodes)}translate(){this.processedXData||this.processData(),this.generatePoints(),this.nodeColumns=this.createNodeColumns(),this.nodeWidth=relativeLength(this.options.nodeWidth,this.chart.plotSizeX);const e=this,o=this.chart,t=this.options,i=this.nodeWidth,s=this.nodeColumns;this.nodePadding=this.getNodePadding(),this.translationFactor=s.reduce((o,t)=>Math.min(o,t.sankeyColumn.getTranslationFactor(e)),1/0),this.colDistance=(o.plotSizeX-i-t.borderWidth)/Math.max(1,s.length-1),e.mapOptionsToLevel=getLevelOptions({from:1,levels:t.levels,to:s.length-1,defaults:{borderColor:t.borderColor,borderRadius:t.borderRadius,borderWidth:t.borderWidth,color:e.color,colorByPoint:t.colorByPoint,levelIsConstant:!0,linkColor:t.linkColor,linkLineWidth:t.linkLineWidth,linkOpacity:t.linkOpacity,states:t.states}});for(const r of s)for(const n of r)e.translateNode(n,r);for(const l of this.nodes)for(const a of l.linksFrom)(a.weight||a.isNull)&&a.to&&(e.translateLink(a),a.allowShadow=!1)}translateLink(e){var o,t,i,s,r,n,l,a,d,h,p,c,m,u,y,S,C,g,f=(o,t)=>{t=o.offset(e,t)*P;return Math.min(o.nodeY+t,o.nodeY+(o.shapeArgs&&o.shapeArgs.height||0)-M)};const k=e.fromNode,v=e.toNode,L=this.chart,b=L["inverted"],P=this.translationFactor,N=this.options,w=pick(e.linkColorMode,N.linkColorMode),x=(L.inverted?-this.colDistance:this.colDistance)*N.curveFactor,O=k.nodeX,T=v.nodeX,D=e.outgoing;let M=Math.max(e.weight*P,this.options.minLinkWidth),W=f(k,"linksFrom"),j=f(v,"linksTo"),z=this.nodeWidth,X=T>O+z;L.inverted&&(W=L.plotSizeY-W,j=(L.plotSizeY||0)-j,z=-z,M=-M,X=T<O),e.shapeType="path",e.linkBase=[W,W+M,j,j+M],X&&"number"==typeof j?e.shapeArgs={d:[["M",O+z,W],["C",O+z+x,W,T-x,j,T,j],["L",T+(D?z:0),j+M/2],["L",T,j+M],["C",T-x,j+M,O+z+x,W+M,O+z,W+M],["Z"]]}:"number"==typeof j&&(f=L.plotHeight-W-M,o=T-20-M,t=T-20,r=(s=(i=O+z)+20)+M,d=(a=(f=(l=(n=(C=W)+M)+20)+f)+20)+M,c=(p=(h=j)+M)+20,g=n-.7*M,m=a+.7*M,u=p-.7*M,y=T-.7*M,S=i+.7*M,e.shapeArgs={d:[["M",i,C],["C",S,C,r,g,r,l],["L",r,f],["C",r,m,S,d,i,d],["L",T,d],["C",y,d,o,m,o,f],["L",o,c],["C",o,u,y,h,T,h],["L",T,p],["C",t,p,t,p,t,c],["L",t,f],["C",t,a,t,a,T,a],["L",i,a],["C",s,a,s,a,s,f],["L",s,l],["C",s,n,s,n,i,n],["Z"]]}),e.dlBox={x:O+(T-O+z)/2,y:W+(j-W)/2,height:M,width:0},e.tooltipPos=L.inverted?[L.plotSizeY-e.dlBox.y-M/2,L.plotSizeX-e.dlBox.x]:[e.dlBox.x,e.dlBox.y+M/2],e.y=e.plotY=1,e.x=e.plotX=1,e.options.color||("from"===w?e.color=k.color:"to"===w?e.color=v.color:"gradient"===w&&(C=color(k.color).get(),g=color(v.color).get(),e.color={linearGradient:{x1:1,x2:0,y1:0,y2:0},stops:[[0,b?C:g],[1,b?g:C]]}))}translateNode(s,r){var o=this.translationFactor,n=this.chart,l=this.options,{borderRadius:a,borderWidth:d=0}=l,t=s.getSum(),h=Math.max(Math.round(t*o),this.options.minLinkWidth),p=Math.round(this.nodeWidth),e=Math.round(d)%2/2,c=r.sankeyColumn.offset(s,o),r=Math.floor(pick(c.absoluteTop,r.sankeyColumn.top(o)+c.relativeTop))+e,o=Math.floor(this.colDistance*s.column+d/2)+relativeLength(s.options[n.inverted?"offsetVertical":"offsetHorizontal"]||0,p)+e,c=n.inverted?n.plotSizeX-o:o;if(s.sum=t){s.shapeType="roundedRect";let o=s.nodeX=c,t=s.nodeY=r,e=s.options.width||l.width||p,i=s.options.height||l.height||h;d=clamp(relativeLength("object"==typeof a?a.radius:a||0,e),0,h/2);n.inverted&&(o=c-p,t=n.plotSizeY-r-h,e=s.options.height||l.height||p,i=s.options.width||l.width||h),s.dlOptions=SankeySeries.getDLOptions({level:this.mapOptionsToLevel[s.level],optionsPoint:s.options}),s.plotX=1,s.plotY=1,s.tooltipPos=n.inverted?[n.plotSizeY-t-i/2,n.plotSizeX-o-e/2]:[o+e/2,t+i/2],s.shapeArgs={x:o,y:t,width:e,height:i,r:d,display:s.hasShape()?"":"none"}}else s.dlOptions={enabled:!1}}}SankeySeries.defaultOptions=merge(ColumnSeries.defaultOptions,SankeySeriesDefaults),NodesComposition.compose(SankeyPoint,SankeySeries),extend(SankeySeries.prototype,{animate:LineSeries.prototype.animate,createNode:NodesComposition.createNode,forceDL:!0,invertible:!0,isCartesian:!1,orderNodes:!0,noSharedTooltip:!0,pointArrayMap:["from","to","weight"],pointClass:SankeyPoint,searchPoint:H.noop}),SeriesRegistry.registerSeriesType("sankey",SankeySeries);export default SankeySeries;