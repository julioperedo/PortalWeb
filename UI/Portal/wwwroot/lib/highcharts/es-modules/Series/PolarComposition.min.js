"use strict";import A from"../Core/Animation/AnimationUtilities.js";const animObject=A["animObject"];import H from"../Core/Globals.js";import Series from"../Core/Series/Series.js";import Pane from"../Extensions/Pane.js";import RadialAxis from"../Core/Axis/RadialAxis.js";import U from"../Core/Utilities.js";const{addEvent,defined,find,isNumber,merge,pick,relativeLength,splat,uniqueKey,wrap}=U,composedMembers=[];function clipCircle(t,e,i,a,r){const n=uniqueKey(),o=t.createElement("clipPath").attr({id:n}).add(t.defs),s=(r?t.arc(e,i,a,r,0,2*Math.PI):t.circle(e,i,a)).add(o);return s.id=n,s.clipPath=o,s}function findAlignments(t,e){let i,a;return null===e.align&&(i=20<t&&t<160?"left":200<t&&t<340?"right":"center",e.align=i),null===e.verticalAlign&&(a=t<45||315<t?"bottom":135<t&&t<225?"top":"middle",e.verticalAlign=a),e}function getConnectors(t,e,i,a){var r=1.5,n=2.5,o=a?1:0;let s,l,p,h,c,d;var e=(s=0<=e&&e<=t.length-1?e:e<0?t.length-1+e:0)-1<0?t.length-(1+o):s-1,o=s+1>t.length-1?o:s+1,m=t[e],o=t[o],g=m.plotX,m=m.plotY,u=o.plotX,o=o.plotY,f=t[s].plotX,x=t[s].plotY,g=(l=(r*f+g)/n,p=(r*x+m)/n,h=(r*f+u)/n,c=(r*x+o)/n,Math.sqrt(Math.pow(l-f,2)+Math.pow(p-x,2))),m=Math.sqrt(Math.pow(h-f,2)+Math.pow(c-x,2)),u=Math.atan2(p-x,l-f),r=Math.atan2(c-x,h-f);d=Math.PI/2+(u+r)/2,Math.abs(u-d)>Math.PI/2&&(d-=Math.PI),l=f+Math.cos(d)*g,p=x+Math.sin(d)*g;const A={rightContX:f+Math.cos(Math.PI+d)*m,rightContY:x+Math.sin(Math.PI+d)*m,leftContX:l,leftContY:p,plotX:f,plotY:x};return i&&(A.prevPointCont=getConnectors(t,e,!1,a)),A}function onChartAfterDrawChartBox(){(this.pane||[]).forEach(t=>{t.render()})}function onChartAfterInit(t){const e=t.args[0].xAxis,i=t.args[0].yAxis,a=t.args[0].chart;e&&i&&("polygon"===i.gridLineInterpolation?(e.startOnTick=!0,e.endOnTick=!0):"polygon"===e.gridLineInterpolation&&a.inverted&&(i.startOnTick=!0,i.endOnTick=!0))}function onChartGetAxes(){this.pane||(this.pane=[]),this.options.pane=splat(this.options.pane),this.options.pane.forEach(t=>{new Pane(t,this)},this)}function onPointerGetSelectionBox(t){const e=t.args.marker,i=this.chart.xAxis[0],a=this.chart.yAxis[0],r=this.chart.inverted,n=r?a:i,o=r?i:a;var s,l,p,h;this.chart.polar&&(t.preventDefault(),s=(e.attr?e.attr("start"):e.start)-n.startAngleRad,l=e.attr?e.attr("r"):e.r,p=(e.attr?e.attr("end"):e.end)-n.startAngleRad,h=e.attr?e.attr("innerR"):e.innerR,t.result.x=s+n.pos,t.result.width=p-s,t.result.y=o.len+o.pos-h,t.result.height=h-l)}function onPointerGetSelectionMarkerAttrs(t){var r=this.chart;if(r.polar&&r.hoverPane&&r.hoverPane.axis){t.preventDefault();const s=r.hoverPane.center,i=this.mouseDownX||0,l=this.mouseDownY||0,p=t.args.chartY,h=t.args.chartX,c=2*Math.PI,d=r.hoverPane.axis.startAngleRad,m=r.hoverPane.axis.endAngleRad,g=(r.inverted?r.xAxis:r.yAxis)[0],u={};let a="arc";if(u.x=s[0]+r.plotLeft,u.y=s[1]+r.plotTop,this.zoomHor){var n=0<d?m-d:Math.abs(d)+Math.abs(m);let t=Math.atan2(l-r.plotTop-s[1],i-r.plotLeft-s[0])-d,e=Math.atan2(p-r.plotTop-s[1],h-r.plotLeft-s[0])-d;u.r=s[2]/2,u.innerR=s[3]/2,t<=0&&(t+=c),e<=0&&(e+=c),e<t&&(e=[t,t=e][0]),n<c&&d+e>m+(c-n)/2&&(e=t,t=d<=0?d:0);var n=u.start=Math.max(t+d,d),o=u.end=Math.min(e+d,m);if("polygon"===g.options.gridLineInterpolation){const f=r.hoverPane.axis,x=(f.tickInterval,n-f.startAngleRad+f.pos),A=o-n;let t=g.getPlotLinePath({value:g.max}),e=f.toValue(x),i=f.toValue(x+A);e<f.getExtremes().min&&({min:o,max:n}=f.getExtremes(),e=n-(o-e)),i<f.getExtremes().min&&({min:n,max:o}=f.getExtremes(),i=o-(n-i)),i<e&&(i=[e,e=i][0]),(t=trimPath(t,e,i,f)).push(["L",s[0]+r.plotLeft,r.plotTop+s[1]]),u.d=t,a="path"}}if(this.zoomVert){const P=(r.inverted?r.xAxis:r.yAxis)[0];let t=Math.sqrt(Math.pow(i-r.plotLeft-s[0],2)+Math.pow(l-r.plotTop-s[1],2)),e=Math.sqrt(Math.pow(h-r.plotLeft-s[0],2)+Math.pow(p-r.plotTop-s[1],2));e<t&&(t=[e,e=t][0]),e>s[2]/2&&(e=s[2]/2),t<s[3]/2&&(t=s[3]/2),this.zoomHor||(u.start=d,u.end=m),u.r=e,u.innerR=t,"polygon"===P.options.gridLineInterpolation&&(o=P.toValue(P.len+P.pos-t),n=P.toValue(P.len+P.pos-e),n=P.getPlotLinePath({value:n}).concat(P.getPlotLinePath({value:o,reverse:!0})),u.d=n,a="path")}if(this.zoomHor&&this.zoomVert&&"polygon"===g.options.gridLineInterpolation){const e=r.hoverPane.axis,v=u.start||0,y=u.end||0,M=v-e.startAngleRad+e.pos,C=y-v,w=e.toValue(M),X=e.toValue(M+C);if(u.d instanceof Array){let t=u.d.slice(0,u.d.length/2),e=u.d.slice(u.d.length/2,u.d.length);e=[...e].reverse();o=r.hoverPane.axis;t=trimPath(t,w,X,o),(e=trimPath(e,w,X,o))&&(e[0][0]="L"),e=[...e].reverse(),u.d=t.concat(e),a="path"}}t.attrs=u,t.shapeType=a}}function onSeriesAfterInit(){var t=this.chart;t.polar&&(this.polar=new PolarAdditions(this),t.inverted&&(this.isRadialSeries=!0,this.is("column")&&(this.isRadialBar=!0)))}function onSeriesAfterTranslate(){if(this.chart.polar&&this.xAxis){const e=this,{xAxis:i,yAxis:a}=e,r=e.chart,n=(e.kdByAngle=r.tooltip&&r.tooltip.shared,e.kdByAngle?e.searchPoint=searchPointByAngle:e.options.findNearestPointBy="xy",e.points);let t=n.length;for(;t--;)e.is("column")||e.is("columnrange")||e.polar.toXY(n[t]),r.hasParallelCoordinates||e.yAxis.reversed||(pick(n[t].y,Number.MIN_VALUE)<a.min||n[t].x<i.min||n[t].x>i.max?(n[t].isNull=!0,n[t].plotY=NaN):n[t].isNull=n[t].isValid&&!n[t].isValid());this.hasClipCircleSetter||(this.hasClipCircleSetter=!!e.eventsToUnbind.push(addEvent(e,"afterRender",function(){var t;r.polar&&!1!==this.options.clip&&(t=this.yAxis.pane.center,this.clipCircle?this.clipCircle.animate({x:t[0],y:t[1],r:t[2]/2,innerR:t[3]/2}):this.clipCircle=clipCircle(r.renderer,t[0],t[1],t[2]/2,t[3]/2),this.group.clip(this.clipCircle),this.setClip=H.noop)})))}}function searchPointByAngle(t){var e=this.chart,i=this.xAxis,i=i.pane&&i.pane.center,a=t.chartX-(i&&i[0]||0)-e.plotLeft,t=t.chartY-(i&&i[1]||0)-e.plotTop;return this.searchKDTree({clientX:180+Math.atan2(a,t)*(-180/Math.PI)})}function trimPath(t,e,i,a){const r=a.tickInterval,n=a.tickPositions;let o=find(n,t=>i<=t),s=find([...n].reverse(),t=>t<=e);return defined(o)||(o=n[n.length-1]),defined(s)||(s=n[0],o+=r,t[0][0]="L",t.unshift(t[t.length-3])),(t=t.slice(n.indexOf(s),n.indexOf(o)+1))[0][0]="M",t}function wrapChartGet(t,e){return find(this.pane||[],function(t){return t.options.id===e})||t.call(this,e)}function wrapColumnSeriesAlignDataLabel(t,e,i,a,r,n){const o=this.chart,s=pick(a.inside,!!this.options.stacking);var l,p;o.polar?(l=e.rectPlotX/Math.PI*180,o.inverted?(this.forceDL=o.isInsidePlot(e.plotX,e.plotY),s&&e.shapeArgs?(p=e.shapeArgs,p=this.yAxis.postTranslate(((p.start||0)+(p.end||0))/2-this.xAxis.startAngleRad,e.barX+e.pointWidth/2),r=merge(r,{x:p.x-o.plotLeft,y:p.y-o.plotTop})):e.tooltipPos&&(r=merge(r,{x:e.tooltipPos[0],y:e.tooltipPos[1]})),a.align=pick(a.align,"center"),a.verticalAlign=pick(a.verticalAlign,"middle")):a=findAlignments(l,a),Series.prototype.alignDataLabel.call(this,e,i,a,r,n),this.isRadialBar&&e.shapeArgs&&e.shapeArgs.start===e.shapeArgs.end?i.hide():i.show()):t.call(this,e,i,a,r,n)}function onAfterColumnTranslate(){const t=this,e=t.options,i=e.stacking,a=t.chart,r=t.xAxis,n=t.yAxis,o=n.reversed,s=n.center,l=r.startAngleRad,p=r.endAngleRad,h=p-l;e.threshold;let c,d=0,m,g,u,f,x,A=0,P=0,v,y,M,C,w,X,Y,b;if(r.isRadial)for(m=t.points,u=m.length,f=n.translate(n.min),x=n.translate(n.max),c=e.threshold||0,a.inverted&&isNumber(c)&&(d=n.translate(c),defined(d)&&(d<0?d=0:d>h&&(d=h),t.translatedThreshold=d+l));u--;){var T;g=m[u],X=g.barX,y=g.x,M=g.y,g.shapeType="arc",a.inverted?(g.plotY=n.translate(M),i&&n.stacking?(w=n.stacking.stacks[(M<0?"-":"")+t.stackKey],t.visible&&w&&w[y]&&(g.isNull||(C=w[y].points[t.getStackIndicator(void 0,y,t.index).key],A=n.translate(C[0]),P=n.translate(C[1]),defined(A)&&(A=U.clamp(A,0,h))))):(A=d,P=g.plotY),A>P&&(P=[A,A=P][0]),o?P>f?P=f:A<x?A=x:(A>f||P<x)&&(A=P=h):A<f?A=f:P>x?P=x:(P<f||A>x)&&(A=P=0),n.min>n.max&&(A=P=o?h:0),A+=l,P+=l,s&&(g.barX=X+=s[3]/2),Y=Math.max(X,0),b=Math.max(X+g.pointWidth,0),T="object"==typeof(T=e.borderRadius)?T.radius:T,T=relativeLength(T||0,b-Y),g.shapeArgs={x:s[0],y:s[1],r:b,innerR:Y,start:A,end:P,borderRadius:T},g.opacity=A===P?0:void 0,g.plotY=(defined(t.translatedThreshold)&&(A<t.translatedThreshold?A:P))-l):(A=X+l,g.shapeArgs=t.polar.arc(g.yBottom,g.plotY,A,A+g.pointWidth),g.shapeArgs.borderRadius=0),t.polar.toXY(g),a.inverted?(v=n.postTranslate(g.rectPlotY,X+g.pointWidth/2),g.tooltipPos=[v.x-a.plotLeft,v.y-a.plotTop]):g.tooltipPos=[g.plotX,g.plotY],s&&(g.ttBelow=g.plotY>s[1])}}function wrapLineSeriesGetGraphPath(t,e){const i=this;let a,r;if(this.chart.polar){e=e||this.points;for(let t=0;t<e.length;t++)if(!e[t].isNull){a=t;break}!1!==this.options.connectEnds&&void 0!==a&&(this.connectEnds=!0,e.splice(e.length,0,e[a]),r=!0),e.forEach(t=>{void 0===t.polarPlotY&&i.polar.toXY(t)})}t=t.apply(this,[].slice.call(arguments,1));return r&&e.pop(),t}function wrapPointerGetCoordinates(t,r){const n=this.chart;let o={xAxis:[],yAxis:[]};return n.polar?n.axes.forEach(t=>{var e,i,a;"colorAxis"!==t.coll&&(e=t.isXAxis,a=t.center,i=r.chartX-a[0]-n.plotLeft,a=r.chartY-a[1]-n.plotTop,o[e?"xAxis":"yAxis"].push({axis:t,value:t.translate(e?Math.PI-Math.atan2(i,a):Math.sqrt(Math.pow(i,2)+Math.pow(a,2)),!0)}))}):o=t.call(this,r),o}function wrapPointerPinch(t,e){this.chart.polar||t.call(this,e)}function wrapSeriesAnimate(t,e){const i=this,a=this.chart,r=this.group,n=this.markerGroup,o=this.xAxis&&this.xAxis.center,s=a.plotLeft,l=a.plotTop;let p=this.options.animation,h,c,d,m,g,u;a.polar?i.isRadialBar?e||(i.startAngleRad=pick(i.translatedThreshold,i.xAxis.startAngleRad),H.seriesTypes.pie.prototype.animate.call(i,e)):(p=animObject(p),i.is("column")?e||(c=o[3]/2,i.points.forEach(t=>{d=t.graphic,m=t.shapeArgs,g=m&&m.r,u=m&&m.innerR,d&&m&&(d.attr({r:c,innerR:c}),d.animate({r:g,innerR:u},i.options.animation))})):e?(h={translateX:o[0]+s,translateY:o[1]+l,scaleX:.001,scaleY:.001},r.attr(h),n&&n.attr(h)):(h={translateX:s,translateY:l,scaleX:1,scaleY:1},r.animate(h,p),n&&n.animate(h,p))):t.call(this,e)}function wrapSplineSeriesGetPointSpline(t,e,i,a){let r,n;var o,s;return r=this.chart.polar?a?(o=(n=getConnectors(e,a,!0,this.connectEnds)).prevPointCont&&n.prevPointCont.rightContX,s=n.prevPointCont&&n.prevPointCont.rightContY,["C",isNumber(o)?o:n.plotX,isNumber(s)?s:n.plotY,isNumber(n.leftContX)?n.leftContX:n.plotX,isNumber(n.leftContY)?n.leftContY:n.plotY,n.plotX,n.plotY]):["M",i.plotX,i.plotY]:t.call(this,e,i,a)}class PolarAdditions{static compose(t,e,i,a,r,n,o,s,l){if(RadialAxis.compose(t,r),U.pushUnique(composedMembers,e)&&(addEvent(e,"afterDrawChartBox",onChartAfterDrawChartBox),addEvent(e,"getAxes",onChartGetAxes),addEvent(e,"init",onChartAfterInit),t=e.prototype,wrap(t,"get",wrapChartGet)),U.pushUnique(composedMembers,i)&&(r=i.prototype,wrap(r,"getCoordinates",wrapPointerGetCoordinates),wrap(r,"pinch",wrapPointerPinch),addEvent(i,"getSelectionMarkerAttrs",onPointerGetSelectionMarkerAttrs),addEvent(i,"getSelectionBox",onPointerGetSelectionBox)),U.pushUnique(composedMembers,a)&&(addEvent(a,"afterInit",onSeriesAfterInit),addEvent(a,"afterTranslate",onSeriesAfterTranslate,{order:2}),addEvent(a,"afterColumnTranslate",onAfterColumnTranslate,{order:4}),e=a.prototype,wrap(e,"animate",wrapSeriesAnimate)),o&&U.pushUnique(composedMembers,o)&&(t=o.prototype,wrap(t,"alignDataLabel",wrapColumnSeriesAlignDataLabel),wrap(t,"animate",wrapSeriesAnimate)),s&&U.pushUnique(composedMembers,s)&&(r=s.prototype,wrap(r,"getGraphPath",wrapLineSeriesGetGraphPath)),l&&U.pushUnique(composedMembers,l)){i=l.prototype;if(wrap(i,"getPointSpline",wrapSplineSeriesGetPointSpline),n&&U.pushUnique(composedMembers,n)){const p=n.prototype;p.getPointSpline=i.getPointSpline}}}constructor(t){this.series=t}arc(t,e,i,a){var r=this.series,n=r.xAxis.center,o=r.yAxis.len,s=n[3]/2;let l=o-e+s,p=o-pick(t,o)+s;return r.yAxis.reversed&&(l<0&&(l=s),p<0&&(p=s)),{x:n[0],y:n[1],r:l,innerR:p,start:i,end:a}}toXY(t){const e=this.series,i=e.chart,a=e.xAxis,r=e.yAxis,n=t.plotX,o=i.inverted,s=t.y;let l=t.plotY,p=o?n:r.len-l,h;var c;o&&e&&!e.isRadialBar&&(t.plotY=l=isNumber(s)?r.translate(s):0),t.rectPlotX=n,t.rectPlotY=l,r.center&&(p+=r.center[3]/2),isNumber(l)&&(c=o?r.postTranslate(l,p):a.postTranslate(n,p),t.plotX=t.polarPlotX=c.x-i.plotLeft,t.plotY=t.polarPlotY=c.y-i.plotTop),e.kdByAngle?((h=(n/Math.PI*180+a.pane.options.startAngle)%360)<0&&(h+=360),t.clientX=h):t.clientX=t.plotX}}export default PolarAdditions;