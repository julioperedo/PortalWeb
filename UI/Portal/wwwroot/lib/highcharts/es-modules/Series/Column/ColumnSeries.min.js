"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const animObject=A["animObject"];import Color from"../../Core/Color/Color.js";const color=Color["parse"];import ColumnSeriesDefaults from"./ColumnSeriesDefaults.js";import H from"../../Core/Globals.js";const{hasTouch,noop}=H;import Series from"../../Core/Series/Series.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";import U from"../../Core/Utilities.js";const{clamp,defined,extend,fireEvent,isArray,isNumber,merge,pick,objectEach,relativeLength}=U;class ColumnSeries extends Series{constructor(){super(...arguments),this.borderWidth=void 0,this.data=void 0,this.group=void 0,this.options=void 0,this.points=void 0}animate(t){const o=this,e=this.yAxis,s=e.pos,i=o.options,r=this.chart.inverted,n={},a=r?"translateX":"translateY";let p,l;t?(n.scaleY=.001,l=clamp(e.toPixels(i.threshold),s,s+e.len),r?n.translateX=l-e.len:n.translateY=l,o.clipBox&&o.setClip(),o.group.attr(n)):(p=Number(o.group.attr(a)),o.group.animate({scaleY:1},extend(animObject(o.options.animation),{step:function(t,e){o.group&&(n[a]=p+e.pos*(s-p),o.group.attr(n))}})))}init(t,e){super.init.apply(this,arguments);const o=this;(t=o.chart).hasRendered&&t.series.forEach(function(t){t.type===o.type&&(t.isDirty=!0)})}getColumnMetrics(){const i=this,t=i.options,e=i.xAxis,r=i.yAxis,o=e.options.reversedStacks,s=e.reversed&&!o||!e.reversed&&o,n={};let a,p=0;!1===t.grouping?p=1:i.chart.series.forEach(function(t){var e=t.yAxis,o=t.options;let s;t.type===i.type&&t.reserveSpace()&&r.len===e.len&&r.pos===e.pos&&(o.stacking&&"group"!==o.stacking?(a=t.stackKey,void 0===n[a]&&(n[a]=p++),s=n[a]):!1!==o.grouping&&(s=p++),t.columnIndex=s)});var l=Math.min(Math.abs(e.transA)*(!e.brokenAxis?.hasBreaks&&e.ordinal?.slope||t.pointRange||e.closestPointRange||e.tickInterval||1),e.len),h=l*t.groupPadding,d=(l-2*h)/(p||1),c=Math.min(t.maxPointWidth||e.len,pick(t.pointWidth,d*(1-2*t.pointPadding))),u=(i.columnIndex||0)+(s?1:0);return i.columnMetrics={width:c,offset:(d-c)/2+(h+u*d-l/2)*(s?-1:1),paddedWidth:d,columnCount:p},i.columnMetrics}crispCol(t,e,o,s){this.chart;var i=this.borderWidth,r=-(i%2?.5:0),i=i%2?.5:1,r=(this.options.crisp&&(o=Math.round(t+o)+r-(t=Math.round(t)+r)),Math.round(e+s)+i),n=Math.abs(e)<=.5&&.5<r;return s=r-(e=Math.round(e)+i),n&&s&&(--e,s+=1),{x:t,y:e,width:o,height:s}}adjustForMissingColumns(t,e,r,o){if(!r.isNull&&1<o.columnCount){const a=this.xAxis.series.filter(t=>t.visible).map(t=>t.index);let s=0,i=0;objectEach(this.xAxis.stacking?.stacks,t=>{if("number"==typeof r.x){const e=t[r.x.toString()];if(e){t=e.points[this.index];if(isArray(t)){const o=Object.keys(e.points).filter(t=>!t.match(",")&&e.points[t]&&1<e.points[t].length).map(parseFloat).filter(t=>-1!==a.indexOf(t)).sort((t,e)=>e-t);s=o.indexOf(this.index),i=o.length}}}});var n=(i-1)*o.paddedWidth+e;t=(r.plotX||0)+n/2-e-s*o.paddedWidth}return t}translate(){const h=this,d=h.chart,c=h.options,t=h.dense=h.closestPointRange*h.xAxis.transA<2,e=h.borderWidth=pick(c.borderWidth,t?0:1),u=h.xAxis,m=h.yAxis,g=c.threshold,f=pick(c.minPointLength,5),y=h.getColumnMetrics(),b=y.width,v=h.pointXOffset=y.offset,x=h.dataMin,C=h.dataMax;let k=h.barW=Math.max(b,1+2*e),S=h.translatedThreshold=m.getThreshold(g);d.inverted&&(S-=.5),c.pointPadding&&(k=Math.ceil(k)),Series.prototype.translate.apply(h),h.points.forEach(function(t){var e=pick(t.yBottom,S),o=999+Math.abs(e),s=t.plotX||0,o=clamp(t.plotY,-o,m.len+o);t.stackBox;let i,r=Math.min(o,e),n=Math.max(o,e)-r,a=b,p=s+v,l=k;f&&Math.abs(n)<f&&(n=f,i=!m.reversed&&!t.negative||m.reversed&&t.negative,isNumber(g)&&isNumber(C)&&t.y===g&&C<=g&&(m.min||0)<g&&(x!==C||(m.max||0)<=g)&&(i=!i,t.negative=!t.negative),r=Math.abs(r-S)>f?e-f:S-(i?f:0)),defined(t.options.pointWidth)&&(a=l=Math.ceil(t.options.pointWidth),p-=Math.round((a-b)/2)),c.centerInCategory&&!c.stacking&&(p=h.adjustForMissingColumns(p,a,t,y)),t.barX=p,t.pointWidth=a,t.tooltipPos=d.inverted?[clamp(m.len+m.pos-d.plotLeft-o,m.pos-d.plotLeft,m.len+m.pos-d.plotLeft),u.len+u.pos-d.plotTop-p-l/2,n]:[u.left-d.plotLeft+p+l/2,clamp(o+m.pos-d.plotTop,m.pos-d.plotTop,m.len+m.pos-d.plotTop),n],t.shapeType=h.pointClass.prototype.shapeType||"roundedRect",t.shapeArgs=h.crispCol(p,t.isNull?S:r,l,t.isNull?0:n)}),fireEvent(this,"afterColumnTranslate")}drawGraph(){this.group[this.dense?"addClass":"removeClass"]("highcharts-dense-data")}pointAttribs(t,e){var o=this.options,s=this.pointAttrToOptions||{},i=s.stroke||"borderColor",s=s["stroke-width"]||"borderWidth";let r,n,a,p=t&&t.color||this.color,l=t&&t[i]||o[i]||p,h=t&&t.options.dashStyle||o.dashStyle,d=t&&t[s]||o[s]||this[s]||0,c=pick(t&&t.opacity,o.opacity,1);t&&this.zones.length&&(n=t.getZone(),p=t.options.color||n&&(n.color||t.nonZonedColor)||this.color,n&&(l=n.borderColor||l,h=n.dashStyle||h,d=n.borderWidth||d)),e&&t&&(a=(r=merge(o.states[e],t.options.states&&t.options.states[e]||{})).brightness,p=r.color||void 0!==a&&color(p).brighten(r.brightness).get()||p,l=r[i]||l,d=r[s]||d,h=r.dashStyle||h,c=pick(r.opacity,c));const u={fill:p,stroke:l,"stroke-width":d,opacity:c};return h&&(u.dashstyle=h),u}drawPoints(t=this.points){const r=this,n=this.chart,a=r.options,p=n.renderer,l=a.animationLimit||250;let h;t.forEach(function(t){var e=t.plotY;let o=t.graphic,s=!!o,i=o&&n.pointCount<l?"animate":"attr";isNumber(e)&&null!==t.y?(h=t.shapeArgs,o&&t.hasNewShapeType()&&(o=o.destroy()),r.enabledDataSorting&&(t.startXPos=r.xAxis.reversed?-(h&&h.width||0):r.xAxis.width),o||(t.graphic=o=p[t.shapeType](h).add(t.group||r.group),o&&r.enabledDataSorting&&n.hasRendered&&n.pointCount<l&&(o.attr({x:t.startXPos}),s=!0,i="animate")),o&&s&&o[i](merge(h)),n.styledMode||o[i](r.pointAttribs(t,t.selected&&"select")).shadow(!1!==t.allowShadow&&a.shadow),o&&(o.addClass(t.getClassName(),!0),o.attr({visibility:t.visible?"inherit":"hidden"}))):o&&(t.graphic=o.destroy())})}drawTracker(t=this.points){function e(t){const e=i.getPointFromEvent(t);void 0!==e&&o.options.enableMouseTracking&&(i.isDirectTouch=!0,e.onMouseOver(t))}const o=this,s=o.chart,i=s.pointer;let r;t.forEach(function(e){r=isArray(e.dataLabels)?e.dataLabels:e.dataLabel?[e.dataLabel]:[],e.graphic&&(e.graphic.element.point=e),r.forEach(function(t){t.div?t.div.point=e:t.element.point=e})}),o._hasTracking||(o.trackerGroups.forEach(function(t){o[t]&&(o[t].addClass("highcharts-tracker").on("mouseover",e).on("mouseout",function(t){i.onTrackerMouseOut(t)}),hasTouch&&o[t].on("touchstart",e),!s.styledMode&&o.options.cursor&&o[t].css({cursor:o.options.cursor}))}),o._hasTracking=!0),fireEvent(this,"afterDrawTracker")}remove(){const e=this,t=e.chart;t.hasRendered&&t.series.forEach(function(t){t.type===e.type&&(t.isDirty=!0)}),Series.prototype.remove.apply(e,arguments)}}ColumnSeries.defaultOptions=merge(Series.defaultOptions,ColumnSeriesDefaults),extend(ColumnSeries.prototype,{directTouch:!0,getSymbol:noop,negStacks:!0,trackerGroups:["group","dataLabelsGroup"]}),SeriesRegistry.registerSeriesType("column",ColumnSeries);export default ColumnSeries;