"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const animObject=A["animObject"];import DependencyWheelPoint from"./DependencyWheelPoint.js";import DependencyWheelSeriesDefaults from"./DependencyWheelSeriesDefaults.js";import H from"../../Core/Globals.js";const deg2rad=H["deg2rad"];import SankeyColumnComposition from"../Sankey/SankeyColumnComposition.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{pie:PieSeries,sankey:SankeySeries}=SeriesRegistry.seriesTypes;import U from"../../Core/Utilities.js";const{extend,merge}=U;class DependencyWheelSeries extends SankeySeries{constructor(){super(...arguments),this.data=void 0,this.options=void 0,this.nodeColumns=void 0,this.nodes=void 0,this.points=void 0}animate(e){var t=this;if(!e){const o=animObject(t.options.animation).duration,n=o/2/t.nodes.length;let e=0;for(const s of t.nodes){const i=s.graphic;i&&(i.attr({opacity:0}),setTimeout(()=>{s.graphic&&s.graphic.animate({opacity:1},{duration:n})},n*e++))}for(const r of t.points){const a=r.graphic;!r.isNode&&a&&a.attr({opacity:0}).animate({opacity:1},t.options.animation)}}}createNode(e){const r=super.createNode(e);return r.getSum=()=>r.linksFrom.concat(r.linksTo).reduce((e,t)=>e+t.weight,0),r.offset=t=>{const o=e=>e.fromNode===r?e.toNode:e.fromNode;let n=0,s=r.linksFrom.concat(r.linksTo),i;s.sort((e,t)=>o(e).index-o(t).index);for(let e=0;e<s.length;e++)if(o(s[e]).index>r.index){s=s.slice(0,e).reverse().concat(s.slice(e).reverse()),i=!0;break}i||s.reverse();for(let e=0;e<s.length;e++){if(s[e]===t)return n;n+=s[e].weight}},r}createNodeColumns(){const e=[SankeyColumnComposition.compose([],this)];for(const t of this.nodes)t.column=0,e[0].push(t);return e}getNodePadding(){return this.options.nodePadding/Math.PI}translate(){const e=this,r=e.options,a=2*Math.PI/(e.chart.plotHeight+e.getNodePadding()),t=e.getCenter(),c=(r.startAngle-90)*deg2rad,o=r.borderRadius,n="object"==typeof o?o.radius:o;super.translate();for(const s of this.nodeColumns[0])if(s.sum){const i=s.shapeArgs,p=t[0],l=t[1],h=t[2]/2,m=h-r.nodeWidth,y=c+a*(i.y||0),g=c+a*((i.y||0)+(i.height||0));s.angle=y+(g-y)/2,s.shapeType="arc",s.shapeArgs={x:p,y:l,r:h,innerR:m,start:y,end:g,borderRadius:n},s.dlBox={x:p+Math.cos((y+g)/2)*(h+m)/2,y:l+Math.sin((y+g)/2)*(h+m)/2,width:1,height:1};for(const f of s.linksFrom)if(f.linkBase){let s,i;var d=f.linkBase.map((e,t)=>{var e=a*e,o=Math.cos(c+e)*(1+m),n=Math.sin(c+e)*(1+m);return s=r.curveFactor||0,(i=Math.abs(f.linkBase[3-t]*a-e))>Math.PI&&(i=2*Math.PI-i),(i*=m)<m&&(s*=i/m),{x:p+o,y:l+n,cpX:p+(1-s)*o,cpY:l+(1-s)*n}});f.shapeArgs={d:[["M",d[0].x,d[0].y],["A",m,m,0,0,1,d[1].x,d[1].y],["C",d[1].cpX,d[1].cpY,d[2].cpX,d[2].cpY,d[2].x,d[2].y],["A",m,m,0,0,1,d[3].x,d[3].y],["C",d[3].cpX,d[3].cpY,d[0].cpX,d[0].cpY,d[0].x,d[0].y]]}}}}}DependencyWheelSeries.defaultOptions=merge(SankeySeries.defaultOptions,DependencyWheelSeriesDefaults),extend(DependencyWheelSeries.prototype,{orderNodes:!1,getCenter:PieSeries.prototype.getCenter}),DependencyWheelSeries.prototype.pointClass=DependencyWheelPoint,SeriesRegistry.registerSeriesType("dependencywheel",DependencyWheelSeries);export default DependencyWheelSeries;