!function(e){"object"==typeof module&&module.exports?module.exports=e.default=e:"function"==typeof define&&define.amd?define("highcharts/modules/marker-clusters",["highcharts"],function(t){return e(t),e.Highcharts=t,e}):e("undefined"!=typeof Highcharts?Highcharts:void 0)}(function(t){"use strict";t=t?t._modules:{};function e(t,e,a,s){t.hasOwnProperty(e)||(t[e]=s.apply(null,a),"function"==typeof CustomEvent&&window.dispatchEvent(new CustomEvent("HighchartsModuleLoaded",{detail:{path:e,module:t[e]}})))}e(t,"Extensions/MarkerClusters/MarkerClusterDefaults.js",[],function(){return{cluster:{enabled:!1,allowOverlap:!0,animation:{duration:500},drillToCluster:!0,minimumClusterSize:2,layoutAlgorithm:{gridSize:50,distance:40,kmeansThreshold:100},marker:{symbol:"cluster",radius:15,lineWidth:0,lineColor:"#ffffff"},dataLabels:{enabled:!0,format:"{point.clusterPointsAmount}",verticalAlign:"middle",align:"center",style:{color:"contrast"},inside:!0}},tooltip:{clusterFormat:"<span>Clustered points: {point.clusterPointsAmount}</span><br/>"}}}),e(t,"Extensions/MarkerClusters/MarkerClusterScatter.js",[t["Core/Animation/AnimationUtilities.js"],t["Extensions/MarkerClusters/MarkerClusterDefaults.js"],t["Core/Utilities.js"]],function(t,s,e){const k=t["animObject"],w=s["cluster"],{addEvent:z,defined:j,error:b,isArray:A,isFunction:P,isObject:X,isNumber:E,merge:Y,objectEach:o,pushUnique:r,relativeLength:O,syncTimeout:M}=e,i=[],n={grid:function(t,e,a,s){const o={},r=this.getGridOffset();let i,n,l,p,u;var d=this.getScaledGridSize(s);for(u=0;u<t.length;u++){var c=U(this,{x:t[u],y:e[u]});i=c.x-r.plotLeft,n=c.y-r.plotTop,l=Math.floor(i/d),p=Math.floor(n/d)+"-"+l,o[p]||(o[p]=[]),o[p].push({dataIndex:a[u],x:t[u],y:e[u]})}return o},kmeans:function(e,a,s,t){const o=this,r=[],i=[],n={},l=t.processedDistance||w.layoutAlgorithm.distance,p=t.iterations;let u=0,d=!0,c,h,m,f=[];t.processedGridSize=t.processedDistance;var g=o.markerClusterAlgorithms?o.markerClusterAlgorithms.grid.call(o,e,a,s,t):{};for(const x in g)1<g[x].length&&(m=V(g[x]),r.push({posX:m.x,posY:m.y,oldX:0,oldY:0,startPointsLen:g[x].length,points:[]}));for(;d;){for(const y of r)y.points.length=0;for(let t=i.length=0;t<e.length;t++)c=e[t],h=a[t],((f=o.getClusterDistancesFromPoint(r,c,h)).length&&f[0].distance<l?r[f[0].clusterIndex].points:i).push({x:c,y:h,dataIndex:s[t]});for(let t=0;t<r.length;t++)1===r[t].points.length&&(f=o.getClusterDistancesFromPoint(r,r[t].points[0].x,r[t].points[0].y))[1].distance<l&&(r[f[1].clusterIndex].points.push(r[t].points[0]),r[f[0].clusterIndex].points.length=0);d=!1;for(let t=0;t<r.length;t++)m=V(r[t].points),r[t].oldX=r[t].posX,r[t].oldY=r[t].posY,r[t].posX=m.x,r[t].posY=m.y,(r[t].posX>r[t].oldX+1||r[t].posX<r[t].oldX-1||r[t].posY>r[t].oldY+1||r[t].posY<r[t].oldY-1)&&(d=!0);p&&(d=u<p-1),u++}for(let t=0,e=r.length;t<e;++t)n["cluster"+t]=r[t].points;for(let t=0,e=i.length;t<e;++t)n["noise"+t]=[i[t]];return n},optimizedKmeans:function(t,e,a,s){var o=this,r=s.processedDistance||w.layoutAlgorithm.gridSize,i=o.getRealExtremes(),n=(o.options.cluster||{}).marker;let l,p={},u,d;if(!o.markerClusterInfo||o.initMaxX&&o.initMaxX<i.maxX||o.initMinX&&o.initMinX>i.minX||o.initMaxY&&o.initMaxY<i.maxY||o.initMinY&&o.initMinY>i.minY)o.initMaxX=i.maxX,o.initMinX=i.minX,o.initMaxY=i.maxY,o.initMinY=i.minY,p=o.markerClusterAlgorithms?o.markerClusterAlgorithms.kmeans.call(o,t,e,a,s):{},o.baseClusters=null;else{o.baseClusters||(o.baseClusters={clusters:o.markerClusterInfo.clusters,noise:o.markerClusterInfo.noise});for(const m of o.baseClusters.clusters){m.pointsOutside=[],m.pointsInside=[];for(const f of m.data){var c=U(o,f),h=U(o,m);l=Math.sqrt(Math.pow(c.x-h.x,2)+Math.pow(c.y-h.y,2)),u=0<=r-(d=(m.clusterZone&&m.clusterZone.marker&&m.clusterZone.marker.radius?m.clusterZone.marker:n&&n.radius?n:w.marker).radius)?r-d:d,l>d+u&&j(m.pointsOutside)?m.pointsOutside.push(f):j(m.pointsInside)&&m.pointsInside.push(f)}m.pointsInside.length&&(p[m.id]=m.pointsInside);let t=0;for(const g of m.pointsOutside)p[m.id+"_noise"+t++]=[g]}for(const x of o.baseClusters.noise)p[x.id]=x.data}return p}};let T,l=[],a=0;function p(t,e,a){t.attr({opacity:e}).animate({opacity:1},a)}function I(t,e,a,s){S(t,s,a,!0,!0);for(const o of e)o.point&&o.point.destroy&&o.point.destroy()}function S(t,e,a,s,o){t.point&&(s&&t.point.graphic&&(t.point.graphic.show(),p(t.point.graphic,e,a)),o&&t.point.dataLabel&&(t.point.dataLabel.show(),p(t.point.dataLabel,e,a)))}function V(e){var a=e.length;let s=0,o=0;for(let t=0;t<a;t++)s+=e[t].x,o+=e[t].y;return{x:s/a,y:o/a}}function u(t,e){const a=[];return a.length=e,t.clusters.forEach(function(t){t.data.forEach(function(t){a[t.dataIndex]=t})}),t.noise.forEach(function(t){a[t.data[0].dataIndex]=t.data[0]}),a}function D(){return Math.random().toString(36).substring(2,7)+"-"+a++}function L(t,e,a){t.point&&(e&&t.point.graphic&&t.point.graphic.hide(),a&&t.point.dataLabel&&t.point.dataLabel.hide())}function G(t){const e=t.point||t.target;e.firePointEvent("drillToCluster",t,function(t){const e=t.point||t.target,a=e.series,s=e.series.xAxis,o=e.series.yAxis,r=e.series.chart,i=r.mapView,n=a.options.cluster,l=(n||{}).drillToCluster;var p,u,d,c,h,m,f;l&&e.clusteredData&&(m=e.clusteredData.map(t=>t.x).sort((t,e)=>t-e),u=e.clusteredData.map(t=>t.y).sort((t,e)=>t-e),h=m[0],m=m[m.length-1],p=u[0],u=u[u.length-1],f=Math.abs(.1*(m-h)),d=Math.abs(.1*(u-p)),c=Math.min(h,m)-f,h=Math.max(h,m)+f,m=Math.min(p,u)-d,f=Math.max(p,u)+d,i?i.fitToBounds({x1:c,x2:h,y1:m,y2:f}):s&&o&&(r.pointer.zoomX=!0,r.pointer.zoomY=!0,r.zoom({originalEvent:t,xAxis:[{axis:s,min:c,max:h}],yAxis:[{axis:o,min:m,max:f}]})))})}function R(t,e){const{chart:a,xAxis:s,yAxis:o}=t;return a.mapView?a.mapView.pixelsToProjectedUnits(e):{x:s?s.toValue(e.x):0,y:o?o.toValue(e.y):0}}function d(t){const e=this.chart,a=e.mapView,s=this.options.cluster,o=k((s||{}).animation),r=o.duration||500,i=(this.markerClusterInfo||{}).pointsState,n=(i||{}).newState,l=(i||{}).oldState,p=[];let u,d,c,h,m,f,g,x=!1,y=!1;var C;l&&n&&(C=U(this,c=n[t.stateId]),f=C.x-(a?0:e.plotLeft),g=C.y-(a?0:e.plotTop),1===c.parentsId.length?(u=(n||{})[t.stateId].parentsId[0],d=l[u],c.point&&c.point.graphic&&d&&d.point&&d.point.plotX&&d.point.plotY&&d.point.plotX!==c.point.plotX&&d.point.plotY!==c.point.plotY&&(h=c.point.graphic.getBBox(),m=c.point.graphic&&c.point.graphic.isImg?0:h.width/2,c.point.graphic.attr({x:d.point.plotX-m,y:d.point.plotY-m}),c.point.graphic.animate({x:f-(c.point.graphic.radius||0),y:g-(c.point.graphic.radius||0)},o,function(){y=!0,d.point&&d.point.destroy&&d.point.destroy()}),c.point.dataLabel&&c.point.dataLabel.alignAttr&&d.point.dataLabel&&d.point.dataLabel.alignAttr&&(c.point.dataLabel.attr({x:d.point.dataLabel.alignAttr.x,y:d.point.dataLabel.alignAttr.y}),c.point.dataLabel.animate({x:c.point.dataLabel.alignAttr.x,y:c.point.dataLabel.alignAttr.y},o)))):0===c.parentsId.length?(L(c,!0,!0),M(function(){S(c,.1,o,!0,!0)},r/2)):(L(c,!0,!0),c.parentsId.forEach(function(t){l&&l[t]&&(d=l[t],p.push(d),d.point&&d.point.graphic&&(x=!0,d.point.graphic.show(),d.point.graphic.animate({x:f-(d.point.graphic.radius||0),y:g-(d.point.graphic.radius||0),opacity:.4},o,function(){y=!0,I(c,p,o,.7)}),d.point.dataLabel&&-9999!==d.point.dataLabel.y&&c.point&&c.point.dataLabel&&c.point.dataLabel.alignAttr&&(d.point.dataLabel.show(),d.point.dataLabel.animate({x:c.point.dataLabel.alignAttr.x,y:c.point.dataLabel.alignAttr.y,opacity:.4},o))))}),M(function(){y||I(c,p,o,.85)},r),x||M(function(){I(c,p,o,.1)},r/2)))}function c(){const t=this.markerClusterSeriesData;(t||[]).forEach(function(t){t&&t.destroy&&t.destroy()}),this.markerClusterSeriesData=null}function h(){const a=this,t=a.chart,e=t.mapView,s=a.xData,o=a.yData,r=a.options.cluster,i=a.getRealExtremes(),n=[],l=[],p=[];let u,d,c,h,m,f,g,x,y,C,k,M,I,S,b,A,X;if(e&&a.is("mappoint")&&s&&o&&(a.options.data||[]).forEach((t,e)=>{t=a.projectPoint(t);t&&(s[e]=t.x,o[e]=t.y)}),r&&r.enabled&&s&&s.length&&o&&o.length&&!t.polar){k=r.layoutAlgorithm.type,(b=r.layoutAlgorithm).processedGridSize=O(b.gridSize||w.layoutAlgorithm.gridSize,t.plotWidth),b.processedDistance=O(b.distance||w.layoutAlgorithm.distance,t.plotWidth),h=b.kmeansThreshold||w.layoutAlgorithm.kmeansThreshold;var Y=b.processedGridSize/2,D=R(a,{x:0,y:0}),Y=R(a,{x:Y,y:Y});for(m=Math.abs(D.x-Y.x),f=Math.abs(D.y-Y.y),X=0;X<s.length;X++)a.dataMaxX||(j(x)&&j(g)&&j(C)&&j(y)?E(o[X])&&E(C)&&E(y)&&(x=Math.max(s[X],x),g=Math.min(s[X],g),C=Math.max(o[X]||C,C),y=Math.min(o[X]||y,y)):(x=g=s[X],C=y=o[X])),s[X]>=i.minX-m&&s[X]<=i.maxX+m&&(o[X]||i.minY)>=i.minY-f&&(o[X]||i.maxY)<=i.maxY+f&&(n.push(s[X]),l.push(o[X]),p.push(X));if(j(x)&&j(g)&&E(C)&&E(y)&&(a.dataMaxX=x,a.dataMinX=g,a.dataMaxY=C,a.dataMinY=y),I=(S=(M=P(k)?k:a.markerClusterAlgorithms?k&&a.markerClusterAlgorithms[k]?a.markerClusterAlgorithms[k]:n.length<h?a.markerClusterAlgorithms.kmeans:a.markerClusterAlgorithms.grid:function(){return!1}).call(this,n,l,p,b))&&a.getClusteredData(S,r),r.animation&&a.markerClusterInfo&&a.markerClusterInfo.pointsState&&a.markerClusterInfo.pointsState.oldState){var L=a.markerClusterInfo.pointsState.oldState;if(L){let t;for(const v of Object.keys(L))(t=L[v]).point&&t.point.destroy&&t.point.destroy()}u=a.markerClusterInfo.pointsState.newState}else u={};d=s.length,c=a.markerClusterInfo,I&&(a.processedXData=I.groupedXData,a.processedYData=I.groupedYData,a.hasGroupedData=!0,a.markerClusterInfo=I,a.groupMap=I.groupMap),T.apply(this),I&&a.markerClusterInfo&&((a.markerClusterInfo.clusters||[]).forEach(function(t){(A=a.points[t.index]).isCluster=!0,A.clusteredData=t.data,A.clusterPointsAmount=t.data.length,t.point=A,z(A,"click",G)}),(a.markerClusterInfo.noise||[]).forEach(function(t){t.point=a.points[t.index]}),r.animation&&a.markerClusterInfo&&(a.markerClusterInfo.pointsState={oldState:u,newState:a.getPointsState(I,c,d)}),r.animation?this.hideClusteredData():this.destroyClusteredData(),this.markerClusterSeriesData=this.hasGroupedData?this.points:null)}else T.apply(this)}function m(e,a,s){const o=[];for(let t=0;t<e.length;t++){var r=U(this,{x:a,y:s}),i=U(this,{x:e[t].posX,y:e[t].posY}),r=Math.sqrt(Math.pow(r.x-i.x,2)+Math.pow(r.y-i.y,2));o.push({clusterIndex:t,distance:r})}return o.sort((t,e)=>t.distance-e.distance)}function f(t,e){const a=this,s=[],o=[],r=[],i=[],n=[],l=Math.max(2,e.minimumClusterSize||2);let p=0,u,d,c,h,m,f,g,x,y,C,k,M,I,S;if(P(e.layoutAlgorithm.type)&&!a.isValidGroupedDataObject(t))return b("Highcharts marker-clusters module: The custom algorithm result is not valid!",!1,a.chart),!1;for(S in t)if(t[S].length>=l){if(c=t[S],u=D(),m=c.length,e.zones)for(I=0;I<e.zones.length;I++)m>=e.zones[I].from&&m<=e.zones[I].to&&((k=e.zones[I]).zoneIndex=I,C=e.zones[I].marker,M=e.zones[I].className);for(y=V(c),g="grid"!==e.layoutAlgorithm.type||e.allowOverlap?{x:y.x,y:y.y}:(f=a.options.marker||{},a.preventClusterCollisions({x:y.x,y:y.y,key:S,groupedData:t,gridSize:a.getScaledGridSize(e.layoutAlgorithm),defaultRadius:f.radius||3+(f.lineWidth||0),clusterRadius:C&&C.radius?C.radius:(e.marker||{}).radius||w.marker.radius})),I=0;I<m;I++)c[I].parentStateId=u;if(r.push({x:g.x,y:g.y,id:S,stateId:u,index:p,data:c,clusterZone:k,clusterZoneClassName:M}),s.push(g.x),o.push(g.y),n.push({options:{formatPrefix:"cluster",dataLabels:e.dataLabels,marker:Y(e.marker,{states:e.states},C||{})}}),a.options.data&&a.options.data.length)for(I=0;I<m;I++)X(a.options.data[c[I].dataIndex])&&(c[I].options=a.options.data[c[I].dataIndex]);p++,C=null}else for(I=0;I<t[S].length;I++)d=t[S][I],u=D(),x=null,h=((a.options||{}).data||[])[d.dataIndex],s.push(d.x),o.push(d.y),d.parentStateId=u,i.push({x:d.x,y:d.y,id:S,stateId:u,index:p,data:t[S]}),x=h&&"object"==typeof h&&!A(h)?Y(h,{x:d.x,y:d.y}):{userOptions:h,x:d.x,y:d.y},n.push({options:x}),p++;return{clusters:r,noise:i,groupedXData:s,groupedYData:o,groupMap:n}}function g(){const t=this,e=t.chart,a=t.xAxis,s=t.yAxis;let o=0,r=0;return o=a&&t.dataMinX&&t.dataMaxX?a.reversed?a.toPixels(t.dataMaxX):a.toPixels(t.dataMinX):e.plotLeft,r=s&&t.dataMinY&&t.dataMaxY?s.reversed?s.toPixels(t.dataMinY):s.toPixels(t.dataMaxY):e.plotTop,{plotLeft:o,plotTop:r}}function x(t,e,a){const s=e?u(e,a):[],o=u(t,a),r={};var i,n;l=[],t.clusters.forEach(function(t){r[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),t.noise.forEach(function(t){r[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}});for(let t=0;t<o.length;t++)i=o[t],n=s[t],i&&n&&i.parentStateId&&n.parentStateId&&r[i.parentStateId]&&-1===r[i.parentStateId].parentsId.indexOf(n.parentStateId)&&(r[i.parentStateId].parentsId.push(n.parentStateId),-1===l.indexOf(n.parentStateId)&&l.push(n.parentStateId));return r}function y(){var t=this.chart,e=t.mapView?0:t.plotLeft,a=R(this,{x:e,y:t.mapView?0:t.plotTop}),e=R(this,{x:e+t.plotWidth,y:e+t.plotHeight}),t=a.x,s=e.x,a=a.y,e=e.y;return{minX:Math.min(t,s),maxX:Math.max(t,s),minY:Math.min(a,e),maxY:Math.max(a,e)}}function C(t){const e=this,a=e.xAxis,s=this.chart.mapView,o=t.processedGridSize||w.layoutAlgorithm.gridSize;let r=!0,i=1,n=1;e.gridValueSize||(s?e.gridValueSize=o/s.getScale():e.gridValueSize=Math.abs(a.toValue(o)-a.toValue(0)));for(var l=+(o/(s?e.gridValueSize*s.getScale():a.toPixels(e.gridValueSize)-a.toPixels(0))).toFixed(14);r&&1!=l;){var p=Math.pow(2,i);.75<l&&l<1.25?r=!1:1/p<=l&&l<1/p*2?(r=!1,n=p):l<=p&&p/2<l&&(r=!1,n=1/p),i++}return o/n/l}function v(){const t=this.markerClusterSeriesData,e=((this.markerClusterInfo||{}).pointsState||{}).oldState||{},a=l.map(t=>(e[t].point||{}).id||"");(t||[]).forEach(function(t){t&&-1!==a.indexOf(t.id)?(t.graphic&&t.graphic.hide(),t.dataLabel&&t.dataLabel.hide()):t&&t.destroy&&t.destroy()})}function F(t){let e=!1,a;return!!X(t)&&(o(t,function(t){if(e=!0,A(t)&&t.length){for(a=0;a<t.length;a++)if(!X(t[a])||!t[a].x||!t[a].y)return void(e=!1)}else e=!1}),e)}function Z(t){const e=this,[a,s]=t.key.split("-").map(parseFloat),o=t.gridSize,r=t.groupedData,i=t.defaultRadius,n=t.clusterRadius,l=s*o,p=a*o,u=U(e,t),d=[],c=(e.options.cluster||{}).marker,h=(e.options.cluster||{}).zones,m=e.getGridOffset();let f=u.x,g=u.y,x,y=0,C,k,M,I,S,b,A,X,Y,D,L,v,z;for(f-=m.plotLeft,g-=m.plotTop,A=1;A<5;A++)for(M=A%2?-1:1,I=A<3?-1:1,S=Math.floor((f+M*n)/o),z=[(b=Math.floor((g+I*n)/o))+"-"+S,b+"-"+s,a+"-"+S],X=0;X<z.length;X++)-1===d.indexOf(z[X])&&z[X]!==t.key&&d.push(z[X]);for(const E of d)if(r[E]){r[E].posX||(L=V(r[E]),r[E].posX=L.x,r[E].posY=L.y);const P=U(e,{x:r[E].posX||0,y:r[E].posY||0});if(C=P.x-m.plotLeft,k=P.y-m.plotTop,[D,Y]=E.split("-").map(parseFloat),h)for(x=r[E].length,A=0;A<h.length;A++)x>=h[A].from&&x<=h[A].to&&(y=j((h[A].marker||{}).radius)?h[A].marker.radius||0:(c&&c.radius?c:w.marker).radius);1<r[E].length&&0===y&&c&&c.radius?y=c.radius:1===r[E].length&&(y=i),v=n+y,y=0,Y!==s&&Math.abs(f-C)<v&&(f=Y-s<0?l+n:l+o-n),D!==a&&Math.abs(g-k)<v&&(g=D-a<0?p+n:p+o-n)}const P=R(e,{x:f+m.plotLeft,y:g+m.plotTop});return r[t.key].posX=P.x,r[t.key].posY=P.y,P}function U(t,e){const{chart:a,xAxis:s,yAxis:o}=t;return a.mapView?a.mapView.projectedUnitsToPixels(e):{x:s?s.toPixels(e.x):0,y:o?o.toPixels(e.y):0}}return{compose:function(t,e){if(r(i,e)){const a=e.prototype;T=a.generatePoints,a.markerClusterAlgorithms=n,a.animateClusterPoint=d,a.destroyClusteredData=c,a.generatePoints=h,a.getClusterDistancesFromPoint=m,a.getClusteredData=f,a.getGridOffset=g,a.getPointsState=x,a.getRealExtremes=y,a.getScaledGridSize=C,a.hideClusteredData=v,a.isValidGroupedDataObject=F,a.preventClusterCollisions=Z,z(e,"destroy",a.destroyClusteredData)}r(i,t)&&((t.plotOptions||{}).series=Y((t.plotOptions||{}).series,s))}}}),e(t,"Extensions/MarkerClusters/MarkerClusters.js",[t["Core/Animation/AnimationUtilities.js"],t["Core/Defaults.js"],t["Extensions/MarkerClusters/MarkerClusterDefaults.js"],t["Extensions/MarkerClusters/MarkerClusterScatter.js"],t["Core/Utilities.js"]],function(t,e,a,r,s){const o=t["animObject"],i=e["defaultOptions"],{addEvent:n,defined:l,error:p,isFunction:u,merge:d,pushUnique:c,syncTimeout:h}=s,m=[];function f(){const t=this.chart;let e=0;for(const a of t.series)a.markerClusterInfo&&(e=o((a.options.cluster||{}).animation).duration||0);h(()=>{t.tooltip&&t.tooltip.destroy()},e)}function g(){for(const a of this.series||[])if(a.markerClusterInfo){var t=a.options.cluster,e=((a.markerClusterInfo||{}).pointsState||{}).oldState;if((t||{}).animation&&a.markerClusterInfo&&0===a.chart.pointer.pinchDown.length&&"pan"!==((a.xAxis||{}).eventArgs||{}).trigger&&e&&Object.keys(e).length){for(const s of a.markerClusterInfo.clusters)a.animateClusterPoint(s);for(const o of a.markerClusterInfo.noise)a.animateClusterPoint(o)}}}function x(t){const e=t.point||t.target,a=e.series,s=a.options.cluster,o=((s||{}).events||{}).drillToCluster;u(o)&&o.call(this,t)}function y(){if(this.dataGroup)return p("Highcharts marker-clusters module: Running `Point.update` when point belongs to clustered series is not supported.",!1,this.series.chart),!1}function C(){var t=(this.options.cluster||{}).drillToCluster;if(this.markerClusterInfo&&this.markerClusterInfo.clusters)for(const e of this.markerClusterInfo.clusters)e.point&&e.point.graphic&&(e.point.graphic.addClass("highcharts-cluster-point"),t&&e.point&&(e.point.graphic.css({cursor:"pointer"}),e.point.dataLabel&&e.point.dataLabel.css({cursor:"pointer"})),l(e.clusterZone)&&e.point.graphic.addClass(e.clusterZoneClassName||"highcharts-cluster-zone-"+e.clusterZone.zoneIndex))}return(i.plotOptions||{}).series=d((i.plotOptions||{}).series,a),{compose:function(t,e,a,s){var o=s.prototype.pointClass;(t=(c(m,t)&&n(t,"setExtremes",f),c(m,e)&&n(e,"render",g),c(m,o)&&(n(o,"drillToCluster",x),n(o,"update",y)),c(m,s)&&n(s,"afterRender",C),s.types)["scatter"])&&r.compose(a,t)}}}),e(t,"Extensions/MarkerClusters/MarkerClusterSymbols.js",[t["Core/Utilities.js"]],function(t){const e=t["pushUnique"],a=[];let p;function s(t,e,a,s){const o=a/2,r=s/2,i=p.arc(t+o,e+r,o-4,r-4,{start:.5*Math.PI,end:2.5*Math.PI,open:!1}),n=p.arc(t+o,e+r,o-3,r-3,{start:.5*Math.PI,end:2.5*Math.PI,innerR:o-2,open:!1}),l=p.arc(t+o,e+r,o-1,r-1,{start:.5*Math.PI,end:2.5*Math.PI,innerR:o,open:!1});return l.concat(n,i)}return{compose:function(t){e(a,t)&&((p=t.prototype.symbols).cluster=s)}}}),e(t,"masters/modules/marker-clusters.src.js",[t["Core/Globals.js"],t["Extensions/MarkerClusters/MarkerClusters.js"],t["Extensions/MarkerClusters/MarkerClusterSymbols.js"]],function(t,e,a){e.compose(t.Axis,t.Chart,t.defaultOptions,t.Series),a.compose(t.SVGRenderer)})});