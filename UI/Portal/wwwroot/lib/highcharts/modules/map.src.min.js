!function(e){"object"==typeof module&&module.exports?module.exports=e.default=e:"function"==typeof define&&define.amd?define("highcharts/modules/map",["highcharts"],function(t){return e(t),e.Highcharts=t,e}):e("undefined"!=typeof Highcharts?Highcharts:void 0)}(function(t){"use strict";t=t?t._modules:{};function e(t,e,o,s){t.hasOwnProperty(e)||(t[e]=s.apply(null,o),"function"==typeof CustomEvent&&window.dispatchEvent(new CustomEvent("HighchartsModuleLoaded",{detail:{path:e,module:t[e]}})))}e(t,"Core/Axis/Color/ColorAxisComposition.js",[t["Core/Color/Color.js"],t["Core/Utilities.js"]],function(t,h){const e=t["parse"],{addEvent:p,extend:c,merge:d,pick:u,splat:o}=h;var s;{t=s=s||{};const w=[];let l;function m(){const t=this.options;this.colorAxis=[],t.colorAxis&&(t.colorAxis=o(t.colorAxis),t.colorAxis.map(t=>new l(this,t)))}function g(e){const t=this.chart.colorAxis||[],o=t=>{t=e.allItems.indexOf(t);-1!==t&&(this.destroyItem(e.allItems[t]),e.allItems.splice(t,1))};let s=[],i,r;for(t.forEach(function(t){(i=t.options)&&i.showInLegend&&(i.dataClasses&&i.visible?s=s.concat(t.getDataClassLegendSymbols()):i.visible&&s.push(t),t.series.forEach(function(t){t.options.showInLegend&&!i.dataClasses||("point"===t.options.legendType?t.points.forEach(function(t){o(t)}):o(t))}))}),r=s.length;r--;)e.allItems.unshift(s[r])}function f(t){t.visible&&t.item.legendColor&&t.item.legendItem.symbol.attr({fill:t.item.legendColor})}function b(e){this.chart.colorAxis?.forEach(t=>{t.update({},e.redraw)})}function y(){(this.chart.colorAxis&&this.chart.colorAxis.length||this.colorAttribs)&&this.translateColors()}function x(){const t=this.axisTypes;t?-1===t.indexOf("colorAxis")&&t.push("colorAxis"):this.axisTypes=["colorAxis"]}function v(t){const e=this,o=t?"show":"hide";e.visible=e.options.visible=Boolean(t),["graphic","dataLabel"].forEach(function(t){e[t]&&e[t][o]()}),this.series.buildKDTree()}function M(){const o=this,t=this.data.length?this.data:this.points,s=this.options.nullColor,i=this.colorAxis,r=this.colorKey;t.forEach(t=>{var e=t.getNestedProperty(r),e=t.options.color||(t.isNull||null===t.value?s:i&&void 0!==e?i.toColor(e,t):t.color||o.color);e&&t.color!==e&&(t.color=e,"point"===o.options.legendType&&t.legendItem&&t.legendItem.label&&o.chart.legend.colorizeItem(t,t.visible))})}function j(){this.elem.attr("fill",e(this.start).tweenTo(e(this.end),this.pos),void 0,!0)}function C(){this.elem.attr("stroke",e(this.start).tweenTo(e(this.end),this.pos),void 0,!0)}t.compose=function(t,e,o,s,i){if(l=l||t,h.pushUnique(w,e)){const r=e.prototype;r.collectionsWithUpdate.push("colorAxis"),r.collectionsWithInit.colorAxis=[r.addColorAxis],p(e,"afterGetAxes",m);{t=e;const a=t.prototype.createAxis;t.prototype.createAxis=function(t,e){var o=this;if("colorAxis"!==t)return a.apply(o,arguments);t=new l(o,d(e.axis,{index:o[t].length,isX:!1}));return o.isDirtyLegend=!0,o.axes.forEach(t=>{t.series=[]}),o.series.forEach(t=>{t.bindAxes(),t.isDirtyData=!0}),u(e.redraw,!0)&&o.redraw(e.animation),t}}}if(h.pushUnique(w,o)){const n=o.prototype;n.fillSetter=j,n.strokeSetter=C}h.pushUnique(w,s)&&(p(s,"afterGetAllItems",g),p(s,"afterColorizeItem",f),p(s,"afterUpdate",b)),h.pushUnique(w,i)&&(c(i.prototype,{optionalAxis:"colorAxis",translateColors:M}),c(i.prototype.pointClass.prototype,{setVisible:v}),p(i,"afterTranslate",y,{order:1}),p(i,"bindAxes",x))},t.pointSetVisible=v}return s}),e(t,"Core/Axis/Color/ColorAxisDefaults.js",[],function(){return{lineWidth:0,minPadding:0,maxPadding:0,gridLineColor:"#ffffff",gridLineWidth:1,tickPixelInterval:72,startOnTick:!0,endOnTick:!0,offset:0,marker:{animation:{duration:50},width:.01,color:"#999999"},labels:{distance:8,overflow:"justify",rotation:0},minColor:"#e6e9ff",maxColor:"#0022ff",tickLength:5,showInLegend:!0}}),e(t,"Core/Axis/Color/ColorAxisLike.js",[t["Core/Color/Color.js"],t["Core/Utilities.js"]],function(t,e){const c=t["parse"],d=e["merge"];var o;return(t=o=o||{}).initDataClasses=function(t){const e=this,o=e.chart,s=e.legendItem=e.legendItem||{},i=e.options,r=t.dataClasses||[];let a,n,l=o.options.chart.colorCount,h=0,p;e.dataClasses=n=[],s.labels=[];for(let t=0,e=r.length;t<e;++t)a=r[t],a=d(a),n.push(a),!o.styledMode&&a.color||("category"===i.dataClassColor?(o.styledMode||(p=o.options.colors||[],l=p.length,a.color=p[h]),a.colorIndex=h,++h===l&&(h=0)):a.color=c(i.minColor).tweenTo(c(i.maxColor),e<2?.5:t/(e-1)))},t.initStops=function(){const t=this.options,o=this.stops=t.stops||[[0,t.minColor||""],[1,t.maxColor||""]];for(let t=0,e=o.length;t<e;++t)o[t].color=c(o[t][1])},t.normalizedValue=function(t){var e=this.max||0,o=this.min||0;return 1-(e-(t=this.logarithmic?this.logarithmic.log2lin(t):t))/(e-o||1)},t.toColor=function(t,e){var o=this.dataClasses,s=this.stops;let i,r,a,n,l,h;if(o){for(h=o.length;h--;)if(l=o[h],r=l.from,a=l.to,(void 0===r||t>=r)&&(void 0===a||t<=a)){n=l.color,e&&(e.dataClass=h,e.colorIndex=l.colorIndex);break}}else{for(i=this.normalizedValue(t),h=s.length;h--&&!(i>s[h][0]););r=s[h]||s[h+1],a=s[h+1]||r,i=1-(a[0]-i)/(a[0]-r[0]||1),n=r.color.tweenTo(a.color,i)}return n},o}),e(t,"Core/Axis/Color/ColorAxis.js",[t["Core/Axis/Axis.js"],t["Core/Axis/Color/ColorAxisComposition.js"],t["Core/Axis/Color/ColorAxisDefaults.js"],t["Core/Axis/Color/ColorAxisLike.js"],t["Core/Legend/LegendSymbol.js"],t["Core/Series/SeriesRegistry.js"],t["Core/Utilities.js"]],function(t,i,e,o,u,s,r){const c=s["series"],{extend:m,fireEvent:g,isArray:a,isNumber:n,merge:l,pick:f}=r;class d extends t{static compose(t,e,o,s){i.compose(d,t,e,o,s)}constructor(t,e){super(t,e),this.beforePadding=!1,this.chart=void 0,this.coll="colorAxis",this.dataClasses=void 0,this.options=void 0,this.stops=void 0,this.visible=!0,this.init(t,e)}init(t,e){var o=this,s=t.options.legend||{},i=e.layout?"vertical"!==e.layout:"vertical"!==s.layout,r=e.visible,s=l(d.defaultColorAxisOptions,e,{showEmpty:!1,title:null,visible:s.enabled&&!1!==r});o.side=e.side||i?2:1,o.reversed=e.reversed||!i,o.opposite=!i,super.init(t,s,"colorAxis"),this.userOptions=e,a(t.userOptions.colorAxis)&&(t.userOptions.colorAxis[this.index]=e),e.dataClasses&&o.initDataClasses(e),o.initStops(),o.horiz=i,o.zoomEnabled=!1}hasData(){return!!(this.tickPositions||[]).length}setTickPositions(){if(!this.dataClasses)return super.setTickPositions()}setOptions(t){super.setOptions(t),this.options.crosshair=this.options.marker}setAxisSize(){const t=this.legendItem&&this.legendItem.symbol;var e,o,s,i,r=this.chart,a=r.options.legend||{};t?(this.left=e=t.attr("x"),this.top=o=t.attr("y"),this.width=s=t.attr("width"),this.height=i=t.attr("height"),this.right=r.chartWidth-e-s,this.bottom=r.chartHeight-o-i,this.len=this.horiz?s:i,this.pos=this.horiz?e:o):this.len=(this.horiz?a.symbolWidth:a.symbolHeight)||d.defaultLegendLength}getOffset(){var t=this,e=t.legendItem&&t.legendItem.group,o=t.chart.axisOffset[t.side];if(e){t.axisParent=e,super.getOffset();const s=this.chart.legend;s.allItems.forEach(function(t){t instanceof d&&t.drawLegendSymbol(s,t)}),s.render(),this.chart.getMargins(!0),t.added||(t.added=!0,t.labelLeft=0,t.labelRight=t.width),t.chart.axisOffset[t.side]=o}}setLegendColor(){var t=this.horiz,e=this.reversed,o=e?1:0,e=e?0:1,t=t?[o,0,e,0]:[0,e,0,o];this.legendColor={linearGradient:{x1:t[0],y1:t[1],x2:t[2],y2:t[3]},stops:this.stops}}drawLegendSymbol(t,e){const o=e.legendItem||{},s=t.padding,i=t.options,r=this.options.labels,a=f(i.itemDistance,10),n=this.horiz,l=f(i.symbolWidth,n?d.defaultLegendLength:12),h=f(i.symbolHeight,n?12:d.defaultLegendLength),p=f(i.labelPadding,n?16:30);this.setLegendColor(),o.symbol||(o.symbol=this.chart.renderer.symbol("roundedRect",0,t.baseline-11,l,h,{r:i.symbolRadius??3}).attr({zIndex:1}).add(o.group)),o.labelWidth=l+s+(n?a:f(r.x,r.distance)+this.maxLabelLength),o.labelHeight=h+s+(n?p:0)}setState(e){this.series.forEach(function(t){t.setState(e)})}setVisible(){}getSeriesExtremes(){var t,e=this.series;let o,s,i,r,a,n,l=e.length,h,p;for(this.dataMin=1/0,this.dataMax=-1/0;l--;){if(s=(n=e[l]).colorKey=f(n.options.colorKey,n.colorKey,n.pointValKey,n.zoneAxis,"y"),r=n.pointArrayMap,a=n[s+"Min"]&&n[s+"Max"],n[s+"Data"])o=n[s+"Data"];else if(r){if(o=[],i=r.indexOf(s),h=n.yData,0<=i&&h)for(p=0;p<h.length;p++)o.push(f(h[p][i],h[p]))}else o=n.yData;a?(n.minColorValue=n[s+"Min"],n.maxColorValue=n[s+"Max"]):(t=c.prototype.getExtremes.call(n,o),n.minColorValue=t.dataMin,n.maxColorValue=t.dataMax),void 0!==n.minColorValue&&(this.dataMin=Math.min(this.dataMin,n.minColorValue),this.dataMax=Math.max(this.dataMax,n.maxColorValue)),a||c.prototype.applyExtremes.call(n)}}drawCrosshair(t,e){var o=this,s=o.legendItem||{},i=e&&e.plotX,r=e&&e.plotY,a=o.pos,n=o.len;let l;e&&((l=o.toPixels(e.getNestedProperty(e.series.colorKey)))<a?l=a-2:l>a+n&&(l=a+n+2),e.plotX=l,e.plotY=o.len-l,super.drawCrosshair(t,e),e.plotX=i,e.plotY=r,o.cross&&!o.cross.addedToColorAxis&&s.group&&(o.cross.addClass("highcharts-coloraxis-marker").add(s.group),o.cross.addedToColorAxis=!0,o.chart.styledMode||"object"!=typeof o.crosshair||o.cross.attr({fill:o.crosshair.color})))}getPlotLinePath(t){var e=this.left,o=t.translatedValue,s=this.top;return n(o)?this.horiz?[["M",o-4,s-6],["L",o+4,s-6],["L",o,s],["Z"]]:[["M",e,o],["L",e-6,o+6],["L",e-6,o-6],["Z"]]:super.getPlotLinePath(t)}update(t,e){const o=this,s=o.chart,i=s.legend;this.series.forEach(t=>{t.isDirtyData=!0}),(t.dataClasses&&i.allItems||o.dataClasses)&&o.destroyItems(),super.update(t,e),o.legendItem&&o.legendItem.label&&(o.setLegendColor(),i.colorizeItem(this,!0))}destroyItems(){const t=this.chart,e=this.legendItem||{};if(e.label)t.legend.destroyItem(this);else if(e.labels)for(const o of e.labels)t.legend.destroyItem(o);t.isDirtyLegend=!0}destroy(){this.chart.isDirtyLegend=!0,this.destroyItems(),super.destroy(...[].slice.call(arguments))}remove(t){this.destroyItems(),super.remove(t)}getDataClassLegendSymbols(){const a=this,n=a.chart,l=a.legendItem&&a.legendItem.labels||[],t=n.options.legend,h=f(t.valueDecimals,-1),p=f(t.valueSuffix,""),c=o=>a.series.reduce((t,e)=>(t.push(...e.points.filter(t=>t.dataClass===o)),t),[]);let d;return l.length||a.dataClasses.forEach((t,o)=>{const e=t.from,s=t.to,i=n["numberFormatter"];let r=!0;d="",void 0===e?d="< ":void 0===s&&(d="> "),void 0!==e&&(d+=i(e,h)+p),void 0!==e&&void 0!==s&&(d+=" - "),void 0!==s&&(d+=i(s,h)+p),l.push(m({chart:n,name:d,options:{},drawLegendSymbol:u.rectangle,visible:!0,isDataClass:!0,setState:t=>{for(const e of c(o))e.setState(t)},setVisible:function(){this.visible=r=a.visible=!r;const t=[];for(const e of c(o))e.setVisible(r),-1===t.indexOf(e.series)&&t.push(e.series);n.legend.colorizeItem(this,r),t.forEach(t=>{g(t,"afterDataClassLegendClick")})}},t))}),l}}return d.defaultColorAxisOptions=e,d.defaultLegendLength=200,d.keepProps=["legendItem"],m(d.prototype,o),Array.prototype.push.apply(t.keepProps,d.keepProps),d}),e(t,"Maps/MapNavigationDefaults.js",[],function(){return{lang:{zoomIn:"Zoom in",zoomOut:"Zoom out"},mapNavigation:{buttonOptions:{alignTo:"plotBox",align:"left",verticalAlign:"top",x:0,width:18,height:18,padding:5,style:{color:"#666666",fontSize:"1em",fontWeight:"bold"},theme:{fill:"#ffffff",stroke:"#e6e6e6","stroke-width":1,"text-align":"center"}},buttons:{zoomIn:{onclick:function(){this.mapZoom(.5)},text:"+",y:0},zoomOut:{onclick:function(){this.mapZoom(2)},text:"-",y:28}},mouseWheelSensitivity:1.1}}}),e(t,"Maps/MapPointer.js",[t["Core/Utilities.js"]],function(t){const{defined:r,extend:a,pick:o,pushUnique:e,wrap:n}=t;var l;{t=l=l||{};const m=[];let s=0,i;function h(t){const e=this.chart;t=this.normalize(t),e.options.mapNavigation.enableDoubleClickZoomTo?e.pointer.inClass(t.target,"highcharts-tracker")&&e.hoverPoint&&e.hoverPoint.zoomTo():e.isInsidePlot(t.chartX-e.plotLeft,t.chartY-e.plotTop)&&e.mapZoom(.5,void 0,void 0,t.chartX,t.chartY)}function p(t){const e=this.chart;t=this.normalize(t);var o=r(t.wheelDelta)&&-t.wheelDelta/120||t.deltaY||t.detail;1<=Math.abs(o)&&(s+=Math.abs(o),i&&clearTimeout(i),i=setTimeout(()=>{s=0},50)),s<10&&e.isInsidePlot(t.chartX-e.plotLeft,t.chartY-e.plotTop)&&e.mapView&&e.mapView.zoomBy((e.options.mapNavigation.mouseWheelSensitivity-1)*-o,void 0,[t.chartX,t.chartY],!(Math.abs(o)<1)&&void 0)}function c(t,e,o){const s=this.chart;return e=t.call(this,e,o),s&&s.mapView&&((t=s.mapView.pixelsToLonLat({x:e.chartX-s.plotLeft,y:e.chartY-s.plotTop}))&&a(e,t)),e}function d(t,e,o,s,i,r,a){t.call(this,e,o,s,i,r,a),"map"===this.chart.options.chart.type&&this.hasZoom&&(t=s.scaleX>s.scaleY,this.pinchTranslateDirection(!t,e,o,s,i,r,a,t?s.scaleX:s.scaleY))}function u(t){var e=this.chart.options.mapNavigation;e&&o(e.enableTouchZoom,e.enabled)&&(this.chart.zooming.pinchType="xy"),t.apply(this,[].slice.call(arguments,1))}t.compose=function(t){e(m,t)&&(t=t.prototype,a(t,{onContainerDblClick:h,onContainerMouseWheel:p}),n(t,"normalize",c),n(t,"pinchTranslate",d),n(t,"zoomOption",u))}}return l}),e(t,"Maps/MapSymbols.js",[t["Core/Utilities.js"]],function(t){const e=t["pushUnique"],o=[];let a;function s(t,e,o,s,i){var r;return i&&(r=i?.r||0,i.brBoxY=e-r,i.brBoxHeight=s+r),a.roundedRect(t,e,o,s,i)}function i(t,e,o,s,i){var r;return i&&(r=i?.r||0,i.brBoxHeight=s+r),a.roundedRect(t,e,o,s,i)}return{compose:function(t){e(o,t)&&((a=t.prototype.symbols).bottombutton=s,a.topbutton=i)}}}),e(t,"Maps/MapNavigation.js",[t["Core/Defaults.js"],t["Maps/MapNavigationDefaults.js"],t["Maps/MapPointer.js"],t["Maps/MapSymbols.js"],t["Core/Utilities.js"]],function(t,s,i,r,e){const a=t["setOptions"],{addEvent:f,extend:b,merge:y,objectEach:o,pick:n,pushUnique:l}=e,h=[];function x(t){t&&(t.preventDefault&&t.preventDefault(),t.stopPropagation&&t.stopPropagation(),t.cancelBubble=!0)}return class p{static compose(t,e,o){i.compose(e),r.compose(o),l(h,t)&&f(t,"beforeRender",function(){this.mapNavigation=new p(this),this.mapNavigation.update()}),l(h,a)&&a(s)}constructor(t){this.navButtonsGroup=void 0,this.chart=t,this.navButtons=[],this.init(t)}init(t){this.chart=t}update(t){function p(t){this.handler.call(d,t),x(t)}const c=this,d=c.chart,u=c.navButtons;let m=d.options.mapNavigation,g;for(t&&(m=d.options.mapNavigation=y(d.options.mapNavigation,t));u.length;)u.pop().destroy();if(!d.renderer.forExport&&n(m.enableButtons,m.enabled)){c.navButtonsGroup||(c.navButtonsGroup=d.renderer.g().attr({zIndex:4}).add()),o(m.buttons,(t,e)=>{t=y(m.buttonOptions,t),!d.styledMode&&t.theme&&((g=t.theme).style=y(t.theme.style,t.style));var{text:o,width:s=0,height:i=0,padding:r=0}=t;const a=d.renderer.button("+"!==o&&"-"!==o&&o||"",0,0,p,g,void 0,void 0,void 0,"zoomIn"===e?"topbutton":"bottombutton").addClass("highcharts-map-navigation highcharts-"+{zoomIn:"zoom-in",zoomOut:"zoom-out"}[e]).attr({width:s,height:i,title:d.options.lang[e],padding:t.padding,zIndex:5}).add(c.navButtonsGroup);if("+"===o||"-"===o){const n=s+1,l=[["M",r+3,r+i/2],["L",r+n-3,r+i/2]];"+"===o&&l.push(["M",r+n/2,r+3],["L",r+n/2,r+i-3]),d.renderer.path(l).addClass("highcharts-button-symbol").attr(d.styledMode?{}:{stroke:t.style?.color,"stroke-width":3,"stroke-linecap":"round"}).add(a)}if(a.handler=t.onclick,f(a.element,"dblclick",x),u.push(a),b(t,{width:a.width,height:2*(a.height||0)}),d.hasLoaded)a.align(t,!1,t.alignTo);else{const h=f(d,"load",()=>{a.element&&a.align(t,!1,t.alignTo),h()})}});const s=(t,e)=>!(e.x>=t.x+t.width||e.x+e.width<=t.x||e.y>=t.y+t.height||e.y+e.height<=t.y);d.hasLoaded||f(d,"render",function(){var t,e,o=d.exportingGroup&&d.exportingGroup.getBBox();o&&(e=c.navButtonsGroup.getBBox(),s(o,e)&&(t=-e.y-e.height+o.y-5,o=o.y+o.height-e.y+5,e=m.buttonOptions&&m.buttonOptions.verticalAlign,c.navButtonsGroup.attr({translateY:"bottom"===e?t:o})))})}this.updateEvents(m)}updateEvents(t){const e=this.chart;n(t.enableDoubleClickZoom,t.enabled)||t.enableDoubleClickZoomTo?this.unbindDblClick=this.unbindDblClick||f(e.container,"dblclick",function(t){e.pointer.onContainerDblClick(t)}):this.unbindDblClick&&(this.unbindDblClick=this.unbindDblClick()),n(t.enableMouseWheelZoom,t.enabled)?this.unbindMouseWheel=this.unbindMouseWheel||f(e.container,"wheel",function(t){return e.pointer.inClass(t.target,"highcharts-no-mousewheel")||(e.pointer.onContainerMouseWheel(t),x(t)),!1}):this.unbindMouseWheel&&(this.unbindMouseWheel=this.unbindMouseWheel())}}}),e(t,"Series/ColorMapComposition.js",[t["Core/Series/SeriesRegistry.js"],t["Core/Utilities.js"]],function(t,o){const e=t.seriesTypes["column"]["prototype"],{addEvent:s,defined:i}=o;var r;{t=r=r||{};const n=[];function a(t){this.moveToTopOnHover&&this.graphic&&this.graphic.attr({zIndex:t&&"hover"===t.state?1:0})}t.pointMembers={dataLabelOnNull:!0,moveToTopOnHover:!0,isValid:function(){return null!==this.value&&this.value!==1/0&&this.value!==-1/0&&(void 0===this.value||!isNaN(this.value))}},t.seriesMembers={colorKey:"value",axisTypes:["xAxis","yAxis","colorAxis"],parallelArrays:["x","y","value"],pointArrayMap:["value"],trackerGroups:["group","markerGroup","dataLabelsGroup"],colorAttribs:function(t){const e={};!i(t.color)||t.state&&"normal"!==t.state||(e[this.colorProp||"fill"]=t.color);return e},pointAttribs:e.pointAttribs},t.compose=function(t){var e=t.prototype.pointClass;return o.pushUnique(n,e)&&s(e,"afterSetState",a),t}}return r}),e(t,"Core/Chart/MapChart.js",[t["Core/Chart/Chart.js"],t["Core/Defaults.js"],t["Core/Renderer/SVG/SVGRenderer.js"],t["Core/Utilities.js"]],function(t,e,s,o){const i=e["getOptions"],{isNumber:r,merge:a,pick:n}=o;class l extends t{init(t,e){var o=i().credits,o=a({chart:{panning:{enabled:!0,type:"xy"},type:"map"},credits:{mapText:n(o.mapText,' © <a href="{geojson.copyrightUrl}">{geojson.copyrightShort}</a>'),mapTextFull:n(o.mapTextFull,"{geojson.copyright}")},mapView:{},tooltip:{followTouchMove:!1}},t);super.init(o,e)}mapZoom(t,e,o,s,i){this.mapView&&(r(t)&&(t=Math.log(t)/Math.log(.5)),this.mapView.zoomBy(t,r(e)&&r(o)?this.mapView.projection.inverse([e,o]):void 0,r(s)&&r(i)?[s,i]:void 0))}}var h;return(h=l=l||{}).maps={},h.mapChart=function(t,e,o){return new h(t,e,o)},h.splitPath=function(t){let e;if("string"==typeof t){const o=(t=t.replace(/([A-Za-z])/g," $1 ").replace(/^\s*/,"").replace(/\s*$/,"")).split(/[ ,;]+/);e=o.map(t=>/[A-za-z]/.test(t)?t:parseFloat(t))}else e=t;return s.prototype.pathToSegments(e)},l}),e(t,"Maps/MapUtilities.js",[],function(){return{boundsFromPath:function(t){let o=-Number.MAX_VALUE,s=Number.MAX_VALUE,i=-Number.MAX_VALUE,r=Number.MAX_VALUE,a;if(t.forEach(t=>{var e=t[t.length-2],t=t[t.length-1];"number"==typeof e&&"number"==typeof t&&(s=Math.min(s,e),o=Math.max(o,e),r=Math.min(r,t),i=Math.max(i,t),a=!0)}),a)return{x1:s,y1:r,x2:o,y2:i}},pointInPolygon:function(t,e){let o,s,i=!1,r=t.x,a=t.y;for(o=0,s=e.length-1;o<e.length;s=o++)e[o][1]>a!=e[s][1]>a&&r<(e[s][0]-e[o][0])*(a-e[o][1])/(e[s][1]-e[o][1])+e[o][0]&&(i=!i);return i}}}),e(t,"Series/Map/MapPoint.js",[t["Series/ColorMapComposition.js"],t["Maps/MapUtilities.js"],t["Core/Series/SeriesRegistry.js"],t["Core/Utilities.js"]],function(t,e,o,s){const n=e["boundsFromPath"];e=o.seriesTypes.scatter.prototype.pointClass;const{extend:r,isNumber:l,pick:h}=s;class p extends e{constructor(){super(...arguments),this.options=void 0,this.path=void 0,this.series=void 0}static getProjectedPath(t,e){return t.projectedPath||(e&&t.geometry?(e.hasCoordinates=!0,t.projectedPath=e.path(t.geometry)):t.projectedPath=t.path),t.projectedPath||[]}applyOptions(t,e){const o=this.series,s=super.applyOptions(t,e),i=o.joinBy;return o.mapData&&o.mapMap&&(t=i[1],(t=void 0!==(e=super.getNestedProperty(t))&&o.mapMap[e])?r(s,t):-1!==o.pointArrayMap.indexOf("value")&&(s.value=s.value||null)),s}getProjectedBounds(t){const e=p.getProjectedPath(this,t),o=n(e),s=this.properties,i=this.series.chart.mapView;if(o){var r=s&&s["hc-middle-lon"],a=s&&s["hc-middle-lat"];if(i&&l(r)&&l(a)){t=t.forward([r,a]);o.midX=t[0],o.midY=t[1]}else{r=s&&s["hc-middle-x"],a=s&&s["hc-middle-y"];o.midX=o.x1+(o.x2-o.x1)*h(this.middleX,l(r)?r:.5);let t=h(this.middleY,l(a)?a:.5);this.geometry||(t=1-t),o.midY=o.y2-(o.y2-o.y1)*t}return o}}onMouseOver(t){s.clearTimeout(this.colorInterval),!this.isNull&&this.visible||this.series.options.nullInteraction?super.onMouseOver.call(this,t):this.series.onMouseOut()}setVisible(t){var e=t?"show":"hide";this.visible=this.options.visible=!!t,this.dataLabel&&this.dataLabel[e](),this.graphic&&this.graphic.attr(this.series.pointAttribs(this))}zoomTo(t){const e=this,o=e.series.chart,s=o.mapView;let i=e.bounds;if(s&&i){const n=l(e.insetIndex)&&s.insets[e.insetIndex];var r,a;n&&(r=n.projectedUnitsToPixels({x:i.x1,y:i.y1}),a=n.projectedUnitsToPixels({x:i.x2,y:i.y2}),r=s.pixelsToProjectedUnits({x:r.x,y:r.y}),a=s.pixelsToProjectedUnits({x:a.x,y:a.y}),i={x1:r.x,y1:r.y,x2:a.x,y2:a.y}),s.fitToBounds(i,void 0,!1),e.series.isDirty=!0,o.redraw(t)}}}return r(p.prototype,{dataLabelOnNull:t.pointMembers.dataLabelOnNull,moveToTopOnHover:t.pointMembers.moveToTopOnHover,isValid:t.pointMembers.isValid}),p}),e(t,"Series/Map/MapSeriesDefaults.js",[t["Core/Utilities.js"]],function(t){const o=t["isNumber"];return{affectsMapView:!0,animation:!1,dataLabels:{crop:!1,formatter:function(){const t=this.series.chart["numberFormatter"];var e=this.point["value"];return o(e)?t(e,-1):""},inside:!0,overflow:!1,padding:0,verticalAlign:"middle"},linecap:"round",marker:null,nullColor:"#f7f7f7",stickyTracking:!1,tooltip:{followPointer:!0,pointFormat:"{point.name}: {point.value}<br/>"},turboThreshold:0,allAreas:!0,borderColor:"#e6e6e6",borderWidth:1,joinBy:"hc-key",states:{hover:{halo:void 0,borderColor:"#666666",borderWidth:2},normal:{animation:!0},select:{color:"#cccccc"}},legendSymbol:"rectangle"}}),e(t,"Maps/MapViewDefaults.js",[],function(){return{center:[0,0],fitToGeometry:void 0,maxZoom:void 0,padding:0,projection:{name:void 0,parallels:void 0,rotation:void 0},zoom:void 0,insetOptions:{borderColor:"#cccccc",borderWidth:1,padding:"10%",relativeTo:"mapBoundingBox",units:"percent"}}}),e(t,"Maps/GeoJSONComposition.js",[t["Core/Globals.js"],t["Core/Templating.js"],t["Core/Utilities.js"]],function(t,e,o){const u=t["win"],h=e["format"],{error:m,extend:p,merge:s,pushUnique:i,wrap:r}=o;var a;{t=a=a||{};const b=[];function n(t){return this.mapView&&this.mapView.lonLatToProjectedUnits(t)}function l(t){return this.mapView&&this.mapView.projectedUnitsToLonLat(t)}function c(t,e){const o=this.options.chart.proj4||u.proj4;var s,i,r,a,n,l,h,p,c,d;{if(o)return{jsonmarginX:s=0,jsonmarginY:i=0,jsonres:r=1,scale:a=1,xoffset:n=0,xpan:l=0,yoffset:h=0,ypan:p=0}=e,t=o(e.crs,[t.lon,t.lat]),c=e.cosAngle||e.rotation&&Math.cos(e.rotation),d=e.sinAngle||e.rotation&&Math.sin(e.rotation),{x:(((e=e.rotation?[t[0]*c+t[1]*d,-t[0]*d+t[1]*c]:t)[0]-n)*a+l)*r+s,y:-(((h-e[1])*a+p)*r-i)};m(21,!1,this)}}function d(t,e){const o=this.options.chart.proj4||u.proj4;var s,i,r,a,n,l,h,p;if(o){if(null!==t.y)return{jsonmarginX:l=0,jsonmarginY:s=0,jsonres:i=1,scale:r=1,xoffset:p=0,xpan:h=0,yoffset:a=0,ypan:n=0}=e,l={x:((t.x-l)/i-h)/r+p,y:((t.y-s)/i+n)/r+a},h=e.cosAngle||e.rotation&&Math.cos(e.rotation),p=e.sinAngle||e.rotation&&Math.sin(e.rotation),{lat:(t=o(e.crs,"WGS84",e.rotation?{x:l.x*h+l.y*-p,y:l.x*p+l.y*h}:l)).y,lon:t.x}}else m(21,!1,this)}function g(t,e){e=e||Object.keys(t.objects)[0];const o=t.objects[e];if(o["hc-decoded-geojson"])return o["hc-decoded-geojson"];let r=t.arcs;if(t.transform){var a=t.arcs,{scale:n,translate:l}=t.transform;let o,s,i;r=[];for(let t=0,e=a.length;t<e;++t){var h=a[t];r.push(o=[]),s=0;for(let t=i=0,e=h.length;t<e;++t)o.push([(s+=h[t][0])*n[0]+l[0],(i+=h[t][1])*n[1]+l[1]])}}const s=t=>"number"==typeof t[0]?t.reduce((t,e,o)=>{let s=e<0?r[~e]:r[e];return e<0?(s=s.slice(0,0===o?s.length:s.length-1)).reverse():o&&(s=s.slice(1)),t.concat(s)},[]):t.map(s),i=o.geometries,p=[];for(let t=0,e=i.length;t<e;++t)p.push({type:"Feature",properties:i[t].properties,geometry:{type:i[t].type,coordinates:i[t].coordinates||s(i[t].arcs)}});e={type:"FeatureCollection",copyright:t.copyright,copyrightShort:t.copyrightShort,copyrightUrl:t.copyrightUrl,features:p,"hc-recommended-mapview":o["hc-recommended-mapview"],bbox:t.bbox,title:t.title};return o["hc-decoded-geojson"]=e}function f(t,e){e=s(!0,this.options.credits,e),this.mapCredits&&(e.href=void 0),t.call(this,e),this.credits&&this.mapCreditsFull&&this.credits.attr({title:this.mapCreditsFull})}t.compose=function(t){if(i(b,t)){const e=t.prototype;e.fromLatLonToPoint=n,e.fromPointToLatLon=l,e.transformFromLatLon=c,e.transformToLatLon=d,r(e,"addCredits",f)}},t.geojson=function(t,o="map",e){const s=[];var i=(t="Topology"===t.type?g(t):t).features;for(let e=0,t=i.length;e<t;++e){var r,a=i[e],n=a.geometry||{},l=n.type,n=n.coordinates,a=a.properties;let t;("map"!==o&&"mapbubble"!==o||"Polygon"!==l&&"MultiPolygon"!==l)&&("mapline"!==o||"LineString"!==l&&"MultiLineString"!==l)?"mappoint"===o&&"Point"===l&&n.length&&(t={geometry:{coordinates:n,type:l}}):n.length&&(t={geometry:{coordinates:n,type:l}}),t&&(n=a&&(a.name||a.NAME),l=a&&a.lon,r=a&&a.lat,s.push(p(t,{lat:"number"==typeof r?r:void 0,lon:"number"==typeof l?l:void 0,name:"string"==typeof n?n:void 0,properties:a})))}return e&&t.copyrightShort&&(e.chart.mapCredits=h(e.chart.options.credits?.mapText,{geojson:t}),e.chart.mapCreditsFull=h(e.chart.options.credits?.mapTextFull,{geojson:t})),s},t.topo2geo=g}return a}),e(t,"Core/Geometry/PolygonClip.js",[],function(){function i(t,e,o=!0){let s=e[e.length-1],i,r,a,n=t;for(let t=0;t<e.length;t++){var l=n;i=e[t],n=[],r=o?l[l.length-1]:l[0];for(let t=0;t<l.length;t++)a=l[t],h(s,i,a)?(h(s,i,r)||n.push(p(s,i,r,a)),n.push(a)):h(s,i,r)&&n.push(p(s,i,r,a)),r=a;s=i}return n}function h(t,e,o){return(e[0]-t[0])*(o[1]-t[1])>(e[1]-t[1])*(o[0]-t[0])}function p(t,e,o,s){const i=[t[0]-e[0],t[1]-e[1]],r=[o[0]-s[0],o[1]-s[1]],a=t[0]*e[1]-t[1]*e[0],n=o[0]*s[1]-o[1]*s[0],l=1/(i[0]*r[1]-i[1]*r[0]),h=[(a*r[0]-n*i[0])*l,(a*r[1]-n*i[1])*l];return h.isIntersection=!0,h}return{clipLineString:function(t,e){const o=[],s=i(t,e,!1);for(let t=1;t<s.length;t++)s[t].isIntersection&&s[t-1].isIntersection&&(o.push(s.splice(0,t)),t=0),t===s.length-1&&o.push(s);return o},clipPolygon:i}}),e(t,"Maps/Projections/LambertConformalConic.js",[],function(){const a=Math.sign||(t=>0===t?0:0<t?1:-1),p=63.78137,c=Math.PI/180,d=Math.PI/2,u=t=>Math.tan((d+t)/2);return class{constructor(t){var e=(t.parallels||[]).map(t=>t*c),o=e[0]||0,e=e[1]??o,s=Math.cos(o);"object"==typeof t.projectedBounds&&(this.projectedBounds=t.projectedBounds);let i=o===e?Math.sin(o):Math.log(s/Math.cos(e))/Math.log(u(e)/u(o));Math.abs(i)<1e-10&&(i=1e-10*(a(i)||1)),this.n=i,this.c=s*Math.pow(u(o),i)/i}forward(t){var{c:e,n:o,projectedBounds:s}=this,i=t[0]*c;let r=t[1]*c;0<e?r<1e-6-d&&(r=1e-6-d):r>d-1e-6&&(r=d-1e-6);const a=e/Math.pow(u(r),o),n=a*Math.sin(o*i)*p,l=(e-a*Math.cos(o*i))*p,h=[n,l];return s&&(n<s.x1||n>s.x2||l<s.y1||l>s.y2)&&(h.outside=!0),h}inverse(t){var{c:e,n:o}=this,s=t[0]/p,t=e-t[1]/p,i=a(o)*Math.sqrt(s*s+t*t);let r=Math.atan2(s,Math.abs(t))*a(t);return t*o<0&&(r-=Math.PI*a(s)*a(t)),[r/o/c,(2*Math.atan(Math.pow(e/i,1/o))-d)/c]}}}),e(t,"Maps/Projections/EqualEarth.js",[],function(){const h=1.340264,p=-.081106,c=893e-6,d=.003796,u=Math.sqrt(3)/2,m=74.03120656864502;return class{constructor(){this.bounds={x1:-200.37508342789243,x2:200.37508342789243,y1:-97.52595454902263,y2:97.52595454902263}}forward(t){var e=Math.PI/180,o=Math.asin(u*Math.sin(t[1]*e)),s=o*o,i=s*s*s;return[t[0]*e*Math.cos(o)*m/(u*(h+3*p*s+i*(7*c+9*d*s))),o*m*(h+p*s+i*(c+d*s))]}inverse(t){var e=t[0]/m,o=t[1]/m,t=180/Math.PI;let s=o,i,r,a,n,l;for(let t=0;t<12&&(i=s*s,r=i*i*i,a=s*(h+p*i+r*(c+d*i))-o,n=h+3*p*i+r*(7*c+9*d*i),s-=l=a/n,!(Math.abs(l)<1e-9));++t);i=s*s,r=i*i*i;e=t*u*e*(h+3*p*i+r*(7*c+9*d*i))/Math.cos(s),t*=Math.asin(Math.sin(s)/u);return 180<Math.abs(e)?[NaN,NaN]:[e,t]}}}),e(t,"Maps/Projections/Miller.js",[],function(){const e=Math.PI/4,o=Math.PI/180,s=63.78137;return class{constructor(){this.bounds={x1:-200.37508342789243,x2:200.37508342789243,y1:-146.91480769173063,y2:146.91480769173063}}forward(t){return[t[0]*o*s,1.25*s*Math.log(Math.tan(e+.4*t[1]*o))]}inverse(t){return[t[0]/s/o,2.5*(Math.atan(Math.exp(t[1]/s*.8))-e)/o]}}}),e(t,"Maps/Projections/Orthographic.js",[],function(){const r=Math.PI/180,a=63.78460826781007;return class{constructor(){this.antimeridianCutting=!1,this.bounds={x1:-a,x2:a,y1:-a,y2:a}}forward(t){const e=t[0],o=t[1],s=o*r,i=[Math.cos(s)*Math.sin(e*r)*a,Math.sin(s)*a];return(e<-90||90<e)&&(i.outside=!0),i}inverse(t){var e=t[0]/a,t=t[1]/a,o=Math.sqrt(e*e+t*t),s=Math.asin(o),i=Math.sin(s),s=Math.cos(s);return[Math.atan2(e*i,o*s)/r,Math.asin(o&&t*i/o)/r]}}}),e(t,"Maps/Projections/WebMercator.js",[],function(){const s=63.78137,i=Math.PI/180;return class{constructor(){this.bounds={x1:-200.37508342789243,x2:200.37508342789243,y1:-200.3750834278071,y2:200.3750834278071},this.maxLatitude=85.0511287798}forward(t){const e=Math.sin(t[1]*i),o=[s*t[0]*i,s*Math.log((1+e)/(1-e))/2];return Math.abs(t[1])>this.maxLatitude&&(o.outside=!0),o}inverse(t){return[t[0]/(s*i),(2*Math.atan(Math.exp(t[1]/s))-Math.PI/2)/i]}}}),e(t,"Maps/Projections/ProjectionRegistry.js",[t["Maps/Projections/LambertConformalConic.js"],t["Maps/Projections/EqualEarth.js"],t["Maps/Projections/Miller.js"],t["Maps/Projections/Orthographic.js"],t["Maps/Projections/WebMercator.js"]],function(t,e,o,s,i){return{EqualEarth:e,LambertConformalConic:t,Miller:o,Orthographic:s,WebMercator:i}}),e(t,"Maps/Projection.js",[t["Core/Geometry/PolygonClip.js"],t["Maps/Projections/ProjectionRegistry.js"],t["Core/Utilities.js"]],function(t,e,o){const{clipLineString:v,clipPolygon:M}=t,{clamp:j,erase:C}=o,w=2*Math.PI/360,P=1e-6;function S(t){return t<-180&&(t+=360),180<t&&(t-=360),t}class L{static add(t,e){L.registry[t]=e}static greatCircle(t,e,o){const{atan2:s,cos:i,sin:r,sqrt:a}=Math,n=t[1]*w,l=t[0]*w,h=e[1]*w,p=e[0]*w,c=h-n,d=p-l,u=r(c/2)*r(c/2)+i(n)*i(h)*r(d/2)*r(d/2),m=2*s(a(u),a(1-u)),g=6371e3*m,f=Math.round(g/5e5),b=[];if(o&&b.push(t),1<f){var y=1/f;for(let t=y;t<.999;t+=y){var x=r((1-t)*m)/r(m),v=r(t*m)/r(m),M=x*i(n)*i(l)+v*i(h)*i(p),j=x*i(n)*r(l)+v*i(h)*r(p),x=x*r(n)+v*r(h),v=s(x,a(M*M+j*j)),x=s(j,M);b.push([x/w,v/w])}}return o&&b.push(e),b}static insertGreatCircles(t){let e=t.length-1;for(;e--;){var o;10<Math.max(Math.abs(t[e][0]-t[e+1][0]),Math.abs(t[e][1]-t[e+1][1]))&&((o=L.greatCircle(t[e],t[e+1])).length&&t.splice(e+1,0,...o))}}static toString(t){const{name:e,rotation:o}=t||{};return[e,o&&o.join(",")].join(";")}constructor(t={}){this.hasCoordinates=!1,this.hasGeoProjection=!1,this.maxLatitude=90;var{name:e,projectedBounds:o,rotation:s}=this.options=t;this.rotator=s?this.getRotator(s):void 0;const i=e?L.registry[e]:void 0,{def:r,rotator:a}=(i&&(this.def=new i(t)),this);r&&(this.maxLatitude=r.maxLatitude||90,this.hasGeoProjection=!0),a&&r?(this.forward=t=>r.forward(a.forward(t)),this.inverse=t=>a.inverse(r.inverse(t))):r?(this.forward=t=>r.forward(t),this.inverse=t=>r.inverse(t)):a&&(this.forward=a.forward,this.inverse=a.inverse),this.bounds="world"===o?r&&r.bounds:o}lineIntersectsBounds(t){var{x1:e,x2:o,y1:s,y2:i}=this.bounds||{},r=(t,e,o)=>{var s,[t,i]=t,r=e?0:1;if("number"==typeof o&&t[e]>=o!=i[e]>=o)return s=(o-t[e])/(i[e]-t[e]),s=t[r]+s*(i[r]-t[r]),e?[s,o]:[o,s]};let a,n=t[0];return((a=r(t,0,e))||(a=r(t,0,o)))&&(n=a,t[1]=a),n=(a=r(t,1,s))||(a=r(t,1,i))?a:n}getRotator(t){const i=t[0]*w,e=(t[1]||0)*w,o=(t[2]||0)*w,r=Math.cos(e),a=Math.sin(e),n=Math.cos(o),l=Math.sin(o);if(0!=i||0!=e||0!=o)return{forward:t=>{var e=t[0]*w+i,t=t[1]*w,o=Math.cos(t),s=Math.cos(e)*o,e=Math.sin(e)*o,o=Math.sin(t),t=o*r+s*a;return[Math.atan2(e*n-t*l,s*r-o*a)/w,Math.asin(t*n+e*l)/w]},inverse:t=>{var e=t[0]*w,t=t[1]*w,o=Math.cos(t),s=Math.cos(e)*o,e=Math.sin(e)*o,o=Math.sin(t),t=o*n-e*l;return[(Math.atan2(e*n+o*l,s*r+t*a)-i)/w,Math.asin(t*r-s*a)/w]}}}forward(t){return t}inverse(t){return t}cutOnAntimeridian(o,s){const i=[],e=[o];for(let e=0,t=o.length;e<t;++e){var r=o[e];let t=o[e-1];if(!e){if(!s)continue;t=o[o.length-1]}var a=t[0],n=r[0];(a<-90||90<a)&&(n<-90||90<n)&&0<a!=0<n&&(n=j((180-(a+360)%360)/((n+360)%360-(a+360)%360),0,1),n=t[1]+n*(r[1]-t[1]),i.push({i:e,lat:n,direction:a<0?1:-1,previousLonLat:t,lonLat:r}))}let l;if(i.length)if(s){i.length%2==1&&(l=i.slice().sort((t,e)=>Math.abs(e.lat)-Math.abs(t.lat))[0],C(i,l));let t=i.length-2;for(;0<=t;){var h=i[t].i,p=S(180+i[t].direction*P),c=S(180-i[t].direction*P);const f=o.splice(h,i[t+1].i-h,...L.greatCircle([p,i[t].lat],[p,i[t+1].lat],!0));f.push(...L.greatCircle([c,i[t+1].lat],[c,i[t].lat],!0)),e.push(f),t-=2}if(l)for(let t=0;t<e.length;t++){const{direction:b,lat:y}=l,o=e[t],x=o.indexOf(l.lonLat);if(-1<x){var d=(y<0?-1:1)*this.maxLatitude,u=S(180+b*P),m=S(180-b*P);const v=L.greatCircle([u,y],[u,d],!0);for(let t=u+120*b;-180<t&&t<180;t+=120*b)v.push([t,d]);v.push(...L.greatCircle([m,d],[m,l.lat],!0)),o.splice(x,0,...v);break}}}else{let t=i.length;for(;t--;){var g=i[t].i;const M=o.splice(g,o.length,[S(180+i[t].direction*P),i[t].lat]);M.unshift([S(180-i[t].direction*P),i[t].lat]),e.push(M)}}return e}path(t){const{bounds:u,def:e,rotator:o}=this,m=[],g="Polygon"===t.type||"MultiPolygon"===t.type,f=this.hasGeoProjection,b=!e||!1!==e.antimeridianCutting,s=b?o:void 0,y=b&&e||this;let x;u&&(x=[[u.x1,u.y1],[u.x2,u.y1],[u.x2,u.y2],[u.x1,u.y2]]);const i=t=>{t=t.map(e=>{if(b){let t=(e=s?s.forward(e):e)[0];e=[t=Math.abs(t-180)<P?t<180?180-P:180+P:t,e[1]]}return e});let e=[t];f&&(L.insertGreatCircles(t),b&&(e=this.cutOnAntimeridian(t,g))),e.forEach(l=>{if(!(l.length<2)){let e=!1,o,s,i=!1;const c=t=>{e?m.push(["L",t[0],t[1]]):(m.push(["M",t[0],t[1]]),e=!0)};let r=!1,a=!1,n=l.map(t=>{const e=y.forward(t);return e.outside?r=!0:a=!0,e[1]===1/0?e[1]=1e10:e[1]===-1/0&&(e[1]=-1e10),e});if(b){if(g&&n.push(n[0]),r){if(!a)return;if(x)if(g)n=M(n,x);else if(u)return void v(n,x).forEach(t=>{e=!1,t.forEach(c)})}n.forEach(c)}else for(let t=0;t<n.length;t++){var h=l[t],p=n[t];if(p.outside)i=!0;else{if(g&&!o&&(o=h,l.push(h),n.push(p)),i&&s)if(g&&f){const d=L.greatCircle(s,h);d.forEach(t=>c(y.forward(t)))}else e=!1;c(p),s=h,i=!1}}}})};return"LineString"===t.type?i(t.coordinates):"MultiLineString"===t.type?t.coordinates.forEach(t=>i(t)):"Polygon"===t.type?(t.coordinates.forEach(t=>i(t)),m.length&&m.push(["Z"])):"MultiPolygon"===t.type&&(t.coordinates.forEach(t=>{t.forEach(t=>i(t))}),m.length&&m.push(["Z"])),m}}return L.registry=e,L}),e(t,"Maps/MapView.js",[t["Maps/MapViewDefaults.js"],t["Maps/GeoJSONComposition.js"],t["Maps/MapUtilities.js"],t["Maps/Projection.js"],t["Core/Utilities.js"]],function(h,t,e,p,o){const s=t["topo2geo"],{boundsFromPath:a,pointInPolygon:l}=e,{addEvent:d,clamp:u,fireEvent:f,isArray:n,isNumber:b,isObject:i,isString:r,merge:c,pick:m,pushUnique:g,relativeLength:y}=o,x=[],v=400.979322;let M={};function j(t,e){var{width:e,height:o}=e,e=Math.max((t.x2-t.x1)/(e/256),(t.y2-t.y1)/(o/256));return Math.log(v/e)/Math.log(2)}class C{static compose(t){g(x,t)&&(M=t.maps,d(t,"afterInit",function(){this.mapView=new C(this,this.options.mapView)},{order:0}))}static compositeBounds(t){if(t.length)return t.slice(1).reduce((t,e)=>(t.x1=Math.min(t.x1,e.x1),t.y1=Math.min(t.y1,e.y1),t.x2=Math.max(t.x2,e.x2),t.y2=Math.max(t.y2,e.y2),t),c(t[0]))}static mergeInsets(t,e){var o=t=>{const o={};return t.forEach((t,e)=>{o[t&&t.id||"i"+e]=t}),o};const s=c(o(t),o(e)),i=Object.keys(s).map(t=>s[t]);return i}constructor(t,e){this.allowTransformAnimation=!0,this.eventsToUnbind=[],this.insets=[],this.padding=[0,0,0,0];let i,r;if(!(this instanceof w)){const a=[t.options.chart.map,...(t.options.series||[]).map(t=>t.mapData)].map(t=>this.getGeoMap(t)),n=[],l=(a.forEach(t=>{var e,o,s;t&&(i=i||t["hc-recommended-mapview"],t.bbox&&([t,e,o,s]=t.bbox,n.push({x1:t,y1:e,x2:o,y2:s})))}),n.length&&C.compositeBounds(n));f(t,"beforeMapViewInit",{geoBounds:l},function(){var t,e,o,s;l&&({x1:t,y1:e,x2:o,y2:s}=l,r=180<o-t&&90<s-e?{name:"EqualEarth"}:{name:"LambertConformalConic",parallels:[e,s],rotation:[-(t+o)/2]})}),this.geoMap=a[0]}this.userOptions=e||{},t.options.mapView&&t.options.mapView.recommendedMapView&&(i=t.options.mapView.recommendedMapView);const o=c(h,{projection:r},i,e);var s=i&&i.insets,e=e&&e.insets;s&&e&&(o.insets=C.mergeInsets(s,e)),this.chart=t,this.center=o.center,this.options=o,this.projection=new p(o.projection),this.playingField=t.plotBox,this.zoom=o.zoom||0,this.minZoom=o.minZoom,this.createInsets(),this.eventsToUnbind.push(d(t,"afterSetChartSize",()=>{this.playingField=this.getField(),void 0!==this.minZoom&&this.minZoom!==this.zoom||(this.fitToBounds(void 0,void 0,!1),!this.chart.hasRendered&&b(this.userOptions.zoom)&&(this.zoom=this.userOptions.zoom),this.userOptions.center&&c(!0,this.center,this.userOptions.center))})),this.setUpEvents()}createInsets(){const e=this.options,t=e.insets;t&&t.forEach(t=>{t=new w(this,c(e.insetOptions,t));this.insets.push(t)})}fitToBounds(t,e,o=!0,s){var i,r=t||this.getProjectedBounds();r&&(e=m(e,t?0:this.options.padding),i=this.getField(!1),e=n(e)?e:[e,e,e,e],this.padding=[y(e[0],i.height),y(e[1],i.width),y(e[2],i.height),y(e[3],i.width)],this.playingField=this.getField(),e=j(r,this.playingField),t||(this.minZoom=e),i=this.projection.inverse([(r.x2+r.x1)/2,(r.y2+r.y1)/2]),this.setView(i,e,o,s))}getField(t=!0){t=t?this.padding:[0,0,0,0];return{x:t[3],y:t[0],width:this.chart.plotWidth-t[1]-t[3],height:this.chart.plotHeight-t[0]-t[2]}}getGeoMap(t){return r(t)?M[t]&&"Topology"===M[t].type?s(M[t]):M[t]:i(t,!0)?"FeatureCollection"===t.type?t:"Topology"===t.type?s(t):void 0:void 0}getMapBBox(){var t,e,o=this.getProjectedBounds(),s=this.getScale();if(o)return t=this.padding,e=this.projectedUnitsToPixels({x:o.x1,y:o.y2}),{width:(o.x2-o.x1)*s+t[1]+t[3],height:(o.y2-o.y1)*s+t[0]+t[2],x:e.x-t[3],y:e.y-t[0]}}getProjectedBounds(){const e=this.projection;var t=this.chart.series.reduce((t,e)=>{var o=e.getProjectedBounds&&e.getProjectedBounds();return o&&!1!==e.options.affectsMapView&&t.push(o),t},[]);const o=this.options.fitToGeometry;if(o){if(!this.fitToGeometryCache)if("MultiPoint"===o.type){const s=o.coordinates.map(t=>e.forward(t)),i=s.map(t=>t[0]),r=s.map(t=>t[1]);this.fitToGeometryCache={x1:Math.min.apply(0,i),x2:Math.max.apply(0,i),y1:Math.min.apply(0,r),y2:Math.max.apply(0,r)}}else this.fitToGeometryCache=a(e.path(o));return this.fitToGeometryCache}return this.projection.bounds||C.compositeBounds(t)}getScale(){return 256/v*Math.pow(2,this.zoom)}getSVGTransform(){var{x:t,y:e,width:o,height:s}=this.playingField,i=this.projection.forward(this.center),r=this.projection.hasCoordinates?-1:1,a=this.getScale(),r=a*r;return{scaleX:a,scaleY:r,translateX:t+o/2-i[0]*a,translateY:e+s/2-i[1]*r}}lonLatToPixels(t){t=this.lonLatToProjectedUnits(t);if(t)return this.projectedUnitsToPixels(t)}lonLatToProjectedUnits(t){const e=this.chart,o=e.mapTransforms;if(o){for(const a in o)if(Object.hasOwnProperty.call(o,a)&&o[a].hitZone){var s=e.transformFromLatLon(t,o[a]);if(s&&l(s,o[a].hitZone.coordinates[0]))return s}return e.transformFromLatLon(t,o.default)}for(const n of this.insets){var i;if(n.options.geoBounds&&l({x:t.lon,y:t.lat},n.options.geoBounds.coordinates[0]))return i=n.projection.forward([t.lon,t.lat]),i=n.projectedUnitsToPixels({x:i[0],y:i[1]}),this.pixelsToProjectedUnits(i)}var r=this.projection.forward([t.lon,t.lat]);if(!r.outside)return{x:r[0],y:r[1]}}projectedUnitsToLonLat(t){const e=this.chart,o=e.mapTransforms;if(o){for(const r in o)if(Object.hasOwnProperty.call(o,r)&&o[r].hitZone&&l(t,o[r].hitZone.coordinates[0]))return e.transformToLatLon(t,o[r]);return e.transformToLatLon(t,o.default)}var s=this.projectedUnitsToPixels(t);for(const a of this.insets)if(a.hitZone&&l(s,a.hitZone.coordinates[0])){const n=a.pixelsToProjectedUnits(s),i=a.projection.inverse([n.x,n.y]);return{lon:i[0],lat:i[1]}}const i=this.projection.inverse([t.x,t.y]);return{lon:i[0],lat:i[1]}}redraw(t){this.chart.series.forEach(t=>{t.useMapGeometry&&(t.isDirty=!0)}),this.chart.redraw(t)}setView(t,e,o=!0,s){t&&(this.center=t),"number"==typeof e&&("number"==typeof this.minZoom&&(e=Math.max(e,this.minZoom)),"number"==typeof this.options.maxZoom&&(e=Math.min(e,this.options.maxZoom)),b(e)&&(this.zoom=e));var i,r,t=this.getProjectedBounds();if(t){const a=this.projection.forward(this.center),{x:n,y:l,width:h,height:p}=this.playingField,c=this.getScale(),d=this.projectedUnitsToPixels({x:t.x1,y:t.y1}),u=this.projectedUnitsToPixels({x:t.x2,y:t.y2}),m=[(t.x1+t.x2)/2,(t.y1+t.y2)/2],g=this.chart.series.some(t=>t.isDrilling);g||(e=d.x,t=u.y,i=u.x,r=d.y,i-e<h?a[0]=m[0]:e<n&&i<n+h?a[0]+=Math.max(e-n,i-h-n)/c:n+h<i&&n<e&&(a[0]+=Math.min(i-h-n,e-n)/c),r-t<p?a[1]=m[1]:t<l&&r<l+p?a[1]-=Math.max(t-l,r-p-l)/c:l+p<r&&l<t&&(a[1]-=Math.min(r-p-l,t-l)/c),this.center=this.projection.inverse(a)),this.insets.forEach(t=>{t.options.field&&(t.hitZone=t.getHitZone(),t.playingField=t.getField())}),this.render()}f(this,"afterSetView"),o&&this.redraw(s)}projectedUnitsToPixels(t){var e=this.getScale(),o=this.projection.forward(this.center),s=this.playingField,i=s.x+s.width/2,s=s.y+s.height/2;return{x:i-e*(o[0]-t.x),y:s+e*(o[1]-t.y)}}pixelsToLonLat(t){return this.projectedUnitsToLonLat(this.pixelsToProjectedUnits(t))}pixelsToProjectedUnits(t){var{x:t,y:e}=t,o=this.getScale(),s=this.projection.forward(this.center),i=this.playingField,r=i.x+i.width/2,i=i.y+i.height/2;return{x:s[0]+(t-r)/o,y:s[1]-(e-i)/o}}setUpEvents(){const l=this["chart"];let h,p,c;var t=t=>{var e,o,s,i=l.pointer.pinchDown,r=this.projection;let{mouseDownX:a,mouseDownY:n}=l;1===i.length&&(a=i[0].chartX,n=i[0].chartY),"number"==typeof a&&"number"==typeof n&&(i=a+","+n,{chartX:e,chartY:o}=t.originalEvent,i!==p&&(p=i,h=this.projection.forward(this.center),c=(this.projection.options.rotation||[0,0]).slice()),i=(i=r.def&&r.def.bounds)&&j(i,this.playingField)||-1/0,"Orthographic"===r.options.name&&(this.minZoom||1/0)<1.3*i?(r=440/(this.getScale()*Math.min(l.plotWidth,l.plotHeight)),c&&(i=(a-e)*r-c[0],r=u(-c[1]-(n-o)*r,-80,80),s=this.zoom,this.update({projection:{rotation:[-i,-r]}},!1),this.fitToBounds(void 0,void 0,!1),this.zoom=s,l.redraw(!1))):b(e)&&b(o)&&(i=this.getScale(),r=this.projection.hasCoordinates?1:-1,s=this.projection.inverse([h[0]+(a-e)/i,h[1]-(n-o)/i*r]),isNaN(s[0]+s[1])||this.setView(s,void 0,!0,!1)),t.preventDefault())};d(l,"pan",t),d(l,"touchpan",t),d(l,"selection",t=>{var e,o,s,i;t.resetSelection?this.zoomBy():(s=t.x-l.plotLeft,i=t.y-l.plotTop,{y:e,x:o}=this.pixelsToProjectedUnits({x:s,y:i}),{y:s,x:i}=this.pixelsToProjectedUnits({x:s+t.width,y:i+t.height}),this.fitToBounds({x1:o,y1:e,x2:i,y2:s},void 0,!0,!t.originalEvent.touches&&void 0),/^touch/.test(t.originalEvent.type)||l.showResetZoom(),t.preventDefault())})}render(){this.group||(this.group=this.chart.renderer.g("map-view").attr({zIndex:4}).add())}update(t,e=!0,o){var s=t.projection;let i=s&&p.toString(s)!==p.toString(this.options.projection),r=!1;c(!0,this.userOptions,t),c(!0,this.options,t),"insets"in t&&(this.insets.forEach(t=>t.destroy()),this.insets.length=0,r=!0),(i||"fitToGeometry"in t)&&delete this.fitToGeometryCache,(i||r)&&(this.chart.series.forEach(t=>{const e=t.transformGroups;if(t.clearBounds&&t.clearBounds(),t.isDirty=!0,t.isDirtyData=!0,r&&e)for(;1<e.length;){const o=e.pop();o&&o.destroy()}}),i&&(this.projection=new p(this.options.projection)),r&&this.createInsets(),t.center||!Object.hasOwnProperty.call(t,"zoom")||b(t.zoom)||this.fitToBounds(void 0,void 0,!1)),t.center||b(t.zoom)?this.setView(this.options.center,t.zoom,!1):"fitToGeometry"in t&&this.fitToBounds(void 0,void 0,!1),e&&this.chart.redraw(o)}zoomBy(e,o,s,i){var r=this.chart;const a=this.projection.forward(this.center);let[n,l]=o?this.projection.forward(o):[];if("number"==typeof e){var h,o=this.zoom+e;let t;s&&([e,s]=s,h=this.getScale(),e=e-r.plotLeft-r.plotWidth/2,s=s-r.plotTop-r.plotHeight/2,n=a[0]+e/h,l=a[1]+s/h),"number"==typeof n&&"number"==typeof l&&(r=1-Math.pow(2,this.zoom)/Math.pow(2,o),e=a[0]-n,s=a[1]-l,a[0]-=e*r,a[1]+=s*r,t=this.projection.inverse(a)),this.setView(t,o,void 0,i)}else this.fitToBounds(void 0,void 0,void 0,i)}}class w extends C{constructor(t,e){if(super(t.chart,e),this.id=e.id,this.mapView=t,this.options=c({center:[0,0]},t.options.insetOptions,e),this.allBounds=[],this.options.geoBounds){const o=t.projection.path(this.options.geoBounds);this.geoBoundsProjectedBox=a(o),this.geoBoundsProjectedPolygon=o.map(t=>[t[1]||0,t[2]||0])}}getField(t=!0){var e=this.hitZone;if(e){const o=t?this.padding:[0,0,0,0],s=e.coordinates[0],i=s.map(t=>t[0]),r=s.map(t=>t[1]),a=Math.min.apply(0,i)+o[3],n=Math.max.apply(0,i)-o[1],l=Math.min.apply(0,r)+o[0],h=Math.max.apply(0,r)-o[2];if(b(a)&&b(l))return{x:a,y:l,width:n-a,height:h-l}}return super.getField.call(this,t)}getHitZone(){const{chart:e,mapView:o,options:s}=this,i=(s.field||{})["coordinates"];if(i){let t=i[0];if("percent"===s.units){const r="mapBoundingBox"===s.relativeTo&&o.getMapBBox()||c(e.plotBox,{x:0,y:0});t=t.map(t=>[y(t[0]+"%",r.width,r.x),y(t[1]+"%",r.height,r.y)])}return{type:"Polygon",coordinates:[t]}}}getProjectedBounds(){return C.compositeBounds(this.allBounds)}isInside(t){var{geoBoundsProjectedBox:e,geoBoundsProjectedPolygon:o}=this;return Boolean(e&&t.x>=e.x1&&t.x<=e.x2&&t.y>=e.y1&&t.y<=e.y2&&o&&l(t,o))}render(){const{chart:r,mapView:e,options:a}=this,o=a.borderPath||a.field;if(o&&e.group){let t=!0;this.border||(this.border=r.renderer.path().addClass("highcharts-mapview-inset-border").add(e.group),t=!1),r.styledMode||this.border.attr({stroke:a.borderColor,"stroke-width":a.borderWidth});const n=Math.round(this.border.strokeWidth())%2/2,l="mapBoundingBox"===a.relativeTo&&e.getMapBBox()||e.playingField;var s=(o.coordinates||[]).reduce((t,e)=>e.reduce((t,e,o)=>{let[s,i]=e;return"percent"===a.units&&(s=r.plotLeft+y(s+"%",l.width,l.x),i=r.plotTop+y(i+"%",l.height,l.y)),s=Math.floor(s)+n,i=Math.floor(i)+n,t.push(0===o?["M",s,i]:["L",s,i]),t},t),[]);this.border[t?"animate":"attr"]({d:s})}}destroy(){this.border&&(this.border=this.border.destroy()),this.eventsToUnbind.forEach(t=>t())}setUpEvents(){}}return C}),e(t,"Series/Map/MapSeries.js",[t["Core/Animation/AnimationUtilities.js"],t["Series/ColorMapComposition.js"],t["Series/CenteredUtilities.js"],t["Core/Globals.js"],t["Core/Chart/MapChart.js"],t["Series/Map/MapPoint.js"],t["Series/Map/MapSeriesDefaults.js"],t["Maps/MapView.js"],t["Core/Series/SeriesRegistry.js"],t["Core/Utilities.js"]],function(t,e,o,x,s,v,i,n,r,a){const{animObject:b,stop:y}=t;t=x.noop;const l=s["splitPath"],{column:h,scatter:p}=r.seriesTypes,{extend:c,find:d,fireEvent:u,getNestedProperty:M,isArray:j,defined:m,isNumber:C,isObject:w,merge:P,objectEach:S,pick:L,splat:g}=a;class f extends p{constructor(){super(...arguments),this.chart=void 0,this.data=void 0,this.group=void 0,this.joinBy=void 0,this.options=void 0,this.points=void 0,this.processedData=[]}animate(t){const{chart:e,group:o}=this,s=b(this.options.animation);t?o.attr({translateX:e.plotLeft+e.plotWidth/2,translateY:e.plotTop+e.plotHeight/2,scaleX:.001,scaleY:.001}):o.animate({translateX:e.plotLeft,translateY:e.plotTop,scaleX:1,scaleY:1},s)}clearBounds(){this.points.forEach(t=>{delete t.bounds,delete t.insetIndex,delete t.projectedPath}),delete this.bounds}doFullTranslate(){return Boolean(this.isDirtyData||this.chart.isResizing||!this.hasRendered)}drawMapDataLabels(){super.drawDataLabels(),this.dataLabelsGroup&&this.dataLabelsGroup.clip(this.chart.clipRect)}drawPoints(){const u=this,{chart:m,group:o,transformGroups:s=[]}=this,{mapView:g,renderer:f}=m;if(g){(this.transformGroups=s)[0]||(s[0]=f.g().add(o));for(let t=0,e=g.insets.length;t<e;++t)s[t+1]||s.push(f.g().add(o));this.doFullTranslate()&&(this.points.forEach(t=>{const e=t["graphic"];t.group=s["number"==typeof t.insetIndex?t.insetIndex+1:0],e&&e.parentGroup!==t.group&&e.add(t.group)}),h.prototype.drawPoints.apply(this),this.points.forEach(e=>{const a=e.graphic;if(a){const n=a.animate;let t="";e.name&&(t+="highcharts-name-"+e.name.replace(/ /g,"-").toLowerCase()),e.properties&&e.properties["hc-key"]&&(t+=" highcharts-key-"+e.properties["hc-key"].toString().toLowerCase()),t&&a.addClass(t),m.styledMode&&a.css(this.pointAttribs(e,e.selected?"select":void 0)),a.animate=function(t,e,o){var s,i=C(t["stroke-width"])&&!C(a["stroke-width"]),r=C(a["stroke-width"])&&!C(t["stroke-width"]),i=((i||r)&&(s=L(u.getStrokeWidth(u.options),1)/(m.mapView&&m.mapView.getScale()||1),i&&(a["stroke-width"]=s),r&&(t["stroke-width"]=s)),n.call(a,t,e,r?function(){a.element.removeAttribute("stroke-width"),delete a["stroke-width"],o&&o.apply(this,arguments)}:o));return i}}})),s.forEach((s,t)=>{const e=0===t?g:g.insets[t-1],i=e.getSVGTransform(),r=L(this.getStrokeWidth(this.options),1),a=i.scaleX,n=0<i.scaleY?1:-1,l=s=>{(u.points||[]).forEach(t=>{const e=t.graphic;let o;e&&e["stroke-width"]&&(o=this.getStrokeWidth(t.options))&&e.attr({"stroke-width":o/s})})};if(f.globalAnimation&&m.hasRendered&&g.allowTransformAnimation){const h=Number(s.attr("translateX")),p=Number(s.attr("translateY")),c=Number(s.attr("scaleX")),o=P(b(f.globalAnimation)),d=o.step;o.step=function(){d&&d.apply(this,arguments),((t,e)=>{var o=c+(a-c)*e.pos;s.attr({translateX:h+(i.translateX-h)*e.pos,translateY:p+(i.translateY-p)*e.pos,scaleX:o,scaleY:o*n,"stroke-width":r/o}),l(o)}).apply(this,arguments)},s.attr({animator:0}).animate({animator:1},o,function(){"boolean"!=typeof f.globalAnimation&&f.globalAnimation.complete&&f.globalAnimation.complete({applyDrilldown:!0})})}else y(s),s.attr(P(i,{"stroke-width":r/a})),l(a)}),this.isDrilling||this.drawMapDataLabels()}}getProjectedBounds(){if(!this.bounds&&this.chart.mapView){const{insets:r,projection:a}=this.chart.mapView,t=[];(this.points||[]).forEach(e=>{if(e.path||e.geometry){if("string"==typeof e.path?e.path=l(e.path):j(e.path)&&"M"===e.path[0]&&(e.path=this.chart.renderer.pathToSegments(e.path)),!e.bounds){let t=e.getProjectedBounds(a);if(t){e.labelrank=L(e.labelrank,(t.x2-t.x1)*(t.y2-t.y1));const{midX:o,midY:s}=t;if(r&&C(o)&&C(s)){const i=d(r,t=>t.isInside({x:o,y:s}));i&&(delete e.projectedPath,(t=e.getProjectedBounds(i.projection))&&i.allBounds.push(t),e.insetIndex=r.indexOf(i))}e.bounds=t}}e.bounds&&void 0===e.insetIndex&&t.push(e.bounds)}}),this.bounds=n.compositeBounds(t)}return this.bounds}getStrokeWidth(t){var e=this.pointAttrToOptions;return t[e&&e["stroke-width"]||"borderWidth"]}hasData(){return!!this.processedXData.length}pointAttribs(t,e){const{mapView:o,styledMode:s}=t.series.chart,i=s?this.colorAttribs(t):h.prototype.pointAttribs.call(this,t,e);let r=this.getStrokeWidth(t.options);e&&(e=P(this.options.states&&this.options.states[e],t.options.states&&t.options.states[e]||{}),a=this.getStrokeWidth(e),m(a)&&(r=a),i.stroke=e.borderColor??t.color),r&&o&&(r/=o.getScale());var a=this.getStrokeWidth(this.options);return i.dashstyle&&o&&C(a)&&(r=a/o.getScale()),t.visible||(i.fill=this.options.nullColor),m(r)?i["stroke-width"]=r:delete i["stroke-width"],i["stroke-linecap"]=i["stroke-linejoin"]=this.options.linecap,i}updateData(){return!this.processedData&&super.updateData.apply(this,arguments)}setData(t,e=!0,o,s){delete this.bounds,super.setData(t,!1,void 0,s),this.processData(),this.generatePoints(),e&&this.chart.redraw(o)}processData(){const s=this.options,e=s.data,t=this.chart,o=t.options.chart,i=this.joinBy,r=s.keys||this.pointArrayMap,a=[],n={},l=this.chart.mapView,h=l&&(w(s.mapData,!0)?l.getGeoMap(s.mapData):l.geoMap),p=t.mapTransforms=o.mapTransforms||h&&h["hc-transform"]||t.mapTransforms;let c,d;p&&S(p,t=>{t.rotation&&(t.cosAngle=Math.cos(t.rotation),t.sinAngle=Math.sin(t.rotation))});let u;j(s.mapData)?u=s.mapData:h&&"FeatureCollection"===h.type&&(this.mapTitle=h.title,u=x.geojson(h,this.type,this)),this.processedData=[];const m=this.processedData;var g;if(e)for(let o=0,t=e.length;o<t;++o){if(g=e[o],C(g))m[o]={value:g};else if(j(g)){let e=0;m[o]={},!s.keys&&g.length>r.length&&"string"==typeof g[0]&&(m[o]["hc-key"]=g[0],++e);for(let t=0;t<r.length;++t,++e)r[t]&&void 0!==g[e]&&(0<r[t].indexOf(".")?v.prototype.setNestedProperty(m[o],g[e],r[t]):m[o][r[t]]=g[e])}else m[o]=e[o];i&&"_i"===i[0]&&(m[o]._i=o)}if(u){this.mapData=u,this.mapMap={};for(let t=0;t<u.length;t++)d=(c=u[t]).properties,c._i=t,i[0]&&d&&d[i[0]]&&(c[i[0]]=d[i[0]]),n[c[i[0]]]=c;if(this.mapMap=n,i[1]){const f=i[1];m.forEach(t=>{t=M(f,t);n[t]&&a.push(n[t])})}if(s.allAreas){if(i[1]){const y=i[1];m.forEach(t=>{a.push(M(y,t))})}const b="|"+a.map(function(t){return t&&t[i[0]]}).join("|")+"|";u.forEach(t=>{i[0]&&-1!==b.indexOf("|"+t[i[0]]+"|")||m.push(P(t,{value:null}))})}}this.processedXData=new Array(m.length)}setOptions(t){t=super.setOptions(t);let e=t.joinBy;return null===t.joinBy&&(e="_i"),(e=this.joinBy=g(e))[1]||(e[1]=e[0]),t}translate(){const o=this.doFullTranslate(),s=this.chart.mapView,i=s&&s.projection;if(!this.chart.hasRendered||!this.isDirtyData&&this.hasRendered||(this.processData(),this.generatePoints(),delete this.bounds,!s||s.userOptions.center||C(s.userOptions.zoom)||s.zoom!==s.minZoom?this.getProjectedBounds():s.fitToBounds(void 0,void 0,!1)),s){const r=s.getSVGTransform();this.points.forEach(t=>{var e=C(t.insetIndex)&&s.insets[t.insetIndex].getSVGTransform()||r;e&&t.bounds&&C(t.bounds.midX)&&C(t.bounds.midY)&&(t.plotX=t.bounds.midX*e.scaleX+e.translateX,t.plotY=t.bounds.midY*e.scaleY+e.translateY),o&&(t.shapeType="path",t.shapeArgs={d:v.getProjectedPath(t,i)}),t.projectedPath&&!t.projectedPath.length?t.setVisible(!1):t.visible||t.setVisible(!0)})}u(this,"afterTranslate")}}return f.defaultOptions=P(p.defaultOptions,i),c(f.prototype,{type:"map",axisTypes:e.seriesMembers.axisTypes,colorAttribs:e.seriesMembers.colorAttribs,colorKey:e.seriesMembers.colorKey,directTouch:!0,drawDataLabels:t,drawGraph:t,forceDL:!0,getCenter:o.getCenter,getExtremesFromAll:!0,getSymbol:t,isCartesian:!1,parallelArrays:e.seriesMembers.parallelArrays,pointArrayMap:e.seriesMembers.pointArrayMap,pointClass:v,preserveAspectRatio:!0,searchPoint:t,trackerGroups:e.seriesMembers.trackerGroups,useMapGeometry:!0}),e.compose(f),r.registerSeriesType("map",f),f}),e(t,"Series/MapLine/MapLineSeriesDefaults.js",[],function(){return{lineWidth:1,fillColor:"none",legendSymbol:"lineMarker"}}),e(t,"Series/MapLine/MapLineSeries.js",[t["Series/MapLine/MapLineSeriesDefaults.js"],t["Series/Map/MapSeries.js"],t["Core/Series/SeriesRegistry.js"],t["Core/Utilities.js"]],function(t,e,o,s){const{extend:i,merge:r}=s;class a extends e{constructor(){super(...arguments),this.data=void 0,this.options=void 0,this.points=void 0}pointAttribs(t,e){const o=super.pointAttribs(t,e);return o.fill=this.options.fillColor,o}}return a.defaultOptions=r(e.defaultOptions,t),i(a.prototype,{type:"mapline",colorProp:"stroke",pointAttrToOptions:{stroke:"color","stroke-width":"lineWidth"}}),o.registerSeriesType("mapline",a),a}),e(t,"Series/MapPoint/MapPointPoint.js",[t["Core/Series/SeriesRegistry.js"],t["Core/Utilities.js"]],function(t,e){t=t.seriesTypes.scatter;const o=e["isNumber"];class s extends t.prototype.pointClass{constructor(){super(...arguments),this.options=void 0,this.series=void 0}isValid(){return Boolean(this.options.geometry||o(this.x)&&o(this.y)||o(this.options.lon)&&o(this.options.lat))}}return s}),e(t,"Series/MapPoint/MapPointSeriesDefaults.js",[],function(){return{dataLabels:{crop:!1,defer:!1,enabled:!0,formatter:function(){return this.point.name},overflow:!1,style:{color:"#000000"}},legendSymbol:"lineMarker"}}),e(t,"Series/MapPoint/MapPointSeries.js",[t["Core/Globals.js"],t["Series/MapPoint/MapPointPoint.js"],t["Series/MapPoint/MapPointSeriesDefaults.js"],t["Core/Series/SeriesRegistry.js"],t["Core/Renderer/SVG/SVGRenderer.js"],t["Core/Utilities.js"]],function(t,e,o,s,i,r){t=t.noop;const{map:a,scatter:n}=s.seriesTypes,{extend:l,fireEvent:h,isNumber:p,merge:c}=r;class d extends n{constructor(){super(...arguments),this.chart=void 0,this.data=void 0,this.options=void 0,this.points=void 0,this.clearBounds=a.prototype.clearBounds}drawDataLabels(){super.drawDataLabels(),this.dataLabelsGroup&&this.dataLabelsGroup.clip(this.chart.clipRect)}projectPoint(e){const o=this.chart.mapView;if(o){var{geometry:e,lon:s,lat:i}=e;let t=e&&"Point"===e.type&&e.coordinates;if(t=p(s)&&p(i)?[s,i]:t)return o.lonLatToProjectedUnits({lon:t[0],lat:t[1]})}}translate(){const a=this.chart.mapView;if(this.processedXData||this.processData(),this.generatePoints(),this.getProjectedBounds&&this.isDirtyData&&(delete this.bounds,this.getProjectedBounds()),a){const n=a.getSVGTransform(),l=a.projection["hasCoordinates"];this.points.forEach(t=>{let{x:e=void 0,y:o=void 0}=t;var s=p(t.insetIndex)&&a.insets[t.insetIndex].getSVGTransform()||n,i=this.projectPoint(t.options)||t.properties&&this.projectPoint(t.properties);let r;i?(e=i.x,o=i.y):t.bounds&&(e=t.bounds.midX,o=t.bounds.midY,s&&p(e)&&p(o)&&(t.plotX=e*s.scaleX+s.translateX,t.plotY=o*s.scaleY+s.translateY,r=!0)),p(e)&&p(o)?r||(i=a.projectedUnitsToPixels({x:e,y:o}),t.plotX=i.x,t.plotY=l?i.y:this.chart.plotHeight-i.y):t.y=t.plotX=t.plotY=void 0,t.isInside=this.isPointInside(t),t.zone=this.zones.length?t.getZone():void 0})}h(this,"afterTranslate")}}d.defaultOptions=c(n.defaultOptions,o);return i.prototype.symbols.mapmarker=(t,e,o,s,i)=>{var r=i&&"legend"===i.context;let a,n;r?(a=t+o/2,n=e+s):i&&"number"==typeof i.anchorX&&"number"==typeof i.anchorY?(a=i.anchorX,n=i.anchorY):(a=t+o/2,n=e+s/2,e-=s);i=r?s/3:s/2;return[["M",a,n],["C",a,n,a-i,e+1.5*i,a-i,e+i],["A",i,i,1,1,1,a+i,e+i],["C",a+i,e+1.5*i,a,n,a,n],["Z"]]},l(d.prototype,{type:"mappoint",axisTypes:["colorAxis"],forceDL:!0,isCartesian:!1,pointClass:e,searchPoint:t,useMapGeometry:!0}),s.registerSeriesType("mappoint",d),d}),e(t,"Series/Bubble/BubbleLegendDefaults.js",[],function(){return{borderColor:void 0,borderWidth:2,className:void 0,color:void 0,connectorClassName:void 0,connectorColor:void 0,connectorDistance:60,connectorWidth:1,enabled:!1,labels:{className:void 0,allowOverlap:!1,format:"",formatter:void 0,align:"right",style:{fontSize:"0.9em",color:"#000000"},x:0,y:0},maxSize:60,minSize:10,legendIndex:0,ranges:{value:void 0,borderColor:void 0,color:void 0,connectorColor:void 0},sizeBy:"area",sizeByAbsoluteValue:!1,zIndex:1,zThreshold:0}}),e(t,"Series/Bubble/BubbleLegendItem.js",[t["Core/Color/Color.js"],t["Core/Templating.js"],t["Core/Globals.js"],t["Core/Utilities.js"]],function(t,r,e,o){const c=t["parse"],s=e["noop"],{arrayMax:n,arrayMin:l,isNumber:p,merge:d,pick:u,stableSort:m}=o;return class{constructor(t,e){this.chart=void 0,this.legend=void 0,this.maxLabel=void 0,this.movementX=void 0,this.ranges=void 0,this.selected=void 0,this.visible=void 0,this.symbols=void 0,this.options=void 0,this.setState=s,this.init(t,e)}init(t,e){this.options=t,this.visible=!0,this.chart=e.chart,this.legend=e}addToLegend(t){t.splice(this.options.legendIndex,0,this)}drawLegendSymbol(t){this.chart;const e=u(t.options.itemDistance,20),o=this.legendItem||{},s=this.options,i=s.ranges,r=s.connectorDistance;let a;var n,l,h;i&&i.length&&p(i[0].value)?(m(i,function(t,e){return e.value-t.value}),this.ranges=i,this.setOptions(),this.render(),n=this.getMaxLabelSize(),h=2*(l=this.ranges[0].radius),a=0<(a=r-l+n.width)?a:0,this.maxLabel=n,this.movementX="left"===s.labels.align?a:0,o.labelWidth=h+a+e,o.labelHeight=h+n.height/2):t.options.bubbleLegend.autoRanges=!0}setOptions(){const o=this.ranges,s=this.options,i=this.chart.series[s.seriesIndex],r=this.legend.baseline,a={zIndex:s.zIndex,"stroke-width":s.borderWidth},n={zIndex:s.zIndex,"stroke-width":s.connectorWidth},l={align:this.legend.options.rtl||"left"===s.labels.align?"right":"left",zIndex:s.zIndex},h=i.options.marker.fillOpacity,p=this.chart.styledMode;o.forEach(function(t,e){p||(a.stroke=u(t.borderColor,s.borderColor,i.color),a.fill=u(t.color,s.color,1!==h?c(i.color).setOpacity(h).get("rgba"):i.color),n.stroke=u(t.connectorColor,s.connectorColor,i.color)),o[e].radius=this.getRangeRadius(t.value),o[e]=d(o[e],{center:o[0].radius-o[e].radius+r}),p||d(!0,o[e],{bubbleAttribs:d(a),connectorAttribs:d(n),labelAttribs:l})},this)}getRangeRadius(t){const e=this.options,o=this.options.seriesIndex,s=this.chart.series[o],i=e.ranges[0].value,r=e.ranges[e.ranges.length-1].value,a=e.minSize,n=e.maxSize;return s.getRadius.call(this,r,i,a,n,t)}render(){const t=this.legendItem||{},e=this.chart.renderer,o=this.options.zThreshold;this.symbols||(this.symbols={connectors:[],bubbleItems:[],labels:[]}),t.symbol=e.g("bubble-legend"),t.label=e.g("bubble-legend-item").css(this.legend.itemStyle||{}),t.symbol.translateX=0,t.symbol.translateY=0,t.symbol.add(t.label),t.label.add(t.group);for(const s of this.ranges)s.value>=o&&this.renderRange(s);this.hideOverlappingLabels()}renderRange(t){const e=this.ranges[0],o=this.legend,s=this.options,i=s.labels,r=this.chart,a=r.series[s.seriesIndex],n=r.renderer,l=this.symbols,h=l.labels,p=t.center,c=Math.abs(t.radius),d=s.connectorDistance||0,u=i.align,m=o.options.rtl,g=s.borderWidth,f=s.connectorWidth,b=e.radius||0,y=p-c-g/2+f/2,x=(y%1?1:.5)-(f%2?0:.5),v=n.styledMode;let M=m||"left"===u?-d:d;"center"===u&&(M=0,s.connectorDistance=0,t.labelAttribs.align="center"),l.bubbleItems.push(n.circle(b,p+x,c).attr(v?{}:t.bubbleAttribs).addClass((v?"highcharts-color-"+a.colorIndex+" ":"")+"highcharts-bubble-legend-symbol "+(s.className||"")).add(this.legendItem.symbol)),l.connectors.push(n.path(n.crispLine([["M",b,y],["L",b+M,y]],s.connectorWidth)).attr(v?{}:t.connectorAttribs).addClass((v?"highcharts-color-"+this.options.seriesIndex+" ":"")+"highcharts-bubble-legend-connectors "+(s.connectorClassName||"")).add(this.legendItem.symbol));const j=n.text(this.formatLabel(t)).attr(v?{}:t.labelAttribs).css(v?{}:i.style).addClass("highcharts-bubble-legend-labels "+(s.labels.className||"")).add(this.legendItem.symbol);t={x:b+M+s.labels.x,y:y+s.labels.y+.4*j.getBBox().height};j.attr(t),h.push(j),j.placed=!0,j.alignAttr=t}getMaxLabelSize(){const t=this.symbols.labels;let e,o;return t.forEach(function(t){o=t.getBBox(!0),e=!e||o.width>e.width?o:e}),e||{}}formatLabel(t){const e=this.options,o=e.labels.formatter,s=e.labels.format,i=this.chart["numberFormatter"];return s?r.format(s,t):o?o.call(t):i(t.value,1)}hideOverlappingLabels(){const t=this.chart,e=this.options.labels.allowOverlap,o=this.symbols;!e&&o&&(t.hideOverlappingLabels(o.labels),o.labels.forEach(function(t,e){t.newOpacity?t.newOpacity!==t.oldOpacity&&o.connectors[e].show():o.connectors[e].hide()}))}getRanges(){const t=this.legend.bubbleLegend,e=t.chart.series,o=t.options.ranges;let s,i,r=Number.MAX_VALUE,a=-Number.MAX_VALUE;return e.forEach(function(t){t.isBubble&&!t.ignoreSeries&&(i=t.zData.filter(p)).length&&(r=u(t.options.zMin,Math.min(r,Math.max(l(i),!1===t.options.displayNegative?t.options.zThreshold:-Number.MAX_VALUE))),a=u(t.options.zMax,Math.max(a,n(i))))}),s=r===a?[{value:a}]:[{value:r},{value:(r+a)/2},{value:a,autoRanges:!0}],o.length&&o[0].radius&&s.reverse(),s.forEach(function(t,e){o&&o[e]&&(s[e]=d(o[e],t))}),s}predictBubbleSizes(){const t=this.chart,e=t.legend.options,o=e.floating,s="horizontal"===e.layout,i=s?t.legend.lastLineHeight:0,r=t.plotSizeX,a=t.plotSizeY,n=t.series[this.options.seriesIndex],l=n.getPxExtremes(),h=Math.ceil(l.minPxSize),p=Math.ceil(l.maxPxSize),c=Math.min(a,r);let d,u=n.options.maxSize;return o||!/%$/.test(u)?d=p:(u=parseFloat(u),d=(c+i)*u/100/(u/100+1),(s&&a-d>=r||!s&&r-d>=a)&&(d=p)),[h,Math.ceil(d)]}updateRanges(t,e){const o=this.legend.options.bubbleLegend;o.minSize=t,o.maxSize=e,o.ranges=this.getRanges()}correctSizes(){const t=this.legend,e=this.chart,o=e.series[this.options.seriesIndex],s=o.getPxExtremes(),i=s.maxPxSize,r=this.options.maxSize;1<Math.abs(Math.ceil(i)-r)&&(this.updateRanges(this.options.minSize,s.maxPxSize),t.render())}}}),e(t,"Series/Bubble/BubbleLegendComposition.js",[t["Series/Bubble/BubbleLegendDefaults.js"],t["Series/Bubble/BubbleLegendItem.js"],t["Core/Defaults.js"],t["Core/Utilities.js"]],function(s,a,t,i){const r=t["setOptions"],{addEvent:n,objectEach:h,wrap:l}=i,p=[];function c(t,e,o){const s=this,i=s.legend,r=0<=d(s);let a,n,l;i&&i.options.enabled&&i.bubbleLegend&&i.options.bubbleLegend.autoRanges&&r?(a=i.bubbleLegend.options,n=i.bubbleLegend.predictBubbleSizes(),i.bubbleLegend.updateRanges(n[0],n[1]),a.placed||(i.group.placed=!1,i.allItems.forEach(t=>{(l=t.legendItem||{}).group&&(l.group.translateY=void 0)})),i.render(),s.getMargins(),s.axes.forEach(function(t){t.visible&&t.render(),a.placed||(t.setScale(),t.updateNames(),h(t.ticks,function(t){t.isNew=!0,t.isNewLabel=!0}))}),a.placed=!0,s.getMargins(),t.call(s,e,o),i.bubbleLegend.correctSizes(),f(i,u(i))):(t.call(s,e,o),i&&i.options.enabled&&i.bubbleLegend&&(i.render(),f(i,u(i))))}function d(t){var e=t.series;let o=0;for(;o<e.length;){if(e[o]&&e[o].isBubble&&e[o].visible&&e[o].zData.length)return o;o++}return-1}function u(t){const e=t.allItems,o=[],s=e.length;let i,r,a,n=0,l=0;for(n=0;n<s;n++)if(r=e[n].legendItem||{},a=(e[n+1]||{}).legendItem||{},r.labelHeight&&(e[n].itemHeight=r.labelHeight),e[n]===e[s-1]||r.y!==a.y){for(o.push({height:0}),i=o[o.length-1],l;l<=n;l++)e[l].itemHeight>i.height&&(i.height=e[l].itemHeight);i.step=n}return o}function m(t){const e=this,o=e.bubbleLegend,s=e.options,i=s.bubbleLegend,r=d(e.chart);o&&o.ranges&&o.ranges.length&&(i.ranges.length&&(i.autoRanges=!!i.ranges[0].autoRanges),e.destroyItem(o)),0<=r&&s.enabled&&i.enabled&&(i.seriesIndex=r,e.bubbleLegend=new a(i,e),e.bubbleLegend.addToLegend(t.allItems))}function g(t){if(t.defaultPrevented)return!1;const e=this,o=e.chart,s=e.visible,i=e.chart.legend;i&&i.bubbleLegend&&(e.visible=!s,e.ignoreSeries=s,t=0<=d(o),i.bubbleLegend.visible!==t&&(i.update({bubbleLegend:{enabled:t}}),i.bubbleLegend.visible=t),e.visible=s)}function f(t,o){const e=t.allItems,s=t.options.rtl;let i,r,a,n,l=0;e.forEach((t,e)=>{(n=t.legendItem||{}).group&&(i=n.group.translateX||0,r=n.y||0,((a=t.movementX)||s&&t.ranges)&&(a=s?i-t.options.maxSize/2:i+a,n.group.attr({translateX:a})),e>o[l].step&&l++,n.group.attr({translateY:Math.round(r+o[l].height/2)}),n.y=r+o[l].height/2)})}return{compose:function(t,e,o){i.pushUnique(p,t)&&(r({legend:{bubbleLegend:s}}),l(t.prototype,"drawChartBox",c)),i.pushUnique(p,e)&&n(e,"afterGetAllItems",m),i.pushUnique(p,o)&&n(o,"legendItemClick",g)}}}),e(t,"Series/Bubble/BubblePoint.js",[t["Core/Series/Point.js"],t["Core/Series/SeriesRegistry.js"],t["Core/Utilities.js"]],function(e,t,o){var{prototype:{pointClass:t}}=t["seriesTypes"]["scatter"];const s=o["extend"];class i extends t{constructor(){super(...arguments),this.options=void 0,this.series=void 0}haloPath(t){return e.prototype.haloPath.call(this,0===t?0:(this.marker&&this.marker.radius||0)+t)}}return s(i.prototype,{ttBelow:!1}),i}),e(t,"Series/Bubble/BubbleSeries.js",[t["Series/Bubble/BubbleLegendComposition.js"],t["Series/Bubble/BubblePoint.js"],t["Core/Color/Color.js"],t["Core/Globals.js"],t["Core/Series/SeriesRegistry.js"],t["Core/Utilities.js"]],function(i,t,e,o,s,r){const a=e["parse"];e=o.noop;const{series:n,seriesTypes:{column:{prototype:l},scatter:h}}=s,{addEvent:p,arrayMax:c,arrayMin:d,clamp:u,extend:m,isNumber:g,merge:f,pick:b}=r,y=[];function x(){const t=this.len,i=(this.chart,this.isXAxis),r=i?"xData":"yData",a=this.min,n=this.max-a;let l=0,h=t,p=t/n,c;this.series.forEach(e=>{if(e.bubblePadding&&e.reserveSpace()){this.allowZoomOutside=!0,c=!0;var o,s=e[r];if(i&&((e.onPoint||e).getRadii(0,0,e),e.onPoint&&(e.radii=e.onPoint.radii)),0<n){let t=s.length;for(;t--;)g(s[t])&&this.dataMin<=s[t]&&s[t]<=this.max&&(o=e.radii&&e.radii[t]||0,l=Math.min((s[t]-a)*p-o,l),h=Math.max((s[t]-a)*p+o,h))}}}),c&&0<n&&!this.logarithmic&&(h-=t,p*=(t+Math.max(0,l)-Math.min(h,t))/t,[["min","userMin",l],["max","userMax",h]].forEach(t=>{void 0===b(this.options[t[0]],this[t[1]])&&(this[t[0]]+=t[2]/p)}))}class v extends h{constructor(){super(...arguments),this.data=void 0,this.maxPxSize=void 0,this.minPxSize=void 0,this.options=void 0,this.points=void 0,this.radii=void 0,this.yData=void 0,this.zData=void 0}static compose(t,e,o,s){i.compose(e,o,s),r.pushUnique(y,t)&&(t.prototype.beforePadding=x)}animate(t){!t&&this.points.length<this.options.animationLimit&&this.points.forEach(function(t){const e=t["graphic"];e&&e.width&&(this.hasRendered||e.attr({x:t.plotX,y:t.plotY,width:1,height:1}),e.animate(this.markerAttribs(t),this.options.animation))},this)}getRadii(){const t=this.zData,e=this.yData,o=[];let s,i,r,a=this.chart.bubbleZExtremes;var{minPxSize:n,maxPxSize:l}=this.getPxExtremes();if(!a){let e=Number.MAX_VALUE,o=-Number.MAX_VALUE,s;this.chart.series.forEach(t=>{t.bubblePadding&&t.reserveSpace()&&((t=(t.onPoint||t).getZExtremes())&&(e=Math.min(b(e,t.zMin),t.zMin),o=Math.max(b(o,t.zMax),t.zMax),s=!0))}),s?(a={zMin:e,zMax:o},this.chart.bubbleZExtremes=a):a={zMin:0,zMax:0}}for(i=0,s=t.length;i<s;i++)r=t[i],o.push(this.getRadius(a.zMin,a.zMax,n,l,r,e&&e[i]));this.radii=o}getRadius(t,e,o,s,i,r){var a=this.options,n="width"!==a.sizeBy,l=a.zThreshold;let h=e-t,p=.5;if(null===r||null===i)return null;if(g(i)){if(a.sizeByAbsoluteValue&&(i=Math.abs(i-l),e=h=Math.max(e-l,Math.abs(t-l)),t=0),i<t)return o/2-1;0<h&&(p=(i-t)/h)}return n&&0<=p&&(p=Math.sqrt(p)),Math.ceil(o+p*(s-o))/2}hasData(){return!!this.processedXData.length}pointAttribs(t,e){const o=this.options.marker,s=o.fillOpacity,i=n.prototype.pointAttribs.call(this,t,e);return 1!==s&&(i.fill=a(i.fill).setOpacity(s).get("rgba")),i}translate(){super.translate.call(this),this.getRadii(),this.translateBubble()}translateBubble(){var{data:t,options:e,radii:o}=this,s=this.getPxExtremes()["minPxSize"];let i=t.length;for(;i--;){const a=t[i];var r=o?o[i]:0;"z"===this.zoneAxis&&(a.negative=(a.z||0)<(e.zThreshold||0)),g(r)&&s/2<=r?(a.marker=m(a.marker,{radius:r,width:2*r,height:2*r}),a.dlBox={x:a.plotX-r,y:a.plotY-r,width:2*r,height:2*r}):(a.shapeArgs=a.plotY=a.dlBox=void 0,a.isInside=!1)}}getPxExtremes(){const o=Math.min(this.chart.plotWidth,this.chart.plotHeight);var t=t=>{let e;return"string"==typeof t&&(e=/%$/.test(t),t=parseInt(t,10)),e?o*t/100:t},e=t(b(this.options.minSize,8));return{minPxSize:e,maxPxSize:Math.max(t(b(this.options.maxSize,"20%")),e)}}getZExtremes(){var t=this.options,e=(this.zData||[]).filter(g);if(e.length){var o=b(t.zMin,u(d(e),!1===t.displayNegative?t.zThreshold||0:-Number.MAX_VALUE,Number.MAX_VALUE)),t=b(t.zMax,c(e));if(g(o)&&g(t))return{zMin:o,zMax:t}}}}return v.defaultOptions=f(h.defaultOptions,{dataLabels:{formatter:function(){const t=this.series.chart["numberFormatter"];var e=this.point["z"];return g(e)?t(e,-1):""},inside:!0,verticalAlign:"middle"},animationLimit:250,marker:{lineColor:null,lineWidth:1,fillOpacity:.5,radius:null,states:{hover:{radiusPlus:0}},symbol:"circle"},minSize:8,maxSize:"20%",softThreshold:!1,states:{hover:{halo:{size:5}}},tooltip:{pointFormat:"({point.x}, {point.y}), Size: {point.z}"},turboThreshold:0,zThreshold:0,zoneAxis:"z"}),m(v.prototype,{alignDataLabel:l.alignDataLabel,applyZones:e,bubblePadding:!0,isBubble:!0,pointArrayMap:["y","z"],pointClass:t,parallelArrays:["x","y","z"],trackerGroups:["group","dataLabelsGroup"],specialGroup:"group",zoneAxis:"z"}),p(v,"updatedData",t=>{delete t.target.chart.bubbleZExtremes}),p(v,"remove",t=>{delete t.target.chart.bubbleZExtremes}),s.registerSeriesType("bubble",v),v}),e(t,"Series/MapBubble/MapBubblePoint.js",[t["Series/Bubble/BubblePoint.js"],t["Core/Series/SeriesRegistry.js"],t["Core/Utilities.js"]],function(t,e,o){var{prototype:{pointClass:{prototype:e}}}=e["seriesTypes"]["map"];const s=o["extend"];class i extends t{isValid(){return"number"==typeof this.z}}return s(i.prototype,{applyOptions:e.applyOptions,getProjectedBounds:e.getProjectedBounds}),i}),e(t,"Series/MapBubble/MapBubbleSeries.js",[t["Series/Bubble/BubbleSeries.js"],t["Series/MapBubble/MapBubblePoint.js"],t["Core/Series/SeriesRegistry.js"],t["Core/Utilities.js"]],function(t,e,o,s){const{map:{prototype:i},mappoint:{prototype:r}}=o["seriesTypes"],{extend:a,merge:n}=s;class l extends t{constructor(){super(...arguments),this.data=void 0,this.options=void 0,this.points=void 0,this.clearBounds=i.clearBounds}searchPoint(t,e){return this.searchKDTree({clientX:t.chartX-this.chart.plotLeft,plotY:t.chartY-this.chart.plotTop},e,t)}translate(){r.translate.call(this),this.getRadii(),this.translateBubble()}updateParallelArrays(t,e,o){super.updateParallelArrays.call(this,t,e,o);let s=this.processedXData,i=this.xData;s&&i&&(s.length=i.length)}}return l.defaultOptions=n(t.defaultOptions,{lineWidth:0,animationLimit:500,joinBy:"hc-key",tooltip:{pointFormat:"{point.name}: {point.z}"}}),a(l.prototype,{type:"mapbubble",axisTypes:["colorAxis"],getProjectedBounds:i.getProjectedBounds,isCartesian:!1,pointArrayMap:["z"],pointClass:e,processData:i.processData,projectPoint:r.projectPoint,setData:i.setData,setOptions:i.setOptions,updateData:i.updateData,useMapGeometry:!0,xyFromShape:!0}),o.registerSeriesType("mapbubble",l),l}),e(t,"Series/Heatmap/HeatmapPoint.js",[t["Core/Series/SeriesRegistry.js"],t["Core/Utilities.js"]],function(t,e){var{pointClass:t}=t.seriesTypes["scatter"]["prototype"];const{clamp:b,defined:y,extend:o,pick:x}=e;class s extends t{constructor(){super(...arguments),this.options=void 0,this.series=void 0,this.value=void 0,this.x=void 0,this.y=void 0}applyOptions(t,e){return!this.isNull&&null!==this.value||delete this.color,super.applyOptions(t,e),this.formatPrefix=this.isNull||null===this.value?"null":"point",this}getCellAttributes(){const t=this,e=t.series,o=e.options,s=(o.colsize||1)/2,i=(o.rowsize||1)/2,r=e.xAxis,a=e.yAxis,n=t.options.marker||e.options.marker,l=e.pointPlacementToXValue(),h=x(t.pointPadding,o.pointPadding,0),p={x1:b(Math.round(r.len-r.translate(t.x-s,!1,!0,!1,!0,-l)),-r.len,2*r.len),x2:b(Math.round(r.len-r.translate(t.x+s,!1,!0,!1,!0,-l)),-r.len,2*r.len),y1:b(Math.round(a.translate(t.y-i,!1,!0,!1,!0)),-a.len,2*a.len),y2:b(Math.round(a.translate(t.y+i,!1,!0,!1,!0)),-a.len,2*a.len)};for(const f of[["width","x"],["height","y"]]){var c=f[0],d=f[1];let t=d+"1",e=d+"2";var u=Math.abs(p[t]-p[e]),m=n&&n.lineWidth||0,g=Math.abs(p[t]+p[e])/2,c=n&&n[c];y(c)&&c<u&&(u=c/2+m/2,p[t]=g-u,p[e]=g+u),h&&(("x"===d&&r.reversed||"y"===d&&!a.reversed)&&(t=e,e=d+"1"),p[t]+=h,p[e]-=h)}return p}haloPath(t){if(!t)return[];var{x:e=0,y:o=0,width:s=0,height:i=0}=this.shapeArgs||{};return[["M",e-t,o-t],["L",e-t,o+i+t],["L",e+s+t,o+i+t],["L",e+s+t,o-t],["Z"]]}isValid(){return this.value!==1/0&&this.value!==-1/0}}return o(s.prototype,{dataLabelOnNull:!0,moveToTopOnHover:!0,ttBelow:!1}),s}),e(t,"Series/Heatmap/HeatmapSeriesDefaults.js",[t["Core/Utilities.js"]],function(t){const o=t["isNumber"];return{animation:!1,borderRadius:0,borderWidth:0,interpolation:!1,nullColor:"#f7f7f7",dataLabels:{formatter:function(){const t=this.series.chart["numberFormatter"];var e=this.point["value"];return o(e)?t(e,-1):""},inside:!0,verticalAlign:"middle",crop:!1,overflow:"allow",padding:0},marker:{symbol:"rect",radius:0,lineColor:void 0,states:{hover:{lineWidthPlus:0},select:{}}},clip:!0,pointRange:null,tooltip:{pointFormat:"{point.x}, {point.y}: {point.value}<br/>"},states:{hover:{halo:!1,brightness:.2}},legendSymbol:"rectangle"}}),e(t,"Series/InterpolationUtilities.js",[t["Core/Globals.js"],t["Core/Utilities.js"]],function(t,e){const s=t["doc"],{defined:i,pick:r}=e;return{colorFromPoint:function(t,e){const o=e.series.colorAxis;if(o){const s=o.toColor(t||0,e).split(")")[0].split("(")[1].split(",").map(t=>r(parseFloat(t),parseInt(t,10)));return s[3]=255*r(s[3],1),i(t)&&e.visible||(s[3]=0),s}return[0,0,0,0]},getContext:function(t){const{canvas:e,context:o}=t;return e&&o?(o.clearRect(0,0,e.width,e.height),o):(t.canvas=s.createElement("canvas"),t.context=t.canvas.getContext("2d",{willReadFrequently:!0})||void 0,t.context)}}}),e(t,"Series/Heatmap/HeatmapSeries.js",[t["Core/Color/Color.js"],t["Series/ColorMapComposition.js"],t["Series/Heatmap/HeatmapPoint.js"],t["Series/Heatmap/HeatmapSeriesDefaults.js"],t["Core/Series/SeriesRegistry.js"],t["Core/Renderer/SVG/SVGRenderer.js"],t["Core/Utilities.js"],t["Series/InterpolationUtilities.js"]],function(h,t,e,o,s,i,r,a){const{series:N,seriesTypes:{column:n,scatter:l}}=s,{symbols:c}=i["prototype"],{addEvent:p,extend:d,fireEvent:u,isNumber:m,merge:g,pick:f}=r,{colorFromPoint:G,getContext:X}=a;class b extends l{constructor(){super(...arguments),this.canvas=void 0,this.colorAxis=void 0,this.context=void 0,this.data=void 0,this.options=void 0,this.points=void 0,this.valueMax=NaN,this.valueMin=NaN,this.isDirtyCanvas=!0}drawPoints(){const e=this,t=e.options,o=t.interpolation,O=t.marker||{};if(o){const{image:i,chart:r,xAxis:a,yAxis:n}=e,{reversed:l=!1,len:h}=a,{reversed:p=!1,len:c}=n,d={width:h,height:c};if(!i||e.isDirtyData||e.isDirtyCanvas){const u=X(e),{canvas:m,options:{colsize:g=1,rowsize:f=1},points:b,points:{length:y}}=e,x=y-1,v=r.colorAxis&&r.colorAxis[0];if(m&&u&&v){const{min:M,max:j}=a.getExtremes(),{min:C,max:w}=n.getExtremes(),P=j-M,S=w-C,L=Math.round(P/g/8*8),A=Math.round(S/f/8*8),[T,z]=[[L,L/P,l,"ceil"],[A,A/S,!p,"floor"]].map(([e,o,t,s])=>t?t=>Math[s](e-o*t):t=>Math[s](o*t)),B=m.width=L+1,k=m.height=A+1,D=B*k,I=x/D,E=new Uint8ClampedArray(4*D);e.buildKDTree();for(let t=0;t<D;t++){var s=b[Math.ceil(I*t)],{x:V,y:U}=s;E.set(G(s.value,s),(s=V,4*Math.ceil(B*z(U-C)+T(s-M))))}u.putImageData(new ImageData(E,B),0,0),i?i.attr({...d,href:m.toDataURL("image/png",1)}):(e.directTouch=!1,e.image=r.renderer.image(m.toDataURL("image/png",1)).attr(d).add(e.group))}e.isDirtyCanvas=!1}else i.width===h&&i.height===c||i.attr(d)}else(O.enabled||e._hasPointMarkers)&&(N.prototype.drawPoints.call(e),e.points.forEach(t=>{t.graphic&&(t.graphic[e.chart.styledMode?"css":"animate"](e.colorAttribs(t)),null===t.value&&t.graphic.addClass("highcharts-null-point"))}))}getExtremes(){var{dataMin:t,dataMax:e}=N.prototype.getExtremes.call(this,this.valueData);return m(t)&&(this.valueMin=t),m(e)&&(this.valueMax=e),N.prototype.getExtremes.call(this)}getValidPoints(t,e){return N.prototype.getValidPoints.call(this,t,e,!0)}hasData(){return!!this.processedXData.length}init(){super.init.apply(this,arguments);const t=this.options;t.pointRange=f(t.pointRange,t.colsize||1),this.yAxis.axisPointRange=t.rowsize||1,c.ellipse=c.circle,t.marker&&m(t.borderRadius)&&(t.marker.r=t.borderRadius)}markerAttribs(t,e){var o,s=t.shapeArgs||{};return t.hasImage?{x:t.plotX,y:t.plotY}:e&&"normal"!==e?(t=t.options.marker||{},o=(o=this.options.marker||{}).states&&o.states[e]||{},e=((t=t.states&&t.states[e]||{}).width||o.width||s.width||0)+(t.widthPlus||o.widthPlus||0),t=(t.height||o.height||s.height||0)+(t.heightPlus||o.heightPlus||0),{x:(s.x||0)+((s.width||0)-e)/2,y:(s.y||0)+((s.height||0)-t)/2,width:e,height:t}):s}pointAttribs(t,e){const o=N.prototype.pointAttribs.call(this,t,e),s=this.options||{},i=this.chart.options.plotOptions||{},r=i.series||{},a=i.heatmap||{},n=t&&t.options.borderColor||s.borderColor||a.borderColor||r.borderColor,l=t&&t.options.borderWidth||s.borderWidth||a.borderWidth||r.borderWidth||o["stroke-width"];return o.stroke=t&&t.marker&&t.marker.lineColor||s.marker&&s.marker.lineColor||n||this.color,o["stroke-width"]=l,e&&"normal"!==e&&(t=g(s.states&&s.states[e],s.marker&&s.marker.states&&s.marker.states[e],t&&t.options.states&&t.options.states[e]||{}),o.fill=t.color||h.parse(o.fill).brighten(t.brightness||0).get(),o.stroke=t.lineColor||o.stroke),o}translate(){const t=this.options,{borderRadius:i,marker:e}=t,r=e&&e.symbol||"rect",a=c[r]?r:"rect",n=-1!==["circle","square"].indexOf(a);this.generatePoints();for(const p of this.points){var l,h=p.getCellAttributes();let t=Math.min(h.x1,h.x2),e=Math.min(h.y1,h.y2),o=Math.max(Math.abs(h.x2-h.x1),0),s=Math.max(Math.abs(h.y2-h.y1),0);p.hasImage=0===(p.marker&&p.marker.symbol||r||"").indexOf("url"),n&&(l=Math.abs(o-s),t=Math.min(h.x1,h.x2)+(o<s?0:l/2),e=Math.min(h.y1,h.y2)+(o<s?l/2:0),o=s=Math.min(o,s)),p.hasImage&&(p.marker={width:o,height:s}),p.plotX=p.clientX=(h.x1+h.x2)/2,p.plotY=(h.y1+h.y2)/2,p.shapeType="path",p.shapeArgs=g(!0,{x:t,y:e,width:o,height:s},{d:c[a](t,e,o,s,{r:m(i)?i:0})})}u(this,"afterTranslate")}}return b.defaultOptions=g(l.defaultOptions,o),p(b,"afterDataClassLegendClick",function(){this.isDirtyCanvas=!0,this.drawPoints()}),d(b.prototype,{axisTypes:t.seriesMembers.axisTypes,colorKey:t.seriesMembers.colorKey,directTouch:!0,getExtremesFromAll:!0,parallelArrays:t.seriesMembers.parallelArrays,pointArrayMap:["y","value"],pointClass:e,specialGroup:"group",trackerGroups:t.seriesMembers.trackerGroups,alignDataLabel:n.prototype.alignDataLabel,colorAttribs:t.seriesMembers.colorAttribs,getSymbol:N.prototype.getSymbol}),t.compose(b),s.registerSeriesType("heatmap",b),b}),e(t,"masters/modules/map.src.js",[t["Core/Globals.js"],t["Core/Axis/Color/ColorAxis.js"],t["Maps/MapNavigation.js"],t["Series/MapBubble/MapBubbleSeries.js"],t["Maps/GeoJSONComposition.js"],t["Core/Chart/MapChart.js"],t["Maps/MapView.js"],t["Maps/Projection.js"]],function(t,e,o,s,i,r,a,n){const l=t;l.ColorAxis=e,l.MapChart=r,l.mapChart=l.Map=r.mapChart,l.MapNavigation=o,l.MapView=a,l.maps=r.maps,l.Projection=n,l.geojson=i.geojson,l.topo2geo=i.topo2geo,e.compose(l.Chart,l.Fx,l.Legend,l.Series),i.compose(l.Chart),s.compose(l.Axis,l.Chart,l.Legend,l.Series),o.compose(r,l.Pointer,l.SVGRenderer),a.compose(r)})});