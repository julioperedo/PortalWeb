!function(n){"object"==typeof module&&module.exports?module.exports=n.default=n:"function"==typeof define&&define.amd?define("highcharts/modules/pathfinder",["highcharts"],function(t){return n(t),n.Highcharts=t,n}):n("undefined"!=typeof Highcharts?Highcharts:void 0)}(function(t){"use strict";t=t?t._modules:{};function n(t,n,i,e){t.hasOwnProperty(n)||(t[n]=e.apply(null,i),"function"==typeof CustomEvent&&window.dispatchEvent(new CustomEvent("HighchartsModuleLoaded",{detail:{path:n,module:t[n]}})))}n(t,"Gantt/Connection.js",[t["Core/Globals.js"],t["Core/Utilities.js"]],function(t,n){const{defined:c,error:o,merge:x,objectEach:i}=n,u=t.deg2rad,l=Math.max,d=Math.min;return class{constructor(t,n,i){this.chart=void 0,this.fromPoint=void 0,this.graphics=void 0,this.pathfinder=void 0,this.toPoint=void 0,this.init(t,n,i)}init(t,n,i){this.fromPoint=t,this.toPoint=n,this.options=i,this.chart=t.series.chart,this.pathfinder=this.chart.pathfinder}renderPath(t,n,i){const e=this.chart,r=e.styledMode,o=e.pathfinder,a=!e.options.chart.forExport&&!1!==i,s={};let h=this.graphics&&this.graphics.path;o.group||(o.group=e.renderer.g().addClass("highcharts-pathfinder-group").attr({zIndex:-1}).add(e.seriesGroup)),o.group.translate(e.plotLeft,e.plotTop),h&&h.renderer||(h=e.renderer.path().add(o.group),r||h.attr({opacity:0})),h.attr(n),s.d=t,r||(s.opacity=1),h[a?"animate":"attr"](s,i),this.graphics=this.graphics||{},this.graphics.path=h}addMarker(t,n,i){const e=this,r=e.fromPoint.series.chart,o=r.pathfinder,a=r.renderer,s="start"===t?e.fromPoint:e.toPoint,h=s.getPathfinderAnchorPoint(n);let c,x,l,d,M,p,y,f;n.enabled&&((f="start"===t?i[1]:i[i.length-2])&&"M"===f[0]||"L"===f[0])&&(y={x:f[1],y:f[2]},x=s.getRadiansToVector(y,h),c=s.getMarkerVector(x,n.radius,h),l=-x/u,n.width&&n.height?(M=n.width,p=n.height):M=p=2*n.radius,e.graphics=e.graphics||{},d={x:c.x-M/2,y:c.y-p/2,width:M,height:p,rotation:l,rotationOriginX:c.x,rotationOriginY:c.y},e.graphics[t]?e.graphics[t].animate(d):(e.graphics[t]=a.symbol(n.symbol).addClass("highcharts-point-connecting-path-"+t+"-marker highcharts-color-"+this.fromPoint.colorIndex).attr(d).add(o.group),a.styledMode||e.graphics[t].attr({fill:n.color||e.fromPoint.color,stroke:n.lineColor,"stroke-width":n.lineWidth,opacity:0}).animate({opacity:1},s.series.options.animation)))}getPath(t){const n=this.pathfinder,i=this.chart,e=n.algorithms[t.type];let r=n.chartObstacles;return"function"!=typeof e?(o('"'+t.type+'" is not a Pathfinder algorithm.'),{path:[],obstacles:[]}):(e.requiresObstacles&&!r&&(r=n.chartObstacles=n.getChartObstacles(t),i.options.connectors.algorithmMargin=t.algorithmMargin,n.chartObstacleMetrics=n.getObstacleMetrics(r)),e(this.fromPoint.getPathfinderAnchorPoint(t.startMarker),this.toPoint.getPathfinderAnchorPoint(t.endMarker),x({chartObstacles:r,lineObstacles:n.lineObstacles||[],obstacleMetrics:n.chartObstacleMetrics,hardBounds:{xMin:0,xMax:i.plotWidth,yMin:0,yMax:i.plotHeight},obstacleOptions:{margin:t.algorithmMargin},startDirectionX:n.getAlgorithmStartDirection(t.startMarker)},t)))}render(){const t=this,n=t.fromPoint,i=n.series,e=i.chart,r=e.pathfinder,o={};let a=x(e.options.connectors,i.options.connectors,n.options.connectors,t.options);e.styledMode||(o.stroke=a.lineColor||n.color,o["stroke-width"]=a.lineWidth,a.dashStyle&&(o.dashstyle=a.dashStyle)),o.class="highcharts-point-connecting-path highcharts-color-"+n.colorIndex,a=x(o,a),c(a.marker.radius)||(a.marker.radius=d(l(Math.ceil((a.algorithmMargin||8)/2)-1,1),5));var s=t.getPath(a),h=s.path;s.obstacles&&(r.lineObstacles=r.lineObstacles||[],r.lineObstacles=r.lineObstacles.concat(s.obstacles)),t.renderPath(h,o,i.options.animation),t.addMarker("start",x(a.marker,a.startMarker),h),t.addMarker("end",x(a.marker,a.endMarker),h)}destroy(){this.graphics&&(i(this.graphics,function(t){t.destroy()}),delete this.graphics)}}}),n(t,"Series/PathUtilities.js",[],function(){function c(n,i){const e=[];for(let t=0;t<n.length;t++){var r,o,a,s,h,c,x=n[t][1],l=n[t][2];"number"==typeof x&&"number"==typeof l&&(0===t?e.push(["M",x,l]):t!==n.length-1&&i?(o=n[t-1],s=n[t+1],o&&s&&(r=o[1],o=o[2],a=s[1],s=s[2],"number"==typeof r&&"number"==typeof a&&"number"==typeof o&&"number"==typeof s&&r!==a&&o!==s&&(h=r<a?1:-1,c=o<s?1:-1,e.push(["L",x-h*Math.min(Math.abs(x-r),i),l-c*Math.min(Math.abs(l-o),i)],["C",x,l,x,l,x+h*Math.min(Math.abs(x-a),i),l+c*Math.min(Math.abs(l-s),i)])))):e.push(["L",x,l]))}return e}return{applyRadius:c,getLinkPath:{default:function(t){var{x1:t,y1:n,x2:i,y2:e,width:r=0,inverted:o=!1,radius:a,parentVisible:s}=t,h=[["M",t,n],["L",t,n],["C",t,n,t,e,t,e],["L",t,e],["C",t,n,t,e,t,e],["L",t,e]];return s?c([["M",t,n],["L",t+r*(o?-.5:.5),n],["L",t+r*(o?-.5:.5),e],["L",i,e]],a):h},straight:function(t){var{x1:t,y1:n,x2:i,y2:e,width:r=0,inverted:o=!1,parentVisible:a}=t;return a?[["M",t,n],["L",t+r*(o?-1:1),e],["L",i,e]]:[["M",t,n],["L",t,e],["L",t,e]]},curved:function(t){var{x1:t,y1:n,x2:i,y2:e,offset:r=0,width:o=0,inverted:a=!1,parentVisible:s}=t;return s?[["M",t,n],["C",t+r,n,t-r+o*(a?-1:1),e,t+o*(a?-1:1),e],["L",i,e]]:[["M",t,n],["C",t,n,t,e,t,e],["L",i,e]]}}}}),n(t,"Gantt/PathfinderAlgorithms.js",[t["Series/PathUtilities.js"],t["Core/Utilities.js"]],function(f,t){const C=t["pick"],{min:O,max:w,abs:k}=Math;function j(t,n,i){var e=n-1e-7;let r=i||0,o=t.length-1,a,s;for(;r<=o;)if(0<(s=e-t[a=o+r>>1].xMin))r=1+a;else{if(!(s<0))return a;o=a-1}return 0<r?r-1:0}function L(t,n){let i=j(t,n.x+1)+1;for(;i--;)if(t[i].xMax>=n.x&&(e=t[i],(r=n).x<=e.xMax&&r.x>=e.xMin&&r.y<=e.yMax&&r.y>=e.yMin))return i;var e,r;return-1}function A(n){const i=[];if(n.length){i.push(["M",n[0].start.x,n[0].start.y]);for(let t=0;t<n.length;++t)i.push(["L",n[t].end.x,n[t].end.y])}return i}function E(t,n){t.yMin=w(t.yMin,n.yMin),t.yMax=O(t.yMax,n.yMax),t.xMin=w(t.xMin,n.xMin),t.xMax=O(t.xMax,n.xMax)}function n(t,n,i){const e=[],r=i.chartObstacles,o=L(r,t),a=L(r,n);let s,h=C(i.startDirectionX,k(n.x-t.x)>k(n.y-t.y))?"x":"y",c,x,l,d,M;function p(t,n,i,e,r){const o={x:t.x,y:t.y};return o[n]=i[e||n]+(r||0),o}function y(t,n,i){var e=k(n[i]-t[i+"Min"])>k(n[i]-t[i+"Max"]);return p(n,i,t,i+(e?"Max":"Min"),e?1:-1)}return M=-1<a?(x=r[a],l=y(x,n,h),s={start:l,end:n},l):n,-1<o&&(c=r[o],l=y(c,t,h),e.push({start:t,end:l}),l[h]>=t[h]==l[h]>=M[h]&&(d=t[h="y"===h?"x":"y"]<n[h],e.push({start:l,end:p(l,h,c,h+(d?"Max":"Min"),d?1:-1)}),h="y"===h?"x":"y")),n=e.length?e[e.length-1].end:t,l=p(n,h,M),e.push({start:n,end:l}),h="y"===h?"x":"y",t=p(l,h,M),e.push({start:l,end:t}),e.push(s),{path:n=f.applyRadius(A(e),i.radius),obstacles:e}}function i(t,n,p){const i=C(p.startDirectionX,k(n.x-t.x)>k(n.y-t.y)),e=i?"x":"y",r=[],o=p.obstacleMetrics,y=O(t.x,n.x)-o.maxWidth-10,f=w(t.x,n.x)+o.maxWidth+10,u=O(t.y,n.y)-o.maxHeight-10,g=w(t.y,n.y)+o.maxHeight+10;let a,s,h,m=!1,b=p.chartObstacles,c=j(b,f);var x,l,d,M=j(b,y);function v(t,n,i){var e=t.x<n.x?1:-1;let r,o,a,s,h=(o=t.x<n.x?(r=t,n):(r=n,t),a=t.y<n.y?(s=t,n):(s=n,t),e<0?O(j(b,o.x),b.length-1):0);for(;b[h]&&(0<e&&b[h].xMin<=o.x||e<0&&b[h].xMax>=r.x);){if(b[h].xMin<=o.x&&b[h].xMax>=r.x&&b[h].yMin<=a.y&&b[h].yMax>=s.y)return i?{y:t.y,x:t.x<n.x?b[h].xMin-1:b[h].xMax+1,obstacle:b[h]}:{x:t.x,y:t.y<n.y?b[h].yMin-1:b[h].yMax+1,obstacle:b[h]};h+=e}return n}function P(t,n,i,e,r){const o=r.soft,a=r.hard,s=e?"x":"y",h={x:n.x,y:n.y},c={x:n.x,y:n.y},x=t[s+"Max"]>=o[s+"Max"],l=t[s+"Min"]<=o[s+"Min"],d=t[s+"Max"]>=a[s+"Max"],M=t[s+"Min"]<=a[s+"Min"],p=k(t[s+"Min"]-n[s]),y=k(t[s+"Max"]-n[s]);let f=k(p-y)<10?n[s]<i[s]:y<p;c[s]=t[s+"Min"],h[s]=t[s+"Max"];r=v(n,c,e)[s]!==c[s],i=v(n,h,e)[s]!==h[s];return f=r?!i||f:!i&&f,f=l?!x||f:!x&&f,f=M?!d||f:!d&&f}for(b=b.slice(M,c+1),-1<(c=L(b,n))&&(h=(M=b[c],x=n,l=t,d=O(M.xMax-x.x,x.x-M.xMin)<O(M.yMax-x.y,x.y-M.yMin),l=P(M,x,l,d,{soft:p.hardBounds,hard:p.hardBounds}),d?{y:x.y,x:M[l?"xMax":"xMin"]+(l?1:-1)}:{x:x.x,y:M[l?"yMax":"yMin"]+(l?1:-1)}),r.push({end:n,start:h}),n=h);-1<(c=L(b,n));)s=n[e]-t[e]<0,(h={x:n.x,y:n.y})[e]=b[c][s?e+"Max":e+"Min"]+(s?1:-1),r.push({end:n,start:h}),n=h;return{path:A(a=(a=function t(n,i,e){if(n.x===i.x&&n.y===i.y)return[];var r=e?"x":"y",o=p.obstacleOptions.margin,a={soft:{xMin:y,xMax:f,yMin:u,yMax:g},hard:p.hardBounds};let s,h,c,x,l,d,M;return-1<(l=L(b,n))?(l=b[l],x=P(l,n,i,e,a),E(l,p.hardBounds),M=e?{y:n.y,x:l[x?"xMax":"xMin"]+(x?1:-1)}:{x:n.x,y:l[x?"yMax":"yMin"]+(x?1:-1)},-1<(d=L(b,M))&&(E(d=b[d],p.hardBounds),M[r]=x?w(l[r+"Max"]-o+1,(d[r+"Min"]+l[r+"Max"])/2):O(l[r+"Min"]+o-1,(d[r+"Max"]+l[r+"Min"])/2),m=n.x===M.x&&n.y===M.y&&(m&&(M[r]=x?w(l[r+"Max"],d[r+"Max"])+1:O(l[r+"Min"],d[r+"Min"])-1),!m)),h=[{start:n,end:M}]):(s=v(n,{x:(e?i:n).x,y:(e?n:i).y},e),h=[{start:n,end:{x:s.x,y:s.y}}],s[e?"x":"y"]!==i[e?"x":"y"]&&(x=P(s.obstacle,s,i,!e,a),E(s.obstacle,p.hardBounds),c={x:e?s.x:s.obstacle[x?"xMax":"xMin"]+(x?1:-1),y:e?s.obstacle[x?"yMax":"yMin"]+(x?1:-1):s.y},e=!e,h=h.concat(t({x:s.x,y:s.y},c,e)))),h=h.concat(t(h[h.length-1].end,i,!e))}(t,n,i)).concat(r.reverse())),obstacles:a}}return i.requiresObstacles=n.requiresObstacles=!0,{fastAvoid:i,straight:function(t,n){return{path:[["M",t.x,t.y],["L",n.x,n.y]],obstacles:[{start:t,end:n}]}},simpleConnect:n}}),n(t,"Gantt/ConnectorsDefaults.js",[],function(){return{connectors:{type:"straight",radius:0,lineWidth:1,marker:{enabled:!1,align:"center",verticalAlign:"middle",inside:!1,lineWidth:1},startMarker:{symbol:"diamond"},endMarker:{symbol:"arrow-filled"}}}}),n(t,"Gantt/PathfinderComposition.js",[t["Gantt/ConnectorsDefaults.js"],t["Core/Defaults.js"],t["Core/Utilities.js"]],function(r,t,n){const o=t["setOptions"],{defined:e,error:a,merge:s,pushUnique:h}=n;function g(t){var n=t.shapeArgs;if(n)return{xMin:n.x||0,xMax:(n.x||0)+(n.width||0),yMin:n.y||0,yMax:(n.y||0)+(n.height||0)};n=t.graphic&&t.graphic.getBBox();return n?{xMin:t.plotX-n.width/2,xMax:t.plotX+n.width/2,yMin:t.plotY-n.height/2,yMax:t.plotY+n.height/2}:null}var i;{t=i=i||{};const d=[];function c(t){var n=g(this);let i,e;switch(t.align){case"right":i="xMax";break;case"left":i="xMin"}switch(t.verticalAlign){case"top":e="yMin";break;case"bottom":e="yMax"}return{x:i?n[i]:(n.xMin+n.xMax)/2,y:e?n[e]:(n.yMin+n.yMax)/2}}function x(t,n){var i;return e(n)||(i=g(this))&&(n={x:(i.xMin+i.xMax)/2,y:(i.yMin+i.yMax)/2}),Math.atan2(n.y-t.y,t.x-n.x)}function l(t,n,i){const e=2*Math.PI,r=g(this),o=r.xMax-r.xMin,a=r.yMax-r.yMin,s=Math.atan2(a,o),h=o/2,c=a/2,x=r.xMin+h,l=r.yMin+c,d={x:x,y:l};let M=t,p,y=!1,f=1,u=1;for(;M<-Math.PI;)M+=e;for(;M>Math.PI;)M-=e;return p=Math.tan(M),M>-s&&M<=s?(u=-1,y=!0):M>s&&M<=Math.PI-s?u=-1:M>Math.PI-s||M<=-(Math.PI-s)?(f=-1,y=!0):f=-1,y?(d.x+=f*h,d.y+=u*h*p):(d.x+=f*(a/(2*p)),d.y+=u*c),i.x!==x&&(d.x=i.x),i.y!==l&&(d.y=i.y),{x:d.x+n*Math.cos(M),y:d.y-n*Math.sin(M)}}t.compose=function(t,n,i){if(h(d,t)&&t.prototype.callbacks.push(function(t){!1!==t.options.connectors.enabled&&(((t=t).options.pathfinder||t.series.reduce(function(t,n){return n.options&&s(!0,n.options.connectors=n.options.connectors||{},n.options.pathfinder),t||n.options&&n.options.pathfinder},!1))&&(s(!0,t.options.connectors=t.options.connectors||{},t.options.pathfinder),a('WARNING: Pathfinder options have been renamed. Use "chart.connectors" or "series.connectors" instead.')),this.pathfinder=new n(this),this.pathfinder.update(!0))}),h(d,i)){const e=i.prototype;e.getMarkerVector=l,e.getPathfinderAnchorPoint=c,e.getRadiansToVector=x}h(d,o)&&o(r)}}return i}),n(t,"Gantt/Pathfinder.js",[t["Gantt/Connection.js"],t["Gantt/PathfinderAlgorithms.js"],t["Gantt/PathfinderComposition.js"],t["Core/Series/Point.js"],t["Core/Utilities.js"]],function(c,t,i,x,n){const{addEvent:e,defined:r,pick:l,splat:d}=n,a=Math.max,h=Math.min;function M(i){const e=i.length,r=[];var o;for(let n=0;n<e;++n)for(let t=n+1;t<e;++t)(o=function t(n,i,e){var e=l(e,10),r=n.yMax+e>i.yMin-e&&n.yMin-e<i.yMax+e,o=n.xMax+e>i.xMin-e&&n.xMin-e<i.xMax+e,a=r?n.xMin>i.xMax?n.xMin-i.xMax:i.xMin-n.xMax:1/0,s=o?n.yMin>i.yMax?n.yMin-i.yMax:i.yMin-n.yMax:1/0;return o&&r?e?t(n,i,Math.floor(e/2)):1/0:h(a,s)}(i[n],i[t]))<80&&r.push(o);return r.push(80),a(Math.floor(r.sort(function(t,n){return t-n})[Math.floor(r.length/10)]/2-1),1)}class o{static compose(t,n){i.compose(t,o,n)}constructor(t){this.chart=void 0,this.chartObstacles=void 0,this.chartObstacleMetrics=void 0,this.connections=void 0,this.group=void 0,this.lineObstacles=void 0,this.init(t)}init(t){this.chart=t,this.connections=[],e(t,"redraw",function(){this.pathfinder.update()})}update(t){const r=this.chart,o=this,a=o.connections;o.connections=[],r.series.forEach(function(t){t.visible&&!t.options.isInternal&&t.points.forEach(function(n){const t=n.options,i=(t&&t.dependency&&(t.connect=t.dependency),n.options?.connect&&d(n.options.connect));let e;n.visible&&!1!==n.isInside&&i&&i.forEach(function(t){(e=r.get("string"==typeof t?t:t.to))instanceof x&&e.series.visible&&e.visible&&!1!==e.isInside&&o.connections.push(new c(n,e,"string"==typeof t?{}:t))})})});for(let t=0,n,i,e=a.length,r=o.connections.length;t<e;++t){i=!1;const s=a[t];for(n=0;n<r;++n){const h=o.connections[n];if((s.options&&s.options.type)===(h.options&&h.options.type)&&s.fromPoint===h.fromPoint&&s.toPoint===h.toPoint){h.graphics=s.graphics,i=!0;break}}i||s.destroy()}delete this.chartObstacles,delete this.lineObstacles,o.renderConnections(t)}renderConnections(t){t?this.chart.series.forEach(function(i){function t(){const t=i.chart.pathfinder,n=t&&t.connections||[];n.forEach(function(t){t.fromPoint&&t.fromPoint.series===i&&t.render()}),i.pathfinderRemoveRenderEvent&&(i.pathfinderRemoveRenderEvent(),delete i.pathfinderRemoveRenderEvent)}!1===i.options.animation?t():i.pathfinderRemoveRenderEvent=e(i,"afterAnimate",t)}):this.connections.forEach(function(t){t.render()})}getChartObstacles(t){var o,a,s=this.chart.series,h=l(t.algorithmMargin,0);let c=[],n;for(let r=0,t=s.length;r<t;++r)if(s[r].visible&&!s[r].options.isInternal)for(let t=0,n=s[r].points.length,i,e;t<n;++t)(e=s[r].points[t]).visible&&(a=void 0,(i=(a=(o=e).shapeArgs)?{xMin:a.x||0,xMax:(a.x||0)+(a.width||0),yMin:a.y||0,yMax:(a.y||0)+(a.height||0)}:(a=o.graphic&&o.graphic.getBBox())?{xMin:o.plotX-a.width/2,xMax:o.plotX+a.width/2,yMin:o.plotY-a.height/2,yMax:o.plotY+a.height/2}:null)&&c.push({xMin:i.xMin-h,xMax:i.xMax+h,yMin:i.yMin-h,yMax:i.yMax+h}));return c=c.sort(function(t,n){return t.xMin-n.xMin}),r(t.algorithmMargin)||(n=t.algorithmMargin=M(c),c.forEach(function(t){t.xMin-=n,t.xMax+=n,t.yMin-=n,t.yMax+=n})),c}getObstacleMetrics(t){let n=0,i=0,e,r,o=t.length;for(;o--;)e=t[o].xMax-t[o].xMin,r=t[o].yMax-t[o].yMin,n<e&&(n=e),i<r&&(i=r);return{maxHeight:i,maxWidth:n}}getAlgorithmStartDirection(t){var n="left"!==t.align&&"right"!==t.align,t="top"!==t.verticalAlign&&"bottom"!==t.verticalAlign;return n?t&&void 0:t||void 0}}return o.prototype.algorithms=t,o}),n(t,"Extensions/ArrowSymbols.js",[t["Core/Utilities.js"]],function(i){const e=[];function r(t,n,i,e){return[["M",t,n+e/2],["L",t+i,n],["L",t,n+e/2],["L",t+i,n+e]]}function o(t,n,i,e){return r(t,n,i/2,e)}function a(t,n,i,e){return[["M",t+i,n],["L",t,n+e/2],["L",t+i,n+e],["Z"]]}function s(t,n,i,e){return a(t,n,i/2,e)}return{compose:function(t){if(i.pushUnique(e,t)){const n=t.prototype.symbols;n.arrow=r,n["arrow-filled"]=a,n["arrow-filled-half"]=s,n["arrow-half"]=o,n["triangle-left"]=a,n["triangle-left-half"]=s}}}}),n(t,"masters/modules/pathfinder.src.js",[t["Core/Globals.js"],t["Gantt/Pathfinder.js"],t["Extensions/ArrowSymbols.js"]],function(t,n,i){const e=t;e.Pathfinder=n,i.compose(e.SVGRenderer),n.compose(e.Chart,e.Point)})});