!function(o){"object"==typeof module&&module.exports?module.exports=o.default=o:"function"==typeof define&&define.amd?define("highcharts/modules/flowmap",["highcharts"],function(t){return o(t),o.Highcharts=t,o}):o("undefined"!=typeof Highcharts?Highcharts:void 0)}(function(t){"use strict";t=t?t._modules:{};function o(t,o,i,s){t.hasOwnProperty(o)||(t[o]=s.apply(null,i),"function"==typeof CustomEvent&&window.dispatchEvent(new CustomEvent("HighchartsModuleLoaded",{detail:{path:o,module:t[o]}})))}o(t,"Series/FlowMap/FlowMapPoint.js",[t["Core/Series/SeriesRegistry.js"],t["Core/Utilities.js"]],function(t,o){var{prototype:{pointClass:t}}=t["seriesTypes"]["mapline"];const{pick:i,isString:s,isNumber:e}=o;class r extends t{constructor(){super(...arguments),this.options=void 0,this.series=void 0}isValid(){let o=!(!this.options.to||!this.options.from);return[this.options.to,this.options.from].forEach(function(t){o=!!(o&&t&&(s(t)||e(i(t[0],t.lat))&&e(i(t[1],t.lon))))}),o}}return r}),o(t,"Series/FlowMap/FlowMapSeries.js",[t["Series/FlowMap/FlowMapPoint.js"],t["Core/Series/SeriesRegistry.js"],t["Core/Utilities.js"]],function(t,o,i){const{series:{prototype:{pointClass:c}},seriesTypes:{column:s,map:e,mapline:r}}=o,{addEvent:f,arrayMax:n,arrayMin:a,defined:W,extend:h,isArray:m,merge:b,pick:C,relativeLength:k}=i;class E extends r{constructor(){super(...arguments),this.data=void 0,this.options=void 0,this.points=void 0,this.smallestWeight=void 0,this.greatestWeight=void 0,this.centerOfPoints=void 0}static getLength(t,o){return Math.sqrt(t*t+o*o)}static normalize(t,o){var i=this.getLength(t,o);return[t/i,o/i]}static markerEndPath(t,o,i,s){var e,r,n=k(s.width||0,this.getLength(o[0]-t[0],o[1]-t[1])),s=s.markerType||"arrow",[a,h]=this.normalize(o[0]-t[0],o[1]-t[1]);const p=[];return"arrow"===s&&([e,r]=t,e-=a*n,r-=h*n,p.push(["L",e,r]),p.push(["L",i[0],i[1]]),[e,r]=o,e+=a*n,r+=h*n,p.push(["L",e,r])),"mushroom"===s&&([e,r]=t,[s,t]=o,[o,i]=i,o=2*(o-(o=(s-e)/2+e))+o,i=2*(i-(i=(t-r)/2+r))+i,e-=a*n,r-=h*n,p.push(["L",e,r]),s+=a*n,t+=h*n,p.push(["Q",o,i,s,t])),p}animate(t){const o=this.points;t||o.forEach(t=>{if(t.shapeArgs&&m(t.shapeArgs.d)&&t.shapeArgs.d.length){var i=t.shapeArgs.d,s=i[0][1],e=i[0][2];if(s&&e){const r=[];for(let o=0;o<i.length;o++){r.push([...i[o]]);for(let t=1;t<i[o].length;t++)r[o][t]=t%2?s:e}t.graphic&&(t.graphic.attr({d:r}),t.graphic.animate({d:i}))}}})}getLinkWidth(t){var o=this.options.width,i=t.options.weight||this.options.weight;if(t.options.weight=i,o&&!i)return o;t=this.smallestWeight,o=this.greatestWeight;if(!W(i)||!t||!o)return 0;var s=this.options.minWidth;return(i-t)*(this.options.maxWidth-s)/(o-t||1)+s}autoCurve(t,o,i,s,e,r){const n=i-t,a=s-o,h=(i-t)/2+t,p=(s-o)/2+o,l=h-e,d=p-r;i=n*l+a*d,t=n*d-a*l;let c=Math.atan2(t,i),f=180*c/Math.PI;return c=(f=f<0?360+f:f)*Math.PI/180,.7*-Math.sin(c)}pointAttribs(t,o){const i=e.prototype.pointAttribs.call(this,t,o);return i.fill=C(t.options.fillColor,t.options.color,"none"===this.options.fillColor?null:this.options.fillColor,this.color),i["fill-opacity"]=C(t.options.fillOpacity,this.options.fillOpacity),i["stroke-width"]=C(t.options.lineWidth,this.options.lineWidth,1),t.options.opacity&&(i.opacity=t.options.opacity),i}translate(){!this.chart.hasRendered||!this.isDirtyData&&this.hasRendered||(this.processData(),this.generatePoints());const p=[];let l=0,d=0;this.points.forEach(t=>{const o=this.chart,i=o.mapView,s=t.options,e=()=>{t.series.isDirty=!0},r=t=>{t=o.get(t);if(t instanceof c&&t.plotX&&t.plotY)return f(t,"update",e),{x:t.plotX,y:t.plotY}},n=t=>m(t)?{lon:t[0],lat:t[1]}:t;let a,h;"string"==typeof s.from?a=r(s.from):"object"==typeof s.from&&i&&(a=i.lonLatToPixels(n(s.from))),"string"==typeof s.to?h=r(s.to):"object"==typeof s.to&&i&&(h=i.lonLatToPixels(n(s.to))),t.fromPos=a,t.toPos=h,a&&h&&(l+=(a.x+h.x)/2,d+=(a.y+h.y)/2),C(t.options.weight,this.options.weight)&&p.push(C(t.options.weight,this.options.weight))}),this.smallestWeight=a(p),this.greatestWeight=n(p),this.centerOfPoints={x:l/this.points.length,y:d/this.points.length},this.points.forEach(t=>{this.getLinkWidth(t)?(t.fromPos&&(t.plotX=t.fromPos.x,t.plotY=t.fromPos.y),t.shapeType="path",t.shapeArgs=this.getPointShapeArgs(t),t.color=C(t.options.color,t.series.color)):t.shapeArgs={d:[]}})}getPointShapeArgs(t){var{fromPos:o,toPos:i}=t;if(!o||!i)return{};var s=this.getLinkWidth(t)/2,e=t.options,r=b(this.options.markerEnd,e.markerEnd),n=C(e.growTowards,this.options.growTowards),a=o.x||0,o=o.y||0;let h=i.x||0,p=i.y||0,l=C(e.curveFactor,this.options.curveFactor),d=r&&r.enabled&&r.height||0;if(W(l)||(l=this.autoCurve(a,o,h,p,this.centerOfPoints.x,this.centerOfPoints.y)),d){d=k(d,4*s);var e=h-a,c=p-o;const f=a+(e*=.5),m=o+(c*=.5),g=e,v=(e=c,c=-g,f+e*l),P=m+c*l;var[e,c]=E.normalize(v-h,P-p);e*=d,c*=d,h+=e,p+=c}e=h-a,c=p-o;const f=a+(e*=.5),m=o+(c*=.5);let g=e,[u,y]=(e=c,c=-g,E.normalize(e,c));var w=1+.25*Math.sqrt(l*l);u*=s*w,y*=s*w;const v=f+e*l,P=m+c*l;let[x,M]=E.normalize(v-a,P-o);g=x,x=M,M=-g,x*=s,M*=s;var[w,e]=E.normalize(v-h,P-p);g=w,w=-e,e=g,w*=s,e*=s,n&&(x/=s,M/=s,u/=4,y/=4);const L={d:[["M",a-x,o-M],["Q",v-u,P-y,h-w,p-e],["L",h+w,p+e],["Q",v+u,P+y,a+x,o+M],["Z"]]};r&&r.enabled&&L.d&&(c=E.markerEndPath([h-w,p-e],[h+w,p+e],[i.x,i.y],r),L.d.splice(2,0,...c));n=t.options.from,s=t.options.to,a=n.lat,o=n.lon,w=s.lat,e=s.lon;return a&&o&&(t.options.from=+a+", "+ +o),w&&e&&(t.options.to=+w+", "+ +e),L}}return E.defaultOptions=b(r.defaultOptions,{animation:!0,dataLabels:{enabled:!1},fillOpacity:.5,markerEnd:{enabled:!0,height:"40%",width:"40%",markerType:"arrow"},width:1,maxWidth:25,minWidth:5,lineWidth:void 0,tooltip:{headerFormat:'<span style="font-size: 0.8em">{series.name}</span><br/>',pointFormat:"{point.options.from} â†’ {point.options.to}: <b>{point.options.weight}</b>"}}),h(E.prototype,{pointClass:t,pointArrayMap:["from","to","weight"],drawPoints:s.prototype.drawPoints,useMapGeometry:!0}),o.registerSeriesType("flowmap",E),E}),o(t,"masters/modules/flowmap.src.js",[],function(){})});