"use strict";import Component from"../Components/Component.js";import DataModifier from"../../Data/Modifiers/DataModifier.js";const RangeModifier=DataModifier.types["Range"];import Globals from"../Globals.js";import NavigatorComponentDefaults from"./NavigatorComponentDefaults.js";import U from"../../Core/Utilities.js";const{addEvent,diffObjects,isNumber,merge,pick}=U,navigatorComponentSync={crossfilter:{emitter:crossfilterEmitter},extremes:{emitter:extremesEmitter,handler:extremesReceiver}};function crossfilterEmitter(){const c=this,e=async(e,n)=>{if(c.connector){const i=c.connector.table,o=c.board.dataCursor,s=c.getColumnAssignment()[0],[r,a]=getAxisExtremes(e,n);let t=i.getModifier();t instanceof RangeModifier?setRangeOptions(t.options.ranges,s,r,a):t=new RangeModifier({ranges:[{column:s,maxValue:a,minValue:r}]}),await i.setModifier(t),o.emitCursor(i,{type:"range",columns:[s],firstRow:0,lastRow:i.getRowCount()-1,state:"crossfilter"},n)}};let n;return addEvent(c.chart.xAxis[0],"afterSetExtremes",function(t){clearTimeout(n),n=setTimeout(e,50,this,t)})}function extremesEmitter(){const a=this,e=(t,e)=>{if(a.connector){const n=a.connector.table,i=a.board.dataCursor,o=a.getColumnAssignment()[0],[s,r]=getAxisExtremes(t,e);i.emitCursor(n,{type:"position",column:o,row:n.getRowIndexBy(o,s),state:"xAxis.extremes.min"},e),i.emitCursor(n,{type:"position",column:o,row:n.getRowIndexBy(o,r),state:"xAxis.extremes.max"},e)}};let n;return addEvent(a.chart.xAxis[0],"afterSetExtremes",function(t){clearTimeout(n),n=setTimeout(e,50,this,t)})}function extremesReceiver(){const c=this,e=c.board.dataCursor,n=i=>{i=i.cursor;if(c.connector){const o=c.connector.table;let t=o.getColumnNames()[0],e=o.getRowCount(),n=0;"range"===i.type?(e=i.lastRow,n=i.firstRow,i.columns&&(t=pick(i.columns[0],t))):"xAxis.extremes.max"===i.state?(t=pick(i.column,t),e=pick(i.row,e)):(t=pick(i.column,t),n=pick(i.row,n));i=o.getModifier();if("string"==typeof t&&i instanceof RangeModifier){const s=i.options.ranges,r=o.getCell(t,n),a=o.getCell(t,e);null!=a&&null!=r&&(unsetRangeOptions(s,t),s.unshift({column:t,maxValue:a,minValue:r}),o.setModifier(i))}}},t=()=>{var t=c.connector&&c.connector.table;t&&(e.addListener(t.id,"xAxis.extremes",n),e.addListener(t.id,"xAxis.extremes.max",n),e.addListener(t.id,"xAxis.extremes.min",n))};t(),c.on("setConnector",()=>{var t=c.connector&&c.connector.table;t&&(e.removeListener(t.id,"xAxis.extremes",n),e.removeListener(t.id,"xAxis.extremes.max",n),e.removeListener(t.id,"xAxis.extremes.min",n))}),c.on("afterSetConnector",()=>t())}function getAxisExtremes(t,e){var n="number"==typeof e.max?e.max:e.dataMax,e="number"==typeof e.min?e.min:e.dataMin;return t.hasNames?[t.names[Math.round(e)],t.names[Math.round(n)]]:[e,n]}function setRangeOptions(n,i,o,s){let r=!1;for(let t=0,e=n.length;t<e;++t)if(n[t].column===i){n[t].maxValue=s,n[t].minValue=o,r=!0;break}r||n.push({column:i,maxValue:s,minValue:o})}function unsetRangeOptions(n,i){for(let t=0,e=n.length;t<e;++t)if(n[t].column===i)return n.splice(t,1)[0]}class NavigatorComponent extends Component{static fromJSON(t,e){const n=t.options,i=new NavigatorComponent(e,n);return i.emit({type:"fromJSON",json:t}),i}constructor(t,e){super(t,e),this.options=merge(NavigatorComponent.defaultOptions,e);const n=NavigatorComponent.charter||Globals.win.Highcharts;this.chartContainer=Globals.win.document.createElement("div"),this.chart=n.chart(this.chartContainer,this.options.chartOptions||{}),this.chartContainer.classList.add(Globals.classNamePrefix+"navigator"),this.filterAndAssignSyncOptions(navigatorComponentSync),this.sync=new NavigatorComponent.Sync(this,this.syncHandlers),this.options.sync.crossfilter&&this.chart.update({navigator:{xAxis:{labels:{format:"{value}"}}}},!1)}adjustNavigator(){const t=this.chart,e=pick(t.chartHeight,this.contentElement.clientHeight),n=this.contentElement.clientWidth,i={};if(t.chartHeight===e&&t.chartWidth===n||(i.chart={height:e,width:n}),t.navigator){const o=t.navigator,s=o.top-t.plotTop+o.height;o.height!==s&&(i.navigator={handles:{height:Math.round(e/4)},height:s}),Object.keys(i).length&&t.update(i,!1),o.series&&o.series[0]&&o.series[0].update({type:t.series[0].type},!1)}else Object.keys(i).length&&t.update(i,!1)}getColumnAssignment(){var t,e=this.options.columnAssignments||{};for(const i of Object.keys(e))if(null!==(t=e[i]))return[i,t];if(this.connector){var n=this.connector.table.getColumnNames();if(n.length)return[n[0],"y"]}return["","y"]}getOptions(){return{...diffObjects(this.options,NavigatorComponentDefaults),type:"Navigator"}}async load(){return await super.load(),this.contentElement.appendChild(this.chartContainer),this.parentElement.appendChild(this.element),this.adjustNavigator(),this.emit({type:"afterLoad"}),this}onTableChanged(){this.renderNavigator()}redrawNavigator(){const n=this.resizeTimeouts;for(let t=0,e=n.length;t<e;++t)clearTimeout(n[t]);n.length=0,n.push(setTimeout(()=>{this.adjustNavigator(),this.chart.redraw()},33))}render(){return super.render(),this.renderNavigator(),this.sync.start(),this.emit({type:"afterRender"}),this}renderNavigator(){const t=this.chart;if(this.connector){const i=this.connector.table,o=this.options,s=this.getColumnAssignment(),r=i.getColumn(s[0],!0)||[];let e;if(o.sync.crossfilter){const a=[],c=[];let t;for(var n of r)null!==n&&(isNumber(n)||(n=""+n),-1===(t=c.indexOf(n))?(t=c.length,c[t]=n,a[t]=[n,1]):a[t][1]=a[t][1]+1);a.sort((t,e)=>pick(t[0],NaN)<pick(e[0],NaN)?-1:t[0]===e[0]?0:1),e=a}else e=(r[0],r.slice());t.series[0]?t.series[0].setData(e,!1):t.addSeries({id:i.id,data:e},!1)}this.redrawNavigator()}resize(t,e){return super.resize(t,e),this.redrawNavigator(),this}async update(t,e=!0){const n=this.chart;await super.update(t,!1),t.sync&&this.filterAndAssignSyncOptions(navigatorComponentSync),t.chartOptions&&n.update(merge(this.options.sync.crossfilter?{navigator:{xAxis:{labels:{format:"{value}"}}}}:{},t.chartOptions),!1),this.emit({type:"afterUpdate"}),e&&this.render()}}NavigatorComponent.defaultOptions=merge(Component.defaultOptions,NavigatorComponentDefaults);export default NavigatorComponent;